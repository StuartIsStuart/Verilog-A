
// Generated from VerilogParser.g4 by ANTLR 4.13.2


#include "VerilogParserVisitor.h"

#include "VerilogParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct VerilogParserStaticData final {
  VerilogParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  VerilogParserStaticData(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData(VerilogParserStaticData&&) = delete;
  VerilogParserStaticData& operator=(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData& operator=(VerilogParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag verilogparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<VerilogParserStaticData> verilogparserParserStaticData = nullptr;

void verilogparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (verilogparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(verilogparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<VerilogParserStaticData>(
    std::vector<std::string>{
      "library_text", "library_description", "library_declaration", "library_incdir", 
      "include_statement", "file_path_spec", "source_text", "description", 
      "module_declaration", "module_keyword", "module_parameter_port_list", 
      "list_of_port_declarations", "port", "port_implicit", "port_explicit", 
      "port_expression", "port_reference", "port_declaration", "module_item", 
      "module_or_generate_item", "module_or_generate_item_declaration", 
      "parameter_override", "config_declaration", "design_statement", "design_statement_item", 
      "config_rule_statement", "default_clause", "inst_clause", "inst_name", 
      "cell_clause", "liblist_clause", "use_clause", "local_parameter_declaration", 
      "parameter_declaration", "specparam_declaration", "parameter_type", 
      "inout_declaration", "input_declaration", "output_declaration", "event_declaration", 
      "integer_declaration", "net_declaration", "real_declaration", "realtime_declaration", 
      "reg_declaration", "time_declaration", "net_type", "discipline_declaration", 
      "nature_declaration", "electrical_declaration", "output_variable_type", 
      "real_type", "variable_type", "drive_strength", "strength0", "strength1", 
      "charge_strength", "delay3", "delay2", "delay_value", "list_of_defparam_assignments", 
      "list_of_event_identifiers", "event_id", "list_of_net_decl_assignments", 
      "list_of_net_identifiers", "net_id", "list_of_param_assignments", 
      "list_of_port_identifiers", "list_of_real_identifiers", "list_of_specparam_assignments", 
      "list_of_variable_identifiers", "list_of_variable_port_identifiers", 
      "var_port_id", "defparam_assignment", "net_decl_assignment", "param_assignment", 
      "specparam_assignment", "pulse_control_specparam", "error_limit_value", 
      "reject_limit_value", "limit_value", "dimension", "range_", "function_declaration", 
      "function_item_declaration", "function_port_list", "func_port_item", 
      "function_range_or_type", "task_declaration", "task_item_declaration", 
      "task_port_list", "task_port_item", "tf_input_declaration", "tf_output_declaration", 
      "tf_inout_declaration", "task_port_type", "block_item_declaration", 
      "list_of_block_variable_identifiers", "list_of_block_real_identifiers", 
      "block_variable_type", "block_real_type", "gate_instantiation", "cmos_switch_instance", 
      "enable_gate_instance", "mos_switch_instance", "n_input_gate_instance", 
      "n_output_gate_instance", "pass_switch_instance", "pass_enable_switch_instance", 
      "pull_gate_instance", "name_of_gate_instance", "pulldown_strength", 
      "pullup_strength", "enable_terminal", "inout_terminal", "input_terminal", 
      "ncontrol_terminal", "output_terminal", "pcontrol_terminal", "cmos_switchtype", 
      "enable_gatetype", "mos_switchtype", "n_input_gatetype", "n_output_gatetype", 
      "pass_en_switchtype", "pass_switchtype", "module_instantiation", "parameter_value_assignment", 
      "list_of_parameter_assignments", "ordered_parameter_assignment", "named_parameter_assignment", 
      "module_instance", "name_of_module_instance", "list_of_port_connections", 
      "ordered_port_connection", "named_port_connection", "generate_region", 
      "genvar_declaration", "list_of_genvar_identifiers", "loop_generate_construct", 
      "genvar_initialization", "genvar_expression", "genvar_iteration", 
      "conditional_generate_construct", "if_generate_construct", "case_generate_construct", 
      "case_generate_item", "generate_block", "generate_block_name", "generate_block_or_null", 
      "udp_declaration", "udp_port_list", "udp_declaration_port_list", "udp_port_declaration", 
      "udp_output_declaration", "udp_input_declaration", "udp_reg_declaration", 
      "udp_body", "combinational_body", "combinational_entry", "sequential_body", 
      "udp_initial_statement", "init_val", "sequential_entry", "seq_input_list", 
      "level_input_list", "edge_input_list", "edge_indicator", "current_state", 
      "next_state", "output_symbol", "level_symbol", "edge_symbol", "udp_instantiation", 
      "udp_instance", "name_of_udp_instance", "continuous_assign", "list_of_net_assignments", 
      "net_assignment", "initial_construct", "always_construct", "analog_construct", 
      "blocking_assignment", "nonblocking_assignment", "analog_assignment", 
      "procedural_continuous_assignments", "variable_assignment", "par_block", 
      "block_name", "seq_block", "statement", "statement_or_null", "function_statement", 
      "delay_control", "delay_or_event_control", "disable_statement", "event_control", 
      "event_trigger", "event_expression", "procedural_timing_control", 
      "procedural_timing_control_statement", "wait_statement", "conditional_statement", 
      "case_statement", "case_item", "loop_statement", "system_task_enable", 
      "sys_task_en_port_list", "sys_task_en_port_item", "task_enable", "task_en_port_list", 
      "specify_block", "specify_item", "pulsestyle_declaration", "showcancelled_declaration", 
      "path_declaration", "simple_path_declaration", "parallel_path_description", 
      "full_path_description", "list_of_path_inputs", "list_of_path_outputs", 
      "specify_input_terminal_descriptor", "specify_output_terminal_descriptor", 
      "input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions", 
      "t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression", 
      "tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression", 
      "t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression", 
      "tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression", 
      "t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression", 
      "tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration", 
      "parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description", 
      "data_source_expression", "edge_identifier", "state_dependent_path_declaration", 
      "polarity_operator", "system_timing_check", "setup_timing_check", 
      "notifier_opt", "hold_timing_check", "setuphold_timing_check", "timing_check_opt", 
      "stamptime_cond_opt", "checktime_cond_opt", "delayed_ref_opt", "delayed_data_opt", 
      "recovery_timing_check", "removal_timing_check", "recrem_timing_check", 
      "skew_timing_check", "timeskew_timing_check", "skew_timing_check_opt", 
      "event_based_flag_opt", "remain_active_flag_opt", "fullskew_timing_check", 
      "period_timing_check", "width_timing_check", "threshold_opt", "nochange_timing_check", 
      "checktime_condition", "controlled_reference_event", "data_event", 
      "delayed_data", "delayed_reference", "end_edge_offset", "event_based_flag", 
      "notifier", "reference_event", "remain_active_flag", "stamptime_condition", 
      "start_edge_offset", "threshold", "timing_check_limit", "timing_check_event", 
      "controlled_timing_check_event", "timing_check_event_control", "specify_terminal_descriptor", 
      "edge_control_specifier", "edge_descriptor", "timing_check_condition", 
      "scalar_timing_check_condition", "scalar_constant", "concatenation", 
      "constant_concatenation", "constant_multiple_concatenation", "module_path_concatenation", 
      "module_path_multiple_concatenation", "multiple_concatenation", "constant_function_call", 
      "constant_system_function_call", "function_call", "system_function_call", 
      "sys_func_call_port_list", "base_expression", "constant_base_expression", 
      "constant_expression", "constant_mintypmax_expression", "constant_range_expression", 
      "dimension_constant_expression", "expression", "lsb_constant_expression", 
      "mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression", 
      "msb_constant_expression", "range_expression", "width_constant_expression", 
      "constant_primary", "module_path_primary", "primary", "select_", "bit_select", 
      "net_lvalue", "const_select", "const_bit_select", "variable_lvalue", 
      "unary_operator", "unary_module_path_operator", "number", "real_number", 
      "decimal_number", "binary_number", "octal_number", "hex_number", "size", 
      "fixed_point_number", "exponential_number", "unsigned_number", "decimal_value", 
      "binary_value", "octal_value", "hex_value", "decimal_base", "binary_base", 
      "octal_base", "hex_base", "string_", "attribute_instance", "attr_spec", 
      "attr_name", "block_identifier", "cell_identifier", "config_identifier", 
      "escaped_identifier", "event_identifier", "function_identifier", "gate_instance_identifier", 
      "generate_block_identifier", "genvar_identifier", "hierarchical_identifier", 
      "hier_ref", "identifier", "input_port_identifier", "instance_identifier", 
      "library_identifier", "module_identifier", "module_instance_identifier", 
      "net_identifier", "output_port_identifier", "parameter_identifier", 
      "port_identifier", "real_identifier", "simple_identifier", "specparam_identifier", 
      "system_function_identifier", "system_task_identifier", "task_identifier", 
      "terminal_identifier", "topmodule_identifier", "udp_identifier", "udp_instance_identifier", 
      "variable_identifier"
    },
    std::vector<std::string>{
      "", "'always'", "'and'", "'assign'", "'automatic'", "'begin'", "'buf'", 
      "'bufif1'", "'bufif0'", "'case'", "'casex'", "'casez'", "'cell'", 
      "'cmos'", "'config'", "'deassign'", "'default'", "'defparam'", "'design'", 
      "'disable'", "'$fullskew'", "'$hold'", "'$nochange'", "'$period'", 
      "'$recovery'", "'$recrem'", "'$removal'", "'$setup'", "'$setuphold'", 
      "'$skew'", "'$timeskew'", "'$width'", "'edge'", "'else'", "'end'", 
      "'endcase'", "'endconfig'", "'endfunction'", "'endgenerate'", "'endmodule'", 
      "'endprimitive'", "'endspecify'", "'endtable'", "'endtask'", "'event'", 
      "'for'", "'force'", "'forever'", "'fork'", "'function'", "'generate'", 
      "'genvar'", "'highz1'", "'highz0'", "'if'", "'ifnone'", "'include'", 
      "'initial'", "'inout'", "'input'", "'instance'", "'integer'", "'join'", 
      "'large'", "'liblist'", "'library'", "'localparam'", "'macromodule'", 
      "'medium'", "'-incdir'", "'module'", "'nand'", "'negedge'", "'nmos'", 
      "'nor'", "'noshowcancelled'", "'not'", "'notif1'", "'notif0'", "'or'", 
      "'output'", "'parameter'", "'PATHPULSE$'", "'pmos'", "'posedge'", 
      "'primitive'", "'pulldown'", "'pull1'", "'pullup'", "'pull0'", "'pulsestyle_ondetect'", 
      "'pulsestyle_onevent'", "'rcmos'", "'real'", "'realtime'", "'reg'", 
      "'release'", "'repeat'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif1'", 
      "'rtranif0'", "'scalared'", "'showcancelled'", "'signed'", "'small'", 
      "'specify'", "'specparam'", "'strong1'", "'strong0'", "'supply1'", 
      "'supply0'", "'table'", "'task'", "'time'", "'tran'", "'tranif1'", 
      "'tranif0'", "'tri'", "'triand'", "'tri1'", "'trior'", "'trireg'", 
      "'tri0'", "'use'", "'uwire'", "'vectored'", "'wait'", "'wand'", "'weak1'", 
      "'weak0'", "'while'", "'wire'", "'wor'", "'xnor'", "'xor'", "'analog'", 
      "'electrical'", "'branch'", "'discipline'", "'nature'", "'<+'", "'&&&'", 
      "'!=='", "'==='", "'>>>'", "'<<<'", "'-:'", "'->'", "'<='", "'<<'", 
      "'&&'", "'*>'", "'=='", "'**'", "'^~'", "'!='", "'>='", "'>>'", "'=>'", 
      "'~&'", "'~^'", "'~|'", "'||'", "'|'", "'&'", "'*'", "'@'", "'^'", 
      "':'", "','", "'$'", "'\"'", "'.'", "'!'", "'='", "", "'>'", "'#'", 
      "'['", "'{'", "'('", "'<'", "'-'", "'%'", "'+'", "'+:'", "'\\u003F'", 
      "']'", "'}'", "')'", "';'", "'/'", "'~'", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "'celldefine'", "", "", "", "", "'end_keywords'", "'endcelldefine'", 
      "", "", "", "", "", "'nounconnected_drive'", "", "'resetall'", "", 
      "", "", "", "", "", "", "", "'``'", "", "'`\\`\"'", "'`\"'"
    },
    std::vector<std::string>{
      "", "ALWAYS", "AND", "ASSIGN", "AUTOMATIC", "BEGIN", "BUF", "BUFIFONE", 
      "BUFIFZERO", "CASE", "CASEX", "CASEZ", "CELL", "CMOS", "CONFIG", "DEASSIGN", 
      "DEFAULT", "DEFPARAM", "DESIGN", "DISABLE", "DLFULLSKEW", "DLHOLD", 
      "DLNOCHANGE", "DLPERIOD", "DLRECOVERY", "DLRECREM", "DLREMOVAL", "DLSETUP", 
      "DLSETUPHOLD", "DLSKEW", "DLTIMESKEW", "DLWIDTH", "EDGE", "ELSE", 
      "END", "ENDCASE", "ENDCONFIG", "ENDFUNCTION", "ENDGENERATE", "ENDMODULE", 
      "ENDPRIMITIVE", "ENDSPECIFY", "ENDTABLE", "ENDTASK", "EVENT", "FOR", 
      "FORCE", "FOREVER", "FORK", "FUNCTION", "GENERATE", "GENVAR", "HIGHZONE", 
      "HIGHZZERO", "IF", "IFNONE", "INCLUDE", "INITIAL", "INOUT", "INPUT", 
      "INSTANCE", "INTEGER", "JOIN", "LARGE", "LIBLIST", "LIBRARY", "LOCALPARAM", 
      "MACROMODULE", "MEDIUM", "MIINCDIR", "MODULE", "NAND", "NEGEDGE", 
      "NMOS", "NOR", "NOSHOWCANCELLED", "NOT", "NOTIFONE", "NOTIFZERO", 
      "OR", "OUTPUT", "PARAMETER", "PATHPULSEDL", "PMOS", "POSEDGE", "PRIMITIVE", 
      "PULLDOWN", "PULLONE", "PULLUP", "PULLZERO", "PULSESTYLE_ONDETECT", 
      "PULSESTYLE_ONEVENT", "RCMOS", "REAL", "REALTIME", "REG", "RELEASE", 
      "REPEAT", "RNMOS", "RPMOS", "RTRAN", "RTRANIFONE", "RTRANIFZERO", 
      "SCALARED", "SHOWCANCELLED", "SIGNED", "SMALL", "SPECIFY", "SPECPARAM", 
      "STRONGONE", "STRONGZERO", "SUPPLYONE", "SUPPLYZERO", "TABLE", "TASK", 
      "TIME", "TRAN", "TRANIFONE", "TRANIFZERO", "TRI", "TRIAND", "TRIONE", 
      "TRIOR", "TRIREG", "TRIZERO", "USE", "UWIRE", "VECTORED", "WAIT", 
      "WAND", "WEAKONE", "WEAKZERO", "WHILE", "WIRE", "WOR", "XNOR", "XOR", 
      "ANALOG", "ELECTRICAL", "BRANCH", "DISCIPLINE", "NATURE", "LTPL", 
      "AMAMAM", "EMEQEQ", "EQEQEQ", "GTGTGT", "LTLTLT", "MICL", "MIGT", 
      "LTEQ", "LTLT", "AMAM", "ASGT", "EQEQ", "ASAS", "CATI", "EMEQ", "GTEQ", 
      "GTGT", "EQGT", "TIAM", "TICA", "TIVL", "VLVL", "VL", "AM", "AS", 
      "AT", "CA", "CL", "CO", "DL", "DQ", "DT", "EM", "EQ", "GA", "GT", 
      "HA", "LB", "LC", "LP", "LT", "MI", "MO", "PL", "PLCL", "QM", "RB", 
      "RC", "RP", "SC", "SL", "TI", "BINARY_BASE", "BLOCK_COMMENT", "DECIMAL_BASE", 
      "ESCAPED_IDENTIFIER", "EXPONENTIAL_NUMBER", "UNIT", "FIXED_POINT_NUMBER", 
      "HEX_BASE", "LINE_COMMENT", "OCTAL_BASE", "SIMPLE_IDENTIFIER", "STRING", 
      "SYSTEM_TF_IDENTIFIER", "UNSIGNED_NUMBER", "WHITE_SPACE", "BINARY_VALUE", 
      "X_OR_Z_UNDERSCORE", "EDGE_DESCRIPTOR", "HEX_VALUE", "FILE_PATH_SPEC", 
      "OCTAL_VALUE", "EDGE_SYMBOL", "LEVEL_ONLY_SYMBOL", "OUTPUT_OR_LEVEL_SYMBOL", 
      "BEGIN_KEYWORDS_DIRECTIVE", "CELLDEFINE_DIRECTIVE", "DEFAULT_NETTYPE_DIRECTIVE", 
      "DEFINE_DIRECTIVE", "ELSE_DIRECTIVE", "ELSIF_DIRECTIVE", "END_KEYWORDS_DIRECTIVE", 
      "ENDCELLDEFINE_DIRECTIVE", "ENDIF_DIRECTIVE", "IFDEF_DIRECTIVE", "IFNDEF_DIRECTIVE", 
      "INCLUDE_DIRECTIVE", "LINE_DIRECTIVE", "NOUNCONNECTED_DRIVE_DIRECTIVE", 
      "PRAGMA_DIRECTIVE", "RESETALL_DIRECTIVE", "TIMESCALE_DIRECTIVE", "UNCONNECTED_DRIVE_DIRECTIVE", 
      "UNDEF_DIRECTIVE", "MACRO_USAGE", "VERSION_SPECIFIER", "DEFAULT_NETTYPE_VALUE", 
      "MACRO_NAME", "FILENAME", "MACRO_DELIMITER", "MACRO_ESC_NEWLINE", 
      "MACRO_ESC_QUOTE", "MACRO_QUOTE", "MACRO_TEXT", "SOURCE_TEXT", "TIME_UNIT", 
      "TIME_VALUE", "UNCONNECTED_DRIVE_VALUE", "MACRO_IDENTIFIER", "IDENTIFIER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,253,4601,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,
  	7,356,2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
  	7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,2,368,
  	7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,7,373,2,374,
  	7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,2,379,7,379,2,380,
  	7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,7,384,2,385,7,385,2,386,
  	7,386,1,0,5,0,776,8,0,10,0,12,0,779,9,0,1,0,1,0,1,1,1,1,1,1,3,1,786,8,
  	1,1,2,1,2,1,2,1,2,1,2,5,2,793,8,2,10,2,12,2,796,9,2,1,2,3,2,799,8,2,1,
  	2,1,2,1,3,1,3,1,3,1,3,5,3,807,8,3,10,3,12,3,810,9,3,1,4,1,4,1,4,1,4,1,
  	5,1,5,1,6,5,6,819,8,6,10,6,12,6,822,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,3,
  	7,831,8,7,1,8,5,8,834,8,8,10,8,12,8,837,9,8,1,8,1,8,1,8,3,8,842,8,8,1,
  	8,3,8,845,8,8,1,8,1,8,5,8,849,8,8,10,8,12,8,852,9,8,1,8,1,8,1,9,1,9,1,
  	10,1,10,1,10,1,10,1,10,5,10,863,8,10,10,10,12,10,866,9,10,1,10,1,10,1,
  	11,1,11,1,11,1,11,5,11,874,8,11,10,11,12,11,877,9,11,1,11,1,11,1,11,1,
  	11,1,11,1,11,4,11,885,8,11,11,11,12,11,886,1,11,1,11,1,11,1,11,1,11,1,
  	11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,901,8,11,1,12,3,12,904,8,12,1,12,
  	3,12,907,8,12,1,13,1,13,1,14,1,14,1,14,1,14,3,14,915,8,14,1,14,1,14,1,
  	15,1,15,1,15,1,15,1,15,5,15,924,8,15,10,15,12,15,927,9,15,1,15,1,15,3,
  	15,931,8,15,1,16,1,16,1,16,1,16,1,16,3,16,938,8,16,1,17,5,17,941,8,17,
  	10,17,12,17,944,9,17,1,17,1,17,5,17,948,8,17,10,17,12,17,951,9,17,1,17,
  	1,17,5,17,955,8,17,10,17,12,17,958,9,17,1,17,3,17,961,8,17,1,18,1,18,
  	1,18,1,18,1,18,1,18,1,18,5,18,970,8,18,10,18,12,18,973,9,18,1,18,1,18,
  	1,18,1,18,5,18,979,8,18,10,18,12,18,982,9,18,1,18,1,18,3,18,986,8,18,
  	1,19,5,19,989,8,19,10,19,12,19,992,9,19,1,19,1,19,5,19,996,8,19,10,19,
  	12,19,999,9,19,1,19,1,19,1,19,1,19,5,19,1005,8,19,10,19,12,19,1008,9,
  	19,1,19,1,19,5,19,1012,8,19,10,19,12,19,1015,9,19,1,19,1,19,5,19,1019,
  	8,19,10,19,12,19,1022,9,19,1,19,1,19,5,19,1026,8,19,10,19,12,19,1029,
  	9,19,1,19,1,19,5,19,1033,8,19,10,19,12,19,1036,9,19,1,19,1,19,5,19,1040,
  	8,19,10,19,12,19,1043,9,19,1,19,1,19,5,19,1047,8,19,10,19,12,19,1050,
  	9,19,1,19,1,19,5,19,1054,8,19,10,19,12,19,1057,9,19,1,19,1,19,5,19,1061,
  	8,19,10,19,12,19,1064,9,19,1,19,1,19,5,19,1068,8,19,10,19,12,19,1071,
  	9,19,1,19,3,19,1074,8,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,
  	1,20,3,20,1086,8,20,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,5,22,
  	1097,8,22,10,22,12,22,1100,9,22,1,22,1,22,1,23,1,23,5,23,1106,8,23,10,
  	23,12,23,1109,9,23,1,23,1,23,1,24,1,24,1,24,3,24,1116,8,24,1,24,1,24,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,3,25,1140,8,25,1,26,1,26,1,27,1,27,1,27,
  	1,28,1,28,1,28,5,28,1150,8,28,10,28,12,28,1153,9,28,1,29,1,29,1,29,1,
  	29,3,29,1159,8,29,1,29,1,29,1,30,1,30,5,30,1165,8,30,10,30,12,30,1168,
  	9,30,1,31,1,31,1,31,1,31,3,31,1174,8,31,1,31,1,31,1,31,3,31,1179,8,31,
  	1,32,1,32,3,32,1183,8,32,1,32,3,32,1186,8,32,1,32,1,32,1,32,1,32,1,32,
  	3,32,1193,8,32,1,33,1,33,3,33,1197,8,33,1,33,3,33,1200,8,33,1,33,1,33,
  	1,33,1,33,1,33,3,33,1207,8,33,1,34,1,34,3,34,1211,8,34,1,34,1,34,1,34,
  	1,35,1,35,1,36,1,36,3,36,1220,8,36,1,36,3,36,1223,8,36,1,36,3,36,1226,
  	8,36,1,36,1,36,1,37,1,37,3,37,1232,8,37,1,37,3,37,1235,8,37,1,37,3,37,
  	1238,8,37,1,37,1,37,1,38,1,38,3,38,1244,8,38,1,38,3,38,1247,8,38,1,38,
  	3,38,1250,8,38,1,38,1,38,1,38,1,38,3,38,1256,8,38,1,38,3,38,1259,8,38,
  	1,38,1,38,1,38,1,38,1,38,3,38,1266,8,38,1,39,1,39,1,39,1,39,1,40,1,40,
  	1,40,1,40,1,41,1,41,3,41,1278,8,41,1,41,3,41,1281,8,41,1,41,1,41,1,41,
  	1,41,1,41,3,41,1288,8,41,1,41,3,41,1291,8,41,1,41,3,41,1294,8,41,1,41,
  	1,41,1,41,1,41,1,41,3,41,1301,8,41,1,41,3,41,1304,8,41,1,41,1,41,3,41,
  	1308,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1315,8,41,1,41,3,41,1318,8,41,
  	1,41,3,41,1321,8,41,1,41,1,41,3,41,1325,8,41,1,41,1,41,1,41,1,41,1,41,
  	3,41,1332,8,41,1,41,3,41,1335,8,41,1,41,3,41,1338,8,41,1,41,1,41,1,41,
  	1,41,1,41,3,41,1345,8,41,1,41,3,41,1348,8,41,1,41,3,41,1351,8,41,1,41,
  	1,41,1,41,1,41,1,41,3,41,1358,8,41,1,41,3,41,1361,8,41,1,41,3,41,1364,
  	8,41,1,41,1,41,3,41,1368,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1375,8,41,
  	1,41,3,41,1378,8,41,1,41,3,41,1381,8,41,1,41,1,41,3,41,1385,8,41,1,41,
  	1,41,1,41,3,41,1390,8,41,1,42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,44,
  	1,44,3,44,1402,8,44,1,44,3,44,1405,8,44,1,44,1,44,1,44,1,45,1,45,1,45,
  	1,45,1,46,1,46,1,47,1,47,1,47,1,47,1,48,1,48,1,48,1,48,1,49,1,49,1,49,
  	1,49,1,50,1,50,1,51,1,51,5,51,1432,8,51,10,51,12,51,1435,9,51,1,51,1,
  	51,1,51,1,51,3,51,1441,8,51,1,52,1,52,5,52,1445,8,52,10,52,12,52,1448,
  	9,52,1,52,1,52,1,52,1,52,3,52,1454,8,52,1,53,1,53,1,53,1,53,1,53,1,53,
  	1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
  	1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
  	1,53,1,53,3,53,1492,8,53,1,54,1,54,1,55,1,55,1,56,1,56,1,56,1,56,1,56,
  	1,56,1,56,1,56,1,56,3,56,1507,8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
  	1,57,1,57,3,57,1518,8,57,3,57,1520,8,57,1,57,1,57,3,57,1524,8,57,1,58,
  	1,58,1,58,1,58,1,58,1,58,1,58,3,58,1533,8,58,1,58,1,58,3,58,1537,8,58,
  	1,59,1,59,1,59,3,59,1542,8,59,1,60,1,60,1,60,5,60,1547,8,60,10,60,12,
  	60,1550,9,60,1,61,1,61,1,61,5,61,1555,8,61,10,61,12,61,1558,9,61,1,62,
  	1,62,5,62,1562,8,62,10,62,12,62,1565,9,62,1,63,1,63,1,63,5,63,1570,8,
  	63,10,63,12,63,1573,9,63,1,64,1,64,1,64,5,64,1578,8,64,10,64,12,64,1581,
  	9,64,1,65,1,65,5,65,1585,8,65,10,65,12,65,1588,9,65,1,66,1,66,1,66,5,
  	66,1593,8,66,10,66,12,66,1596,9,66,1,67,1,67,1,67,5,67,1601,8,67,10,67,
  	12,67,1604,9,67,1,68,1,68,1,68,5,68,1609,8,68,10,68,12,68,1612,9,68,1,
  	69,1,69,1,69,5,69,1617,8,69,10,69,12,69,1620,9,69,1,70,1,70,1,70,5,70,
  	1625,8,70,10,70,12,70,1628,9,70,1,71,1,71,1,71,5,71,1633,8,71,10,71,12,
  	71,1636,9,71,1,72,1,72,1,72,3,72,1641,8,72,1,73,1,73,1,73,1,73,1,74,1,
  	74,1,74,1,74,1,75,1,75,1,75,1,75,1,76,1,76,1,76,1,76,1,76,3,76,1660,8,
  	76,1,77,1,77,1,77,1,77,1,77,1,77,3,77,1668,8,77,1,77,1,77,1,77,1,77,1,
  	77,1,77,1,77,1,77,1,77,1,77,1,77,3,77,1681,8,77,1,77,1,77,3,77,1685,8,
  	77,1,78,1,78,1,79,1,79,1,80,1,80,1,81,1,81,1,81,1,81,1,81,1,81,1,82,1,
  	82,1,82,1,82,1,82,1,82,1,83,1,83,3,83,1707,8,83,1,83,3,83,1710,8,83,1,
  	83,1,83,1,83,4,83,1715,8,83,11,83,12,83,1716,1,83,1,83,1,83,1,83,1,83,
  	3,83,1724,8,83,1,83,3,83,1727,8,83,1,83,1,83,1,83,1,83,1,83,1,83,5,83,
  	1735,8,83,10,83,12,83,1738,9,83,1,83,1,83,1,83,3,83,1743,8,83,1,84,1,
  	84,5,84,1747,8,84,10,84,12,84,1750,9,84,1,84,1,84,1,84,3,84,1755,8,84,
  	1,85,1,85,1,85,5,85,1760,8,85,10,85,12,85,1763,9,85,1,86,5,86,1766,8,
  	86,10,86,12,86,1769,9,86,1,86,1,86,1,87,1,87,1,87,3,87,1776,8,87,1,87,
  	1,87,1,87,1,87,3,87,1782,8,87,1,88,1,88,3,88,1786,8,88,1,88,1,88,1,88,
  	5,88,1791,8,88,10,88,12,88,1794,9,88,1,88,1,88,1,88,1,88,1,88,3,88,1801,
  	8,88,1,88,1,88,1,88,3,88,1806,8,88,1,88,1,88,1,88,5,88,1811,8,88,10,88,
  	12,88,1814,9,88,1,88,1,88,1,88,3,88,1819,8,88,1,89,1,89,5,89,1823,8,89,
  	10,89,12,89,1826,9,89,1,89,1,89,1,89,1,89,5,89,1832,8,89,10,89,12,89,
  	1835,9,89,1,89,1,89,1,89,1,89,5,89,1841,8,89,10,89,12,89,1844,9,89,1,
  	89,1,89,1,89,3,89,1849,8,89,1,90,1,90,1,90,5,90,1854,8,90,10,90,12,90,
  	1857,9,90,1,91,5,91,1860,8,91,10,91,12,91,1863,9,91,1,91,1,91,5,91,1867,
  	8,91,10,91,12,91,1870,9,91,1,91,1,91,5,91,1874,8,91,10,91,12,91,1877,
  	9,91,1,91,3,91,1880,8,91,1,92,1,92,3,92,1884,8,92,1,92,3,92,1887,8,92,
  	1,92,3,92,1890,8,92,1,92,1,92,1,92,1,92,1,92,3,92,1897,8,92,1,93,1,93,
  	3,93,1901,8,93,1,93,3,93,1904,8,93,1,93,3,93,1907,8,93,1,93,1,93,1,93,
  	1,93,1,93,3,93,1914,8,93,1,94,1,94,3,94,1918,8,94,1,94,3,94,1921,8,94,
  	1,94,3,94,1924,8,94,1,94,1,94,1,94,1,94,1,94,3,94,1931,8,94,1,95,1,95,
  	1,96,5,96,1936,8,96,10,96,12,96,1939,9,96,1,96,1,96,3,96,1943,8,96,1,
  	96,3,96,1946,8,96,1,96,1,96,1,96,1,96,5,96,1952,8,96,10,96,12,96,1955,
  	9,96,1,96,1,96,1,96,1,96,1,96,5,96,1962,8,96,10,96,12,96,1965,9,96,1,
  	96,1,96,1,96,1,96,1,96,5,96,1972,8,96,10,96,12,96,1975,9,96,1,96,1,96,
  	1,96,1,96,1,96,5,96,1982,8,96,10,96,12,96,1985,9,96,1,96,1,96,1,96,1,
  	96,1,96,5,96,1992,8,96,10,96,12,96,1995,9,96,1,96,1,96,5,96,1999,8,96,
  	10,96,12,96,2002,9,96,1,96,1,96,1,96,1,96,5,96,2008,8,96,10,96,12,96,
  	2011,9,96,1,96,1,96,1,96,3,96,2016,8,96,1,97,1,97,1,97,5,97,2021,8,97,
  	10,97,12,97,2024,9,97,1,98,1,98,1,98,5,98,2029,8,98,10,98,12,98,2032,
  	9,98,1,99,1,99,5,99,2036,8,99,10,99,12,99,2039,9,99,1,100,1,100,5,100,
  	2043,8,100,10,100,12,100,2046,9,100,1,101,1,101,3,101,2050,8,101,1,101,
  	1,101,1,101,5,101,2055,8,101,10,101,12,101,2058,9,101,1,101,1,101,1,101,
  	1,101,3,101,2064,8,101,1,101,3,101,2067,8,101,1,101,1,101,1,101,5,101,
  	2072,8,101,10,101,12,101,2075,9,101,1,101,1,101,1,101,1,101,3,101,2081,
  	8,101,1,101,1,101,1,101,5,101,2086,8,101,10,101,12,101,2089,9,101,1,101,
  	1,101,1,101,1,101,3,101,2095,8,101,1,101,3,101,2098,8,101,1,101,1,101,
  	1,101,5,101,2103,8,101,10,101,12,101,2106,9,101,1,101,1,101,1,101,1,101,
  	3,101,2112,8,101,1,101,3,101,2115,8,101,1,101,1,101,1,101,5,101,2120,
  	8,101,10,101,12,101,2123,9,101,1,101,1,101,1,101,1,101,3,101,2129,8,101,
  	1,101,1,101,1,101,5,101,2134,8,101,10,101,12,101,2137,9,101,1,101,1,101,
  	1,101,1,101,1,101,1,101,5,101,2145,8,101,10,101,12,101,2148,9,101,1,101,
  	1,101,1,101,1,101,3,101,2154,8,101,1,101,1,101,1,101,5,101,2159,8,101,
  	10,101,12,101,2162,9,101,1,101,1,101,1,101,1,101,3,101,2168,8,101,1,101,
  	1,101,1,101,5,101,2173,8,101,10,101,12,101,2176,9,101,1,101,1,101,3,101,
  	2180,8,101,1,102,3,102,2183,8,102,1,102,1,102,1,102,1,102,1,102,1,102,
  	1,102,1,102,1,102,1,102,1,103,3,103,2196,8,103,1,103,1,103,1,103,1,103,
  	1,103,1,103,1,103,1,103,1,104,3,104,2207,8,104,1,104,1,104,1,104,1,104,
  	1,104,1,104,1,104,1,104,1,105,3,105,2218,8,105,1,105,1,105,1,105,1,105,
  	1,105,1,105,5,105,2226,8,105,10,105,12,105,2229,9,105,1,105,1,105,1,106,
  	3,106,2234,8,106,1,106,1,106,1,106,1,106,5,106,2240,8,106,10,106,12,106,
  	2243,9,106,1,106,1,106,1,106,1,106,1,107,3,107,2250,8,107,1,107,1,107,
  	1,107,1,107,1,107,1,107,1,108,3,108,2259,8,108,1,108,1,108,1,108,1,108,
  	1,108,1,108,1,108,1,108,1,109,3,109,2270,8,109,1,109,1,109,1,109,1,109,
  	1,110,1,110,3,110,2278,8,110,1,111,1,111,1,111,1,111,1,111,1,111,1,111,
  	1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,3,111,2296,8,111,
  	1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,
  	1,112,1,112,1,112,1,112,3,112,2314,8,112,1,113,1,113,1,114,1,114,1,115,
  	1,115,1,116,1,116,1,117,1,117,1,118,1,118,1,119,1,119,1,120,1,120,1,121,
  	1,121,1,122,1,122,1,123,1,123,1,124,1,124,1,125,1,125,1,126,1,126,3,126,
  	2344,8,126,1,126,1,126,1,126,5,126,2349,8,126,10,126,12,126,2352,9,126,
  	1,126,1,126,1,127,1,127,1,127,1,127,1,127,1,128,1,128,1,128,5,128,2364,
  	8,128,10,128,12,128,2367,9,128,1,128,1,128,1,128,5,128,2372,8,128,10,
  	128,12,128,2375,9,128,3,128,2377,8,128,1,129,1,129,1,130,1,130,1,130,
  	1,130,3,130,2385,8,130,1,130,1,130,1,131,1,131,1,131,1,131,1,131,1,132,
  	1,132,3,132,2396,8,132,1,133,1,133,1,133,5,133,2401,8,133,10,133,12,133,
  	2404,9,133,1,133,1,133,1,133,5,133,2409,8,133,10,133,12,133,2412,9,133,
  	3,133,2414,8,133,1,134,5,134,2417,8,134,10,134,12,134,2420,9,134,1,134,
  	3,134,2423,8,134,1,135,5,135,2426,8,135,10,135,12,135,2429,9,135,1,135,
  	1,135,1,135,1,135,3,135,2435,8,135,1,135,1,135,1,136,1,136,5,136,2441,
  	8,136,10,136,12,136,2444,9,136,1,136,1,136,1,137,1,137,1,137,1,137,1,
  	138,1,138,1,138,5,138,2455,8,138,10,138,12,138,2458,9,138,1,139,1,139,
  	1,139,1,139,1,139,1,139,1,139,1,139,1,139,1,139,1,140,1,140,1,140,1,140,
  	1,141,1,141,1,142,1,142,1,142,1,142,1,143,1,143,3,143,2482,8,143,1,144,
  	1,144,1,144,1,144,1,144,1,144,1,144,3,144,2491,8,144,1,145,1,145,1,145,
  	1,145,1,145,4,145,2498,8,145,11,145,12,145,2499,1,145,1,145,1,146,1,146,
  	1,146,5,146,2507,8,146,10,146,12,146,2510,9,146,1,146,1,146,1,146,1,146,
  	1,146,3,146,2517,8,146,1,146,3,146,2520,8,146,1,147,1,147,1,147,3,147,
  	2525,8,147,1,147,5,147,2528,8,147,10,147,12,147,2531,9,147,1,147,3,147,
  	2534,8,147,1,148,1,148,1,148,1,149,1,149,3,149,2541,8,149,1,150,5,150,
  	2544,8,150,10,150,12,150,2547,9,150,1,150,1,150,1,150,1,150,1,150,1,150,
  	1,150,4,150,2556,8,150,11,150,12,150,2557,1,150,1,150,1,150,1,150,5,150,
  	2564,8,150,10,150,12,150,2567,9,150,1,150,1,150,1,150,1,150,1,150,1,150,
  	1,150,1,150,1,150,3,150,2578,8,150,1,151,1,151,1,151,1,151,1,151,5,151,
  	2585,8,151,10,151,12,151,2588,9,151,1,152,1,152,1,152,1,152,1,152,5,152,
  	2595,8,152,10,152,12,152,2598,9,152,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,3,153,2609,8,153,1,154,5,154,2612,8,154,10,154,12,154,
  	2615,9,154,1,154,1,154,1,154,5,154,2620,8,154,10,154,12,154,2623,9,154,
  	1,154,1,154,1,154,1,154,1,154,3,154,2630,8,154,3,154,2632,8,154,1,155,
  	5,155,2635,8,155,10,155,12,155,2638,9,155,1,155,1,155,1,155,1,156,5,156,
  	2644,8,156,10,156,12,156,2647,9,156,1,156,1,156,1,156,1,157,1,157,3,157,
  	2654,8,157,1,158,1,158,4,158,2658,8,158,11,158,12,158,2659,1,158,1,158,
  	1,159,1,159,1,159,1,159,1,159,1,160,3,160,2670,8,160,1,160,1,160,4,160,
  	2674,8,160,11,160,12,160,2675,1,160,1,160,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,162,1,162,3,162,2688,8,162,1,163,1,163,1,163,1,163,1,163,1,163,
  	1,163,1,164,1,164,3,164,2699,8,164,1,165,4,165,2702,8,165,11,165,12,165,
  	2703,1,166,5,166,2707,8,166,10,166,12,166,2710,9,166,1,166,1,166,5,166,
  	2714,8,166,10,166,12,166,2717,9,166,1,167,1,167,1,167,1,167,1,167,1,167,
  	3,167,2725,8,167,1,168,1,168,1,169,1,169,3,169,2731,8,169,1,170,1,170,
  	1,171,1,171,1,172,1,172,1,173,1,173,3,173,2741,8,173,1,173,3,173,2744,
  	8,173,1,173,1,173,1,173,5,173,2749,8,173,10,173,12,173,2752,9,173,1,173,
  	1,173,1,174,3,174,2757,8,174,1,174,1,174,1,174,1,174,1,174,1,174,5,174,
  	2765,8,174,10,174,12,174,2768,9,174,1,174,1,174,1,175,1,175,3,175,2774,
  	8,175,1,176,1,176,3,176,2778,8,176,1,176,3,176,2781,8,176,1,176,1,176,
  	1,176,1,177,1,177,1,177,5,177,2789,8,177,10,177,12,177,2792,9,177,1,178,
  	1,178,1,178,1,178,1,179,1,179,1,179,1,180,1,180,1,180,1,181,1,181,1,181,
  	1,182,1,182,1,182,3,182,2810,8,182,1,182,1,182,1,183,1,183,1,183,3,183,
  	2817,8,183,1,183,1,183,1,184,1,184,1,184,3,184,2824,8,184,1,184,1,184,
  	1,185,1,185,1,185,1,185,1,185,1,185,1,185,1,185,3,185,2836,8,185,1,186,
  	1,186,1,186,1,186,1,187,1,187,1,187,5,187,2845,8,187,10,187,12,187,2848,
  	9,187,3,187,2850,8,187,1,187,5,187,2853,8,187,10,187,12,187,2856,9,187,
  	1,187,1,187,1,188,1,188,1,188,1,189,1,189,1,189,5,189,2866,8,189,10,189,
  	12,189,2869,9,189,3,189,2871,8,189,1,189,5,189,2874,8,189,10,189,12,189,
  	2877,9,189,1,189,1,189,1,190,5,190,2882,8,190,10,190,12,190,2885,9,190,
  	1,190,1,190,1,190,1,190,5,190,2891,8,190,10,190,12,190,2894,9,190,1,190,
  	1,190,5,190,2898,8,190,10,190,12,190,2901,9,190,1,190,1,190,5,190,2905,
  	8,190,10,190,12,190,2908,9,190,1,190,1,190,5,190,2912,8,190,10,190,12,
  	190,2915,9,190,1,190,1,190,5,190,2919,8,190,10,190,12,190,2922,9,190,
  	1,190,1,190,5,190,2926,8,190,10,190,12,190,2929,9,190,1,190,1,190,1,190,
  	1,190,5,190,2935,8,190,10,190,12,190,2938,9,190,1,190,1,190,1,190,1,190,
  	5,190,2944,8,190,10,190,12,190,2947,9,190,1,190,1,190,5,190,2951,8,190,
  	10,190,12,190,2954,9,190,1,190,1,190,1,190,1,190,5,190,2960,8,190,10,
  	190,12,190,2963,9,190,1,190,1,190,5,190,2967,8,190,10,190,12,190,2970,
  	9,190,1,190,1,190,5,190,2974,8,190,10,190,12,190,2977,9,190,1,190,1,190,
  	5,190,2981,8,190,10,190,12,190,2984,9,190,1,190,1,190,5,190,2988,8,190,
  	10,190,12,190,2991,9,190,1,190,3,190,2994,8,190,1,191,1,191,5,191,2998,
  	8,191,10,191,12,191,3001,9,191,1,191,3,191,3004,8,191,1,192,1,192,1,193,
  	1,193,1,193,1,193,1,193,1,193,1,193,3,193,3015,8,193,1,194,1,194,1,194,
  	1,194,1,194,1,194,1,194,1,194,3,194,3025,8,194,1,195,1,195,1,195,1,195,
  	1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,
  	1,196,3,196,3044,8,196,1,197,1,197,1,197,3,197,3049,8,197,1,197,1,197,
  	1,198,1,198,1,198,1,198,1,198,1,198,3,198,3059,8,198,1,198,1,198,1,198,
  	1,198,1,198,1,198,5,198,3067,8,198,10,198,12,198,3070,9,198,1,199,1,199,
  	3,199,3074,8,199,1,200,1,200,1,200,1,201,1,201,1,201,1,201,1,201,1,201,
  	1,202,1,202,1,202,1,202,1,202,1,202,1,202,3,202,3092,8,202,1,203,1,203,
  	1,203,1,203,1,203,4,203,3099,8,203,11,203,12,203,3100,1,203,1,203,1,203,
  	1,203,1,203,1,203,1,203,4,203,3110,8,203,11,203,12,203,3111,1,203,1,203,
  	1,203,1,203,1,203,1,203,1,203,4,203,3121,8,203,11,203,12,203,3122,1,203,
  	1,203,3,203,3127,8,203,1,204,1,204,1,204,5,204,3132,8,204,10,204,12,204,
  	3135,9,204,1,204,1,204,1,204,1,204,1,204,3,204,3142,8,204,1,204,3,204,
  	3145,8,204,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,
  	1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,
  	1,205,1,205,3,205,3171,8,205,1,206,1,206,3,206,3175,8,206,1,206,1,206,
  	1,207,1,207,1,207,1,207,5,207,3183,8,207,10,207,12,207,3186,9,207,1,207,
  	1,207,1,208,3,208,3191,8,208,1,209,1,209,3,209,3195,8,209,1,209,1,209,
  	1,210,1,210,1,210,1,210,5,210,3203,8,210,10,210,12,210,3206,9,210,1,210,
  	1,210,1,211,1,211,5,211,3212,8,211,10,211,12,211,3215,9,211,1,211,1,211,
  	1,212,1,212,1,212,1,212,1,212,3,212,3224,8,212,1,213,1,213,1,213,1,213,
  	1,213,1,213,1,213,1,213,3,213,3234,8,213,1,214,1,214,1,214,1,214,1,214,
  	1,214,1,214,1,214,3,214,3244,8,214,1,215,1,215,1,215,1,215,1,215,1,215,
  	1,215,1,215,1,215,3,215,3255,8,215,1,216,1,216,1,216,1,216,1,216,1,216,
  	1,216,1,216,3,216,3265,8,216,1,217,1,217,1,217,3,217,3270,8,217,1,217,
  	1,217,1,217,1,217,1,218,1,218,1,218,3,218,3279,8,218,1,218,1,218,1,218,
  	1,218,1,219,1,219,1,219,5,219,3288,8,219,10,219,12,219,3291,9,219,1,220,
  	1,220,1,220,5,220,3296,8,220,10,220,12,220,3299,9,220,1,221,1,221,1,221,
  	1,221,1,221,3,221,3306,8,221,1,222,1,222,1,222,1,222,1,222,3,222,3313,
  	8,222,1,223,1,223,1,224,1,224,1,225,1,225,1,225,1,225,1,225,3,225,3324,
  	8,225,1,226,1,226,1,226,1,226,1,226,1,226,3,226,3332,8,226,1,226,1,226,
  	1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,
  	1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,3,226,3358,
  	8,226,3,226,3360,8,226,1,227,1,227,1,228,1,228,1,229,1,229,1,230,1,230,
  	1,231,1,231,1,232,1,232,1,233,1,233,1,234,1,234,1,235,1,235,1,236,1,236,
  	1,237,1,237,1,238,1,238,1,239,1,239,1,240,1,240,1,241,1,241,1,242,1,242,
  	1,243,1,243,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,3,244,3404,
  	8,244,1,245,1,245,3,245,3408,8,245,1,245,1,245,1,245,1,245,1,245,3,245,
  	3415,8,245,1,245,1,245,1,245,1,245,1,245,1,246,1,246,3,246,3424,8,246,
  	1,246,1,246,1,246,1,246,1,246,3,246,3431,8,246,1,246,1,246,1,246,1,246,
  	1,246,1,247,1,247,1,248,1,248,1,249,1,249,1,249,1,249,1,249,1,249,1,249,
  	1,249,1,249,1,249,1,249,1,249,1,249,1,249,3,249,3456,8,249,1,250,1,250,
  	1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,
  	3,251,3472,8,251,1,252,1,252,1,252,1,252,1,252,1,252,1,252,1,252,3,252,
  	3482,8,252,1,252,1,252,1,252,1,253,1,253,3,253,3489,8,253,1,254,1,254,
  	1,254,1,254,1,254,1,254,1,254,1,254,3,254,3499,8,254,1,254,1,254,1,254,
  	1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,3,255,3514,
  	8,255,1,255,1,255,1,255,1,256,1,256,3,256,3521,8,256,1,256,3,256,3524,
  	8,256,1,257,1,257,3,257,3528,8,257,1,257,3,257,3531,8,257,1,258,1,258,
  	3,258,3535,8,258,1,258,3,258,3538,8,258,1,259,1,259,3,259,3542,8,259,
  	1,259,3,259,3545,8,259,1,260,1,260,3,260,3549,8,260,1,261,1,261,1,261,
  	1,261,1,261,1,261,1,261,1,261,3,261,3559,8,261,1,261,1,261,1,261,1,262,
  	1,262,1,262,1,262,1,262,1,262,1,262,1,262,3,262,3572,8,262,1,262,1,262,
  	1,262,1,263,1,263,1,263,1,263,1,263,1,263,1,263,1,263,1,263,1,263,3,263,
  	3587,8,263,1,263,1,263,1,263,1,264,1,264,1,264,1,264,1,264,1,264,1,264,
  	1,264,3,264,3600,8,264,1,264,1,264,1,264,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,3,265,3613,8,265,1,265,1,265,1,265,1,266,1,266,3,266,
  	3620,8,266,1,266,3,266,3623,8,266,1,267,1,267,3,267,3627,8,267,1,267,
  	3,267,3630,8,267,1,268,1,268,3,268,3634,8,268,1,269,1,269,1,269,1,269,
  	1,269,1,269,1,269,1,269,1,269,1,269,3,269,3646,8,269,1,269,1,269,1,269,
  	1,270,1,270,1,270,1,270,1,270,1,270,3,270,3657,8,270,1,270,1,270,1,270,
  	1,271,1,271,1,271,1,271,1,271,1,271,3,271,3668,8,271,1,271,1,271,1,271,
  	1,272,1,272,1,272,1,272,3,272,3677,8,272,1,273,1,273,1,273,1,273,1,273,
  	1,273,1,273,1,273,1,273,1,273,3,273,3689,8,273,1,273,1,273,1,273,1,274,
  	1,274,1,275,1,275,1,276,1,276,1,277,1,277,1,277,1,277,1,277,3,277,3705,
  	8,277,1,278,1,278,1,278,1,278,1,278,3,278,3712,8,278,1,279,1,279,1,280,
  	1,280,1,281,1,281,1,282,1,282,1,283,1,283,1,284,1,284,1,285,1,285,1,286,
  	1,286,1,287,1,287,1,288,3,288,3733,8,288,1,288,1,288,1,288,3,288,3738,
  	8,288,1,289,1,289,1,289,1,289,3,289,3744,8,289,1,290,1,290,1,290,3,290,
  	3749,8,290,1,291,1,291,3,291,3753,8,291,1,292,1,292,1,292,1,292,1,292,
  	5,292,3760,8,292,10,292,12,292,3763,9,292,1,292,1,292,1,293,1,293,1,294,
  	1,294,1,294,1,294,1,294,3,294,3774,8,294,1,295,1,295,1,295,1,295,1,295,
  	1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,
  	1,295,1,295,3,295,3795,8,295,1,296,1,296,3,296,3799,8,296,1,297,1,297,
  	1,297,1,297,5,297,3805,8,297,10,297,12,297,3808,9,297,1,297,1,297,1,298,
  	1,298,1,298,1,298,5,298,3816,8,298,10,298,12,298,3819,9,298,1,298,1,298,
  	1,299,1,299,1,299,1,299,1,299,1,300,1,300,1,300,1,300,5,300,3832,8,300,
  	10,300,12,300,3835,9,300,1,300,1,300,1,301,1,301,1,301,1,301,1,301,1,
  	302,1,302,1,302,1,302,1,302,1,303,1,303,5,303,3851,8,303,10,303,12,303,
  	3854,9,303,1,303,1,303,1,303,1,303,5,303,3860,8,303,10,303,12,303,3863,
  	9,303,1,303,1,303,1,304,1,304,1,304,1,304,1,304,5,304,3872,8,304,10,304,
  	12,304,3875,9,304,1,304,1,304,1,305,1,305,5,305,3881,8,305,10,305,12,
  	305,3884,9,305,1,305,1,305,1,305,1,305,5,305,3890,8,305,10,305,12,305,
  	3893,9,305,1,305,1,305,1,306,1,306,3,306,3899,8,306,1,307,1,307,1,307,
  	1,307,5,307,3905,8,307,10,307,12,307,3908,9,307,1,307,1,307,1,308,1,308,
  	1,309,1,309,1,310,1,310,1,310,1,310,5,310,3920,8,310,10,310,12,310,3923,
  	9,310,1,310,1,310,3,310,3927,8,310,1,310,1,310,1,310,5,310,3932,8,310,
  	10,310,12,310,3935,9,310,1,310,1,310,1,310,1,310,5,310,3941,8,310,10,
  	310,12,310,3944,9,310,1,310,1,310,1,310,1,310,5,310,3950,8,310,10,310,
  	12,310,3953,9,310,1,310,1,310,1,310,1,310,5,310,3959,8,310,10,310,12,
  	310,3962,9,310,1,310,1,310,1,310,1,310,5,310,3968,8,310,10,310,12,310,
  	3971,9,310,1,310,1,310,1,310,1,310,5,310,3977,8,310,10,310,12,310,3980,
  	9,310,1,310,1,310,1,310,1,310,5,310,3986,8,310,10,310,12,310,3989,9,310,
  	1,310,1,310,1,310,1,310,5,310,3995,8,310,10,310,12,310,3998,9,310,1,310,
  	1,310,1,310,1,310,5,310,4004,8,310,10,310,12,310,4007,9,310,1,310,1,310,
  	1,310,1,310,5,310,4013,8,310,10,310,12,310,4016,9,310,1,310,1,310,1,310,
  	1,310,5,310,4022,8,310,10,310,12,310,4025,9,310,1,310,1,310,1,310,1,310,
  	5,310,4031,8,310,10,310,12,310,4034,9,310,1,310,1,310,1,310,1,310,5,310,
  	4040,8,310,10,310,12,310,4043,9,310,1,311,1,311,1,311,1,311,1,311,1,311,
  	3,311,4051,8,311,1,312,1,312,1,312,1,312,1,312,1,312,1,312,1,312,1,312,
  	1,312,1,312,1,312,1,312,3,312,4066,8,312,1,313,1,313,1,314,1,314,1,314,
  	1,314,5,314,4074,8,314,10,314,12,314,4077,9,314,1,314,1,314,3,314,4081,
  	8,314,1,314,1,314,1,314,5,314,4086,8,314,10,314,12,314,4089,9,314,1,314,
  	1,314,1,314,1,314,5,314,4095,8,314,10,314,12,314,4098,9,314,1,314,1,314,
  	1,314,1,314,5,314,4104,8,314,10,314,12,314,4107,9,314,1,314,1,314,1,314,
  	1,314,5,314,4113,8,314,10,314,12,314,4116,9,314,1,314,1,314,1,314,1,314,
  	5,314,4122,8,314,10,314,12,314,4125,9,314,1,314,1,314,1,314,1,314,5,314,
  	4131,8,314,10,314,12,314,4134,9,314,1,314,1,314,1,314,1,314,5,314,4140,
  	8,314,10,314,12,314,4143,9,314,1,314,1,314,1,314,1,314,5,314,4149,8,314,
  	10,314,12,314,4152,9,314,1,314,1,314,1,314,1,314,5,314,4158,8,314,10,
  	314,12,314,4161,9,314,1,314,1,314,1,314,1,314,5,314,4167,8,314,10,314,
  	12,314,4170,9,314,1,314,1,314,1,314,1,314,5,314,4176,8,314,10,314,12,
  	314,4179,9,314,1,314,1,314,1,314,1,314,5,314,4185,8,314,10,314,12,314,
  	4188,9,314,1,314,1,314,1,314,1,314,5,314,4194,8,314,10,314,12,314,4197,
  	9,314,1,315,1,315,1,316,1,316,1,316,1,316,1,316,1,316,3,316,4207,8,316,
  	1,317,1,317,1,317,1,317,5,317,4213,8,317,10,317,12,317,4216,9,317,1,317,
  	1,317,3,317,4220,8,317,1,317,1,317,1,317,5,317,4225,8,317,10,317,12,317,
  	4228,9,317,1,317,1,317,1,317,1,317,5,317,4234,8,317,10,317,12,317,4237,
  	9,317,1,317,1,317,1,317,1,317,5,317,4243,8,317,10,317,12,317,4246,9,317,
  	1,317,1,317,1,317,1,317,5,317,4252,8,317,10,317,12,317,4255,9,317,1,317,
  	1,317,1,317,1,317,5,317,4261,8,317,10,317,12,317,4264,9,317,1,317,1,317,
  	1,317,1,317,5,317,4270,8,317,10,317,12,317,4273,9,317,1,317,1,317,1,317,
  	1,317,5,317,4279,8,317,10,317,12,317,4282,9,317,1,317,1,317,1,317,1,317,
  	5,317,4288,8,317,10,317,12,317,4291,9,317,1,318,1,318,1,318,1,318,1,318,
  	1,318,3,318,4299,8,318,1,319,1,319,1,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,1,320,3,320,4316,8,320,1,321,1,321,
  	1,322,1,322,1,322,1,322,1,322,1,322,3,322,4326,8,322,1,322,1,322,1,322,
  	1,322,1,322,1,322,1,322,1,322,1,322,3,322,4337,8,322,1,323,1,323,1,323,
  	1,323,1,323,1,323,1,323,1,323,1,323,1,323,3,323,4349,8,323,1,324,1,324,
  	1,324,3,324,4354,8,324,1,324,1,324,1,324,1,324,1,324,1,324,1,324,1,324,
  	1,324,3,324,4365,8,324,1,325,3,325,4368,8,325,1,325,1,325,1,325,1,325,
  	1,326,1,326,1,326,1,326,4,326,4378,8,326,11,326,12,326,4379,1,327,1,327,
  	3,327,4384,8,327,1,327,1,327,1,327,1,327,5,327,4390,8,327,10,327,12,327,
  	4393,9,327,1,327,1,327,3,327,4397,8,327,1,328,3,328,4400,8,328,1,328,
  	1,328,1,328,1,328,1,329,1,329,1,329,1,329,4,329,4410,8,329,11,329,12,
  	329,4411,1,330,1,330,3,330,4416,8,330,1,330,1,330,1,330,1,330,5,330,4422,
  	8,330,10,330,12,330,4425,9,330,1,330,1,330,3,330,4429,8,330,1,331,1,331,
  	1,332,1,332,1,333,1,333,1,333,1,333,1,333,3,333,4440,8,333,1,334,1,334,
  	3,334,4444,8,334,1,334,1,334,3,334,4448,8,334,3,334,4450,8,334,1,335,
  	1,335,3,335,4454,8,335,1,335,1,335,1,335,3,335,4459,8,335,1,336,3,336,
  	4462,8,336,1,336,1,336,1,336,1,337,3,337,4468,8,337,1,337,1,337,1,337,
  	1,338,3,338,4474,8,338,1,338,1,338,1,338,1,339,1,339,1,340,1,340,1,341,
  	1,341,1,342,1,342,1,343,1,343,1,344,1,344,1,345,1,345,1,346,1,346,1,347,
  	1,347,1,348,1,348,1,349,1,349,1,350,1,350,1,351,1,351,1,352,1,352,1,352,
  	1,352,1,352,5,352,4510,8,352,10,352,12,352,4513,9,352,1,352,1,352,1,352,
  	1,353,1,353,1,353,3,353,4521,8,353,1,354,1,354,1,355,1,355,1,356,1,356,
  	1,357,1,357,1,358,1,358,1,359,1,359,1,360,1,360,1,361,1,361,1,362,1,362,
  	1,363,1,363,1,364,5,364,4544,8,364,10,364,12,364,4547,9,364,1,364,1,364,
  	1,365,1,365,3,365,4553,8,365,1,365,1,365,1,366,1,366,3,366,4559,8,366,
  	1,367,1,367,1,368,1,368,1,369,1,369,1,370,1,370,1,371,1,371,1,372,1,372,
  	1,373,1,373,1,374,1,374,1,375,1,375,1,376,1,376,1,377,1,377,1,378,1,378,
  	1,379,1,379,1,380,1,380,1,381,1,381,1,382,1,382,1,383,1,383,1,384,1,384,
  	1,385,1,385,1,386,1,386,1,386,0,4,396,620,628,634,387,0,2,4,6,8,10,12,
  	14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
  	60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,
  	178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,
  	214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,
  	250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,
  	286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,
  	322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,
  	358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,
  	394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,
  	430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,
  	466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,
  	502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,
  	538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,
  	574,576,578,580,582,584,586,588,590,592,594,596,598,600,602,604,606,608,
  	610,612,614,616,618,620,622,624,626,628,630,632,634,636,638,640,642,644,
  	646,648,650,652,654,656,658,660,662,664,666,668,670,672,674,676,678,680,
  	682,684,686,688,690,692,694,696,698,700,702,704,706,708,710,712,714,716,
  	718,720,722,724,726,728,730,732,734,736,738,740,742,744,746,748,750,752,
  	754,756,758,760,762,764,766,768,770,772,0,26,2,0,67,67,70,70,3,0,61,61,
  	93,94,115,115,2,0,103,103,127,127,6,0,111,112,119,122,124,124,126,126,
  	129,129,133,134,2,0,61,61,115,115,4,0,89,89,110,110,112,112,131,131,4,
  	0,87,87,109,109,111,111,130,130,2,0,13,13,92,92,2,0,7,8,77,78,3,0,73,
  	73,83,83,98,99,5,0,2,2,71,71,74,74,79,79,135,136,2,0,6,6,76,76,2,0,101,
  	102,117,118,2,0,100,100,116,116,1,0,217,218,2,0,72,72,84,84,2,0,184,184,
  	186,186,3,0,167,167,185,185,193,193,3,0,146,147,151,151,159,159,4,0,150,
  	150,158,158,178,178,183,183,3,0,144,145,154,154,157,157,3,0,156,156,162,
  	162,169,169,2,0,154,154,157,157,8,0,156,156,161,163,165,166,169,169,175,
  	175,184,184,186,186,194,194,6,0,156,156,161,163,165,166,169,169,175,175,
  	194,194,2,0,208,208,211,211,4850,0,777,1,0,0,0,2,785,1,0,0,0,4,787,1,
  	0,0,0,6,802,1,0,0,0,8,811,1,0,0,0,10,815,1,0,0,0,12,820,1,0,0,0,14,830,
  	1,0,0,0,16,835,1,0,0,0,18,855,1,0,0,0,20,857,1,0,0,0,22,900,1,0,0,0,24,
  	906,1,0,0,0,26,908,1,0,0,0,28,910,1,0,0,0,30,930,1,0,0,0,32,932,1,0,0,
  	0,34,960,1,0,0,0,36,985,1,0,0,0,38,1073,1,0,0,0,40,1085,1,0,0,0,42,1087,
  	1,0,0,0,44,1091,1,0,0,0,46,1103,1,0,0,0,48,1115,1,0,0,0,50,1139,1,0,0,
  	0,52,1141,1,0,0,0,54,1143,1,0,0,0,56,1146,1,0,0,0,58,1154,1,0,0,0,60,
  	1162,1,0,0,0,62,1169,1,0,0,0,64,1192,1,0,0,0,66,1206,1,0,0,0,68,1208,
  	1,0,0,0,70,1215,1,0,0,0,72,1217,1,0,0,0,74,1229,1,0,0,0,76,1265,1,0,0,
  	0,78,1267,1,0,0,0,80,1271,1,0,0,0,82,1389,1,0,0,0,84,1391,1,0,0,0,86,
  	1395,1,0,0,0,88,1399,1,0,0,0,90,1409,1,0,0,0,92,1413,1,0,0,0,94,1415,
  	1,0,0,0,96,1419,1,0,0,0,98,1423,1,0,0,0,100,1427,1,0,0,0,102,1440,1,0,
  	0,0,104,1453,1,0,0,0,106,1491,1,0,0,0,108,1493,1,0,0,0,110,1495,1,0,0,
  	0,112,1506,1,0,0,0,114,1523,1,0,0,0,116,1536,1,0,0,0,118,1541,1,0,0,0,
  	120,1543,1,0,0,0,122,1551,1,0,0,0,124,1559,1,0,0,0,126,1566,1,0,0,0,128,
  	1574,1,0,0,0,130,1582,1,0,0,0,132,1589,1,0,0,0,134,1597,1,0,0,0,136,1605,
  	1,0,0,0,138,1613,1,0,0,0,140,1621,1,0,0,0,142,1629,1,0,0,0,144,1637,1,
  	0,0,0,146,1642,1,0,0,0,148,1646,1,0,0,0,150,1650,1,0,0,0,152,1659,1,0,
  	0,0,154,1684,1,0,0,0,156,1686,1,0,0,0,158,1688,1,0,0,0,160,1690,1,0,0,
  	0,162,1692,1,0,0,0,164,1698,1,0,0,0,166,1742,1,0,0,0,168,1754,1,0,0,0,
  	170,1756,1,0,0,0,172,1767,1,0,0,0,174,1781,1,0,0,0,176,1818,1,0,0,0,178,
  	1848,1,0,0,0,180,1850,1,0,0,0,182,1879,1,0,0,0,184,1896,1,0,0,0,186,1913,
  	1,0,0,0,188,1930,1,0,0,0,190,1932,1,0,0,0,192,2015,1,0,0,0,194,2017,1,
  	0,0,0,196,2025,1,0,0,0,198,2033,1,0,0,0,200,2040,1,0,0,0,202,2179,1,0,
  	0,0,204,2182,1,0,0,0,206,2195,1,0,0,0,208,2206,1,0,0,0,210,2217,1,0,0,
  	0,212,2233,1,0,0,0,214,2249,1,0,0,0,216,2258,1,0,0,0,218,2269,1,0,0,0,
  	220,2275,1,0,0,0,222,2295,1,0,0,0,224,2313,1,0,0,0,226,2315,1,0,0,0,228,
  	2317,1,0,0,0,230,2319,1,0,0,0,232,2321,1,0,0,0,234,2323,1,0,0,0,236,2325,
  	1,0,0,0,238,2327,1,0,0,0,240,2329,1,0,0,0,242,2331,1,0,0,0,244,2333,1,
  	0,0,0,246,2335,1,0,0,0,248,2337,1,0,0,0,250,2339,1,0,0,0,252,2341,1,0,
  	0,0,254,2355,1,0,0,0,256,2376,1,0,0,0,258,2378,1,0,0,0,260,2380,1,0,0,
  	0,262,2388,1,0,0,0,264,2393,1,0,0,0,266,2413,1,0,0,0,268,2418,1,0,0,0,
  	270,2427,1,0,0,0,272,2438,1,0,0,0,274,2447,1,0,0,0,276,2451,1,0,0,0,278,
  	2459,1,0,0,0,280,2469,1,0,0,0,282,2473,1,0,0,0,284,2475,1,0,0,0,286,2481,
  	1,0,0,0,288,2483,1,0,0,0,290,2492,1,0,0,0,292,2519,1,0,0,0,294,2533,1,
  	0,0,0,296,2535,1,0,0,0,298,2540,1,0,0,0,300,2577,1,0,0,0,302,2579,1,0,
  	0,0,304,2589,1,0,0,0,306,2608,1,0,0,0,308,2631,1,0,0,0,310,2636,1,0,0,
  	0,312,2645,1,0,0,0,314,2653,1,0,0,0,316,2655,1,0,0,0,318,2663,1,0,0,0,
  	320,2669,1,0,0,0,322,2679,1,0,0,0,324,2687,1,0,0,0,326,2689,1,0,0,0,328,
  	2698,1,0,0,0,330,2701,1,0,0,0,332,2708,1,0,0,0,334,2724,1,0,0,0,336,2726,
  	1,0,0,0,338,2730,1,0,0,0,340,2732,1,0,0,0,342,2734,1,0,0,0,344,2736,1,
  	0,0,0,346,2738,1,0,0,0,348,2756,1,0,0,0,350,2771,1,0,0,0,352,2775,1,0,
  	0,0,354,2785,1,0,0,0,356,2793,1,0,0,0,358,2797,1,0,0,0,360,2800,1,0,0,
  	0,362,2803,1,0,0,0,364,2806,1,0,0,0,366,2813,1,0,0,0,368,2820,1,0,0,0,
  	370,2835,1,0,0,0,372,2837,1,0,0,0,374,2841,1,0,0,0,376,2859,1,0,0,0,378,
  	2862,1,0,0,0,380,2993,1,0,0,0,382,3003,1,0,0,0,384,3005,1,0,0,0,386,3014,
  	1,0,0,0,388,3024,1,0,0,0,390,3026,1,0,0,0,392,3043,1,0,0,0,394,3045,1,
  	0,0,0,396,3058,1,0,0,0,398,3073,1,0,0,0,400,3075,1,0,0,0,402,3078,1,0,
  	0,0,404,3084,1,0,0,0,406,3126,1,0,0,0,408,3144,1,0,0,0,410,3170,1,0,0,
  	0,412,3172,1,0,0,0,414,3178,1,0,0,0,416,3190,1,0,0,0,418,3192,1,0,0,0,
  	420,3198,1,0,0,0,422,3209,1,0,0,0,424,3223,1,0,0,0,426,3233,1,0,0,0,428,
  	3243,1,0,0,0,430,3254,1,0,0,0,432,3264,1,0,0,0,434,3266,1,0,0,0,436,3275,
  	1,0,0,0,438,3284,1,0,0,0,440,3292,1,0,0,0,442,3300,1,0,0,0,444,3307,1,
  	0,0,0,446,3314,1,0,0,0,448,3316,1,0,0,0,450,3323,1,0,0,0,452,3359,1,0,
  	0,0,454,3361,1,0,0,0,456,3363,1,0,0,0,458,3365,1,0,0,0,460,3367,1,0,0,
  	0,462,3369,1,0,0,0,464,3371,1,0,0,0,466,3373,1,0,0,0,468,3375,1,0,0,0,
  	470,3377,1,0,0,0,472,3379,1,0,0,0,474,3381,1,0,0,0,476,3383,1,0,0,0,478,
  	3385,1,0,0,0,480,3387,1,0,0,0,482,3389,1,0,0,0,484,3391,1,0,0,0,486,3393,
  	1,0,0,0,488,3403,1,0,0,0,490,3405,1,0,0,0,492,3421,1,0,0,0,494,3437,1,
  	0,0,0,496,3439,1,0,0,0,498,3455,1,0,0,0,500,3457,1,0,0,0,502,3471,1,0,
  	0,0,504,3473,1,0,0,0,506,3486,1,0,0,0,508,3490,1,0,0,0,510,3503,1,0,0,
  	0,512,3518,1,0,0,0,514,3525,1,0,0,0,516,3532,1,0,0,0,518,3539,1,0,0,0,
  	520,3546,1,0,0,0,522,3550,1,0,0,0,524,3563,1,0,0,0,526,3576,1,0,0,0,528,
  	3591,1,0,0,0,530,3604,1,0,0,0,532,3617,1,0,0,0,534,3624,1,0,0,0,536,3631,
  	1,0,0,0,538,3635,1,0,0,0,540,3650,1,0,0,0,542,3661,1,0,0,0,544,3672,1,
  	0,0,0,546,3678,1,0,0,0,548,3693,1,0,0,0,550,3695,1,0,0,0,552,3697,1,0,
  	0,0,554,3699,1,0,0,0,556,3706,1,0,0,0,558,3713,1,0,0,0,560,3715,1,0,0,
  	0,562,3717,1,0,0,0,564,3719,1,0,0,0,566,3721,1,0,0,0,568,3723,1,0,0,0,
  	570,3725,1,0,0,0,572,3727,1,0,0,0,574,3729,1,0,0,0,576,3732,1,0,0,0,578,
  	3739,1,0,0,0,580,3748,1,0,0,0,582,3752,1,0,0,0,584,3754,1,0,0,0,586,3766,
  	1,0,0,0,588,3773,1,0,0,0,590,3794,1,0,0,0,592,3798,1,0,0,0,594,3800,1,
  	0,0,0,596,3811,1,0,0,0,598,3822,1,0,0,0,600,3827,1,0,0,0,602,3838,1,0,
  	0,0,604,3843,1,0,0,0,606,3848,1,0,0,0,608,3866,1,0,0,0,610,3878,1,0,0,
  	0,612,3896,1,0,0,0,614,3900,1,0,0,0,616,3911,1,0,0,0,618,3913,1,0,0,0,
  	620,3926,1,0,0,0,622,4044,1,0,0,0,624,4065,1,0,0,0,626,4067,1,0,0,0,628,
  	4080,1,0,0,0,630,4198,1,0,0,0,632,4200,1,0,0,0,634,4219,1,0,0,0,636,4292,
  	1,0,0,0,638,4300,1,0,0,0,640,4315,1,0,0,0,642,4317,1,0,0,0,644,4336,1,
  	0,0,0,646,4348,1,0,0,0,648,4364,1,0,0,0,650,4367,1,0,0,0,652,4377,1,0,
  	0,0,654,4396,1,0,0,0,656,4399,1,0,0,0,658,4409,1,0,0,0,660,4428,1,0,0,
  	0,662,4430,1,0,0,0,664,4432,1,0,0,0,666,4439,1,0,0,0,668,4449,1,0,0,0,
  	670,4458,1,0,0,0,672,4461,1,0,0,0,674,4467,1,0,0,0,676,4473,1,0,0,0,678,
  	4478,1,0,0,0,680,4480,1,0,0,0,682,4482,1,0,0,0,684,4484,1,0,0,0,686,4486,
  	1,0,0,0,688,4488,1,0,0,0,690,4490,1,0,0,0,692,4492,1,0,0,0,694,4494,1,
  	0,0,0,696,4496,1,0,0,0,698,4498,1,0,0,0,700,4500,1,0,0,0,702,4502,1,0,
  	0,0,704,4504,1,0,0,0,706,4517,1,0,0,0,708,4522,1,0,0,0,710,4524,1,0,0,
  	0,712,4526,1,0,0,0,714,4528,1,0,0,0,716,4530,1,0,0,0,718,4532,1,0,0,0,
  	720,4534,1,0,0,0,722,4536,1,0,0,0,724,4538,1,0,0,0,726,4540,1,0,0,0,728,
  	4545,1,0,0,0,730,4550,1,0,0,0,732,4558,1,0,0,0,734,4560,1,0,0,0,736,4562,
  	1,0,0,0,738,4564,1,0,0,0,740,4566,1,0,0,0,742,4568,1,0,0,0,744,4570,1,
  	0,0,0,746,4572,1,0,0,0,748,4574,1,0,0,0,750,4576,1,0,0,0,752,4578,1,0,
  	0,0,754,4580,1,0,0,0,756,4582,1,0,0,0,758,4584,1,0,0,0,760,4586,1,0,0,
  	0,762,4588,1,0,0,0,764,4590,1,0,0,0,766,4592,1,0,0,0,768,4594,1,0,0,0,
  	770,4596,1,0,0,0,772,4598,1,0,0,0,774,776,3,2,1,0,775,774,1,0,0,0,776,
  	779,1,0,0,0,777,775,1,0,0,0,777,778,1,0,0,0,778,780,1,0,0,0,779,777,1,
  	0,0,0,780,781,5,0,0,1,781,1,1,0,0,0,782,786,3,4,2,0,783,786,3,8,4,0,784,
  	786,3,44,22,0,785,782,1,0,0,0,785,783,1,0,0,0,785,784,1,0,0,0,786,3,1,
  	0,0,0,787,788,5,65,0,0,788,789,3,738,369,0,789,794,3,10,5,0,790,791,5,
  	171,0,0,791,793,3,10,5,0,792,790,1,0,0,0,793,796,1,0,0,0,794,792,1,0,
  	0,0,794,795,1,0,0,0,795,798,1,0,0,0,796,794,1,0,0,0,797,799,3,6,3,0,798,
  	797,1,0,0,0,798,799,1,0,0,0,799,800,1,0,0,0,800,801,5,192,0,0,801,5,1,
  	0,0,0,802,803,5,69,0,0,803,808,3,10,5,0,804,805,5,171,0,0,805,807,3,10,
  	5,0,806,804,1,0,0,0,807,810,1,0,0,0,808,806,1,0,0,0,808,809,1,0,0,0,809,
  	7,1,0,0,0,810,808,1,0,0,0,811,812,5,56,0,0,812,813,3,10,5,0,813,814,5,
  	192,0,0,814,9,1,0,0,0,815,816,5,214,0,0,816,11,1,0,0,0,817,819,3,14,7,
  	0,818,817,1,0,0,0,819,822,1,0,0,0,820,818,1,0,0,0,820,821,1,0,0,0,821,
  	823,1,0,0,0,822,820,1,0,0,0,823,824,5,0,0,1,824,13,1,0,0,0,825,831,3,
  	16,8,0,826,831,3,300,150,0,827,831,3,44,22,0,828,831,3,96,48,0,829,831,
  	3,94,47,0,830,825,1,0,0,0,830,826,1,0,0,0,830,827,1,0,0,0,830,828,1,0,
  	0,0,830,829,1,0,0,0,831,15,1,0,0,0,832,834,3,704,352,0,833,832,1,0,0,
  	0,834,837,1,0,0,0,835,833,1,0,0,0,835,836,1,0,0,0,836,838,1,0,0,0,837,
  	835,1,0,0,0,838,839,3,18,9,0,839,841,3,740,370,0,840,842,3,20,10,0,841,
  	840,1,0,0,0,841,842,1,0,0,0,842,844,1,0,0,0,843,845,3,22,11,0,844,843,
  	1,0,0,0,844,845,1,0,0,0,845,846,1,0,0,0,846,850,5,192,0,0,847,849,3,36,
  	18,0,848,847,1,0,0,0,849,852,1,0,0,0,850,848,1,0,0,0,850,851,1,0,0,0,
  	851,853,1,0,0,0,852,850,1,0,0,0,853,854,5,39,0,0,854,17,1,0,0,0,855,856,
  	7,0,0,0,856,19,1,0,0,0,857,858,5,179,0,0,858,859,5,182,0,0,859,864,3,
  	66,33,0,860,861,5,171,0,0,861,863,3,66,33,0,862,860,1,0,0,0,863,866,1,
  	0,0,0,864,862,1,0,0,0,864,865,1,0,0,0,865,867,1,0,0,0,866,864,1,0,0,0,
  	867,868,5,191,0,0,868,21,1,0,0,0,869,870,5,182,0,0,870,875,3,34,17,0,
  	871,872,5,171,0,0,872,874,3,34,17,0,873,871,1,0,0,0,874,877,1,0,0,0,875,
  	873,1,0,0,0,875,876,1,0,0,0,876,878,1,0,0,0,877,875,1,0,0,0,878,879,5,
  	191,0,0,879,901,1,0,0,0,880,881,5,182,0,0,881,884,3,24,12,0,882,883,5,
  	171,0,0,883,885,3,24,12,0,884,882,1,0,0,0,885,886,1,0,0,0,886,884,1,0,
  	0,0,886,887,1,0,0,0,887,888,1,0,0,0,888,889,5,191,0,0,889,901,1,0,0,0,
  	890,891,5,182,0,0,891,892,3,26,13,0,892,893,5,191,0,0,893,901,1,0,0,0,
  	894,895,5,182,0,0,895,896,3,28,14,0,896,897,5,191,0,0,897,901,1,0,0,0,
  	898,899,5,182,0,0,899,901,5,191,0,0,900,869,1,0,0,0,900,880,1,0,0,0,900,
  	890,1,0,0,0,900,894,1,0,0,0,900,898,1,0,0,0,901,23,1,0,0,0,902,904,3,
  	26,13,0,903,902,1,0,0,0,903,904,1,0,0,0,904,907,1,0,0,0,905,907,3,28,
  	14,0,906,903,1,0,0,0,906,905,1,0,0,0,907,25,1,0,0,0,908,909,3,30,15,0,
  	909,27,1,0,0,0,910,911,5,174,0,0,911,912,3,750,375,0,912,914,5,182,0,
  	0,913,915,3,30,15,0,914,913,1,0,0,0,914,915,1,0,0,0,915,916,1,0,0,0,916,
  	917,5,191,0,0,917,29,1,0,0,0,918,931,3,32,16,0,919,920,5,181,0,0,920,
  	925,3,32,16,0,921,922,5,171,0,0,922,924,3,32,16,0,923,921,1,0,0,0,924,
  	927,1,0,0,0,925,923,1,0,0,0,925,926,1,0,0,0,926,928,1,0,0,0,927,925,1,
  	0,0,0,928,929,5,190,0,0,929,931,1,0,0,0,930,918,1,0,0,0,930,919,1,0,0,
  	0,931,31,1,0,0,0,932,937,3,750,375,0,933,934,5,180,0,0,934,935,3,624,
  	312,0,935,936,5,189,0,0,936,938,1,0,0,0,937,933,1,0,0,0,937,938,1,0,0,
  	0,938,33,1,0,0,0,939,941,3,704,352,0,940,939,1,0,0,0,941,944,1,0,0,0,
  	942,940,1,0,0,0,942,943,1,0,0,0,943,945,1,0,0,0,944,942,1,0,0,0,945,961,
  	3,72,36,0,946,948,3,704,352,0,947,946,1,0,0,0,948,951,1,0,0,0,949,947,
  	1,0,0,0,949,950,1,0,0,0,950,952,1,0,0,0,951,949,1,0,0,0,952,961,3,74,
  	37,0,953,955,3,704,352,0,954,953,1,0,0,0,955,958,1,0,0,0,956,954,1,0,
  	0,0,956,957,1,0,0,0,957,959,1,0,0,0,958,956,1,0,0,0,959,961,3,76,38,0,
  	960,942,1,0,0,0,960,949,1,0,0,0,960,956,1,0,0,0,961,35,1,0,0,0,962,963,
  	3,34,17,0,963,964,5,192,0,0,964,986,1,0,0,0,965,986,3,38,19,0,966,986,
  	3,272,136,0,967,986,3,422,211,0,968,970,3,704,352,0,969,968,1,0,0,0,970,
  	973,1,0,0,0,971,969,1,0,0,0,971,972,1,0,0,0,972,974,1,0,0,0,973,971,1,
  	0,0,0,974,975,3,66,33,0,975,976,5,192,0,0,976,986,1,0,0,0,977,979,3,704,
  	352,0,978,977,1,0,0,0,979,982,1,0,0,0,980,978,1,0,0,0,980,981,1,0,0,0,
  	981,983,1,0,0,0,982,980,1,0,0,0,983,986,3,68,34,0,984,986,3,98,49,0,985,
  	962,1,0,0,0,985,965,1,0,0,0,985,966,1,0,0,0,985,967,1,0,0,0,985,971,1,
  	0,0,0,985,980,1,0,0,0,985,984,1,0,0,0,986,37,1,0,0,0,987,989,3,704,352,
  	0,988,987,1,0,0,0,989,992,1,0,0,0,990,988,1,0,0,0,990,991,1,0,0,0,991,
  	993,1,0,0,0,992,990,1,0,0,0,993,1074,3,40,20,0,994,996,3,704,352,0,995,
  	994,1,0,0,0,996,999,1,0,0,0,997,995,1,0,0,0,997,998,1,0,0,0,998,1000,
  	1,0,0,0,999,997,1,0,0,0,1000,1001,3,64,32,0,1001,1002,5,192,0,0,1002,
  	1074,1,0,0,0,1003,1005,3,704,352,0,1004,1003,1,0,0,0,1005,1008,1,0,0,
  	0,1006,1004,1,0,0,0,1006,1007,1,0,0,0,1007,1009,1,0,0,0,1008,1006,1,0,
  	0,0,1009,1074,3,42,21,0,1010,1012,3,704,352,0,1011,1010,1,0,0,0,1012,
  	1015,1,0,0,0,1013,1011,1,0,0,0,1013,1014,1,0,0,0,1014,1016,1,0,0,0,1015,
  	1013,1,0,0,0,1016,1074,3,352,176,0,1017,1019,3,704,352,0,1018,1017,1,
  	0,0,0,1019,1022,1,0,0,0,1020,1018,1,0,0,0,1020,1021,1,0,0,0,1021,1023,
  	1,0,0,0,1022,1020,1,0,0,0,1023,1074,3,202,101,0,1024,1026,3,704,352,0,
  	1025,1024,1,0,0,0,1026,1029,1,0,0,0,1027,1025,1,0,0,0,1027,1028,1,0,0,
  	0,1028,1030,1,0,0,0,1029,1027,1,0,0,0,1030,1074,3,252,126,0,1031,1033,
  	3,704,352,0,1032,1031,1,0,0,0,1033,1036,1,0,0,0,1034,1032,1,0,0,0,1034,
  	1035,1,0,0,0,1035,1037,1,0,0,0,1036,1034,1,0,0,0,1037,1074,3,346,173,
  	0,1038,1040,3,704,352,0,1039,1038,1,0,0,0,1040,1043,1,0,0,0,1041,1039,
  	1,0,0,0,1041,1042,1,0,0,0,1042,1044,1,0,0,0,1043,1041,1,0,0,0,1044,1074,
  	3,358,179,0,1045,1047,3,704,352,0,1046,1045,1,0,0,0,1047,1050,1,0,0,0,
  	1048,1046,1,0,0,0,1048,1049,1,0,0,0,1049,1051,1,0,0,0,1050,1048,1,0,0,
  	0,1051,1074,3,360,180,0,1052,1054,3,704,352,0,1053,1052,1,0,0,0,1054,
  	1057,1,0,0,0,1055,1053,1,0,0,0,1055,1056,1,0,0,0,1056,1058,1,0,0,0,1057,
  	1055,1,0,0,0,1058,1074,3,362,181,0,1059,1061,3,704,352,0,1060,1059,1,
  	0,0,0,1061,1064,1,0,0,0,1062,1060,1,0,0,0,1062,1063,1,0,0,0,1063,1065,
  	1,0,0,0,1064,1062,1,0,0,0,1065,1074,3,278,139,0,1066,1068,3,704,352,0,
  	1067,1066,1,0,0,0,1068,1071,1,0,0,0,1069,1067,1,0,0,0,1069,1070,1,0,0,
  	0,1070,1072,1,0,0,0,1071,1069,1,0,0,0,1072,1074,3,286,143,0,1073,990,
  	1,0,0,0,1073,997,1,0,0,0,1073,1006,1,0,0,0,1073,1013,1,0,0,0,1073,1020,
  	1,0,0,0,1073,1027,1,0,0,0,1073,1034,1,0,0,0,1073,1041,1,0,0,0,1073,1048,
  	1,0,0,0,1073,1055,1,0,0,0,1073,1062,1,0,0,0,1073,1069,1,0,0,0,1074,39,
  	1,0,0,0,1075,1086,3,82,41,0,1076,1086,3,88,44,0,1077,1086,3,80,40,0,1078,
  	1086,3,84,42,0,1079,1086,3,90,45,0,1080,1086,3,86,43,0,1081,1086,3,78,
  	39,0,1082,1086,3,274,137,0,1083,1086,3,176,88,0,1084,1086,3,166,83,0,
  	1085,1075,1,0,0,0,1085,1076,1,0,0,0,1085,1077,1,0,0,0,1085,1078,1,0,0,
  	0,1085,1079,1,0,0,0,1085,1080,1,0,0,0,1085,1081,1,0,0,0,1085,1082,1,0,
  	0,0,1085,1083,1,0,0,0,1085,1084,1,0,0,0,1086,41,1,0,0,0,1087,1088,5,17,
  	0,0,1088,1089,3,120,60,0,1089,1090,5,192,0,0,1090,43,1,0,0,0,1091,1092,
  	5,14,0,0,1092,1093,3,714,357,0,1093,1094,5,192,0,0,1094,1098,3,46,23,
  	0,1095,1097,3,50,25,0,1096,1095,1,0,0,0,1097,1100,1,0,0,0,1098,1096,1,
  	0,0,0,1098,1099,1,0,0,0,1099,1101,1,0,0,0,1100,1098,1,0,0,0,1101,1102,
  	5,36,0,0,1102,45,1,0,0,0,1103,1107,5,18,0,0,1104,1106,3,48,24,0,1105,
  	1104,1,0,0,0,1106,1109,1,0,0,0,1107,1105,1,0,0,0,1107,1108,1,0,0,0,1108,
  	1110,1,0,0,0,1109,1107,1,0,0,0,1110,1111,5,192,0,0,1111,47,1,0,0,0,1112,
  	1113,3,738,369,0,1113,1114,5,174,0,0,1114,1116,1,0,0,0,1115,1112,1,0,
  	0,0,1115,1116,1,0,0,0,1116,1117,1,0,0,0,1117,1118,3,712,356,0,1118,49,
  	1,0,0,0,1119,1120,3,52,26,0,1120,1121,3,60,30,0,1121,1122,5,192,0,0,1122,
  	1140,1,0,0,0,1123,1124,3,54,27,0,1124,1125,3,60,30,0,1125,1126,5,192,
  	0,0,1126,1140,1,0,0,0,1127,1128,3,54,27,0,1128,1129,3,62,31,0,1129,1130,
  	5,192,0,0,1130,1140,1,0,0,0,1131,1132,3,58,29,0,1132,1133,3,60,30,0,1133,
  	1134,5,192,0,0,1134,1140,1,0,0,0,1135,1136,3,58,29,0,1136,1137,3,62,31,
  	0,1137,1138,5,192,0,0,1138,1140,1,0,0,0,1139,1119,1,0,0,0,1139,1123,1,
  	0,0,0,1139,1127,1,0,0,0,1139,1131,1,0,0,0,1139,1135,1,0,0,0,1140,51,1,
  	0,0,0,1141,1142,5,16,0,0,1142,53,1,0,0,0,1143,1144,5,60,0,0,1144,1145,
  	3,56,28,0,1145,55,1,0,0,0,1146,1151,3,766,383,0,1147,1148,5,174,0,0,1148,
  	1150,3,736,368,0,1149,1147,1,0,0,0,1150,1153,1,0,0,0,1151,1149,1,0,0,
  	0,1151,1152,1,0,0,0,1152,57,1,0,0,0,1153,1151,1,0,0,0,1154,1158,5,12,
  	0,0,1155,1156,3,738,369,0,1156,1157,5,174,0,0,1157,1159,1,0,0,0,1158,
  	1155,1,0,0,0,1158,1159,1,0,0,0,1159,1160,1,0,0,0,1160,1161,3,712,356,
  	0,1161,59,1,0,0,0,1162,1166,5,64,0,0,1163,1165,3,738,369,0,1164,1163,
  	1,0,0,0,1165,1168,1,0,0,0,1166,1164,1,0,0,0,1166,1167,1,0,0,0,1167,61,
  	1,0,0,0,1168,1166,1,0,0,0,1169,1173,5,125,0,0,1170,1171,3,738,369,0,1171,
  	1172,5,174,0,0,1172,1174,1,0,0,0,1173,1170,1,0,0,0,1173,1174,1,0,0,0,
  	1174,1175,1,0,0,0,1175,1178,3,712,356,0,1176,1177,5,170,0,0,1177,1179,
  	5,14,0,0,1178,1176,1,0,0,0,1178,1179,1,0,0,0,1179,63,1,0,0,0,1180,1182,
  	5,66,0,0,1181,1183,5,105,0,0,1182,1181,1,0,0,0,1182,1183,1,0,0,0,1183,
  	1185,1,0,0,0,1184,1186,3,164,82,0,1185,1184,1,0,0,0,1185,1186,1,0,0,0,
  	1186,1187,1,0,0,0,1187,1193,3,132,66,0,1188,1189,5,66,0,0,1189,1190,3,
  	70,35,0,1190,1191,3,132,66,0,1191,1193,1,0,0,0,1192,1180,1,0,0,0,1192,
  	1188,1,0,0,0,1193,65,1,0,0,0,1194,1196,5,81,0,0,1195,1197,5,105,0,0,1196,
  	1195,1,0,0,0,1196,1197,1,0,0,0,1197,1199,1,0,0,0,1198,1200,3,164,82,0,
  	1199,1198,1,0,0,0,1199,1200,1,0,0,0,1200,1201,1,0,0,0,1201,1207,3,132,
  	66,0,1202,1203,5,81,0,0,1203,1204,3,70,35,0,1204,1205,3,132,66,0,1205,
  	1207,1,0,0,0,1206,1194,1,0,0,0,1206,1202,1,0,0,0,1207,67,1,0,0,0,1208,
  	1210,5,108,0,0,1209,1211,3,164,82,0,1210,1209,1,0,0,0,1210,1211,1,0,0,
  	0,1211,1212,1,0,0,0,1212,1213,3,138,69,0,1213,1214,5,192,0,0,1214,69,
  	1,0,0,0,1215,1216,7,1,0,0,1216,71,1,0,0,0,1217,1219,5,58,0,0,1218,1220,
  	3,92,46,0,1219,1218,1,0,0,0,1219,1220,1,0,0,0,1220,1222,1,0,0,0,1221,
  	1223,5,105,0,0,1222,1221,1,0,0,0,1222,1223,1,0,0,0,1223,1225,1,0,0,0,
  	1224,1226,3,164,82,0,1225,1224,1,0,0,0,1225,1226,1,0,0,0,1226,1227,1,
  	0,0,0,1227,1228,3,134,67,0,1228,73,1,0,0,0,1229,1231,5,59,0,0,1230,1232,
  	3,92,46,0,1231,1230,1,0,0,0,1231,1232,1,0,0,0,1232,1234,1,0,0,0,1233,
  	1235,5,105,0,0,1234,1233,1,0,0,0,1234,1235,1,0,0,0,1235,1237,1,0,0,0,
  	1236,1238,3,164,82,0,1237,1236,1,0,0,0,1237,1238,1,0,0,0,1238,1239,1,
  	0,0,0,1239,1240,3,134,67,0,1240,75,1,0,0,0,1241,1243,5,80,0,0,1242,1244,
  	3,92,46,0,1243,1242,1,0,0,0,1243,1244,1,0,0,0,1244,1246,1,0,0,0,1245,
  	1247,5,105,0,0,1246,1245,1,0,0,0,1246,1247,1,0,0,0,1247,1249,1,0,0,0,
  	1248,1250,3,164,82,0,1249,1248,1,0,0,0,1249,1250,1,0,0,0,1250,1251,1,
  	0,0,0,1251,1266,3,134,67,0,1252,1253,5,80,0,0,1253,1255,5,95,0,0,1254,
  	1256,5,105,0,0,1255,1254,1,0,0,0,1255,1256,1,0,0,0,1256,1258,1,0,0,0,
  	1257,1259,3,164,82,0,1258,1257,1,0,0,0,1258,1259,1,0,0,0,1259,1260,1,
  	0,0,0,1260,1266,3,142,71,0,1261,1262,5,80,0,0,1262,1263,3,100,50,0,1263,
  	1264,3,142,71,0,1264,1266,1,0,0,0,1265,1241,1,0,0,0,1265,1252,1,0,0,0,
  	1265,1261,1,0,0,0,1266,77,1,0,0,0,1267,1268,5,44,0,0,1268,1269,3,122,
  	61,0,1269,1270,5,192,0,0,1270,79,1,0,0,0,1271,1272,5,61,0,0,1272,1273,
  	3,140,70,0,1273,1274,5,192,0,0,1274,81,1,0,0,0,1275,1277,3,92,46,0,1276,
  	1278,5,105,0,0,1277,1276,1,0,0,0,1277,1278,1,0,0,0,1278,1280,1,0,0,0,
  	1279,1281,3,114,57,0,1280,1279,1,0,0,0,1280,1281,1,0,0,0,1281,1282,1,
  	0,0,0,1282,1283,3,128,64,0,1283,1284,5,192,0,0,1284,1390,1,0,0,0,1285,
  	1287,3,92,46,0,1286,1288,3,106,53,0,1287,1286,1,0,0,0,1287,1288,1,0,0,
  	0,1288,1290,1,0,0,0,1289,1291,5,105,0,0,1290,1289,1,0,0,0,1290,1291,1,
  	0,0,0,1291,1293,1,0,0,0,1292,1294,3,114,57,0,1293,1292,1,0,0,0,1293,1294,
  	1,0,0,0,1294,1295,1,0,0,0,1295,1296,3,126,63,0,1296,1297,5,192,0,0,1297,
  	1390,1,0,0,0,1298,1300,3,92,46,0,1299,1301,7,2,0,0,1300,1299,1,0,0,0,
  	1300,1301,1,0,0,0,1301,1303,1,0,0,0,1302,1304,5,105,0,0,1303,1302,1,0,
  	0,0,1303,1304,1,0,0,0,1304,1305,1,0,0,0,1305,1307,3,164,82,0,1306,1308,
  	3,114,57,0,1307,1306,1,0,0,0,1307,1308,1,0,0,0,1308,1309,1,0,0,0,1309,
  	1310,3,128,64,0,1310,1311,5,192,0,0,1311,1390,1,0,0,0,1312,1314,3,92,
  	46,0,1313,1315,3,106,53,0,1314,1313,1,0,0,0,1314,1315,1,0,0,0,1315,1317,
  	1,0,0,0,1316,1318,7,2,0,0,1317,1316,1,0,0,0,1317,1318,1,0,0,0,1318,1320,
  	1,0,0,0,1319,1321,5,105,0,0,1320,1319,1,0,0,0,1320,1321,1,0,0,0,1321,
  	1322,1,0,0,0,1322,1324,3,164,82,0,1323,1325,3,114,57,0,1324,1323,1,0,
  	0,0,1324,1325,1,0,0,0,1325,1326,1,0,0,0,1326,1327,3,126,63,0,1327,1328,
  	5,192,0,0,1328,1390,1,0,0,0,1329,1331,5,123,0,0,1330,1332,3,112,56,0,
  	1331,1330,1,0,0,0,1331,1332,1,0,0,0,1332,1334,1,0,0,0,1333,1335,5,105,
  	0,0,1334,1333,1,0,0,0,1334,1335,1,0,0,0,1335,1337,1,0,0,0,1336,1338,3,
  	114,57,0,1337,1336,1,0,0,0,1337,1338,1,0,0,0,1338,1339,1,0,0,0,1339,1340,
  	3,128,64,0,1340,1341,5,192,0,0,1341,1390,1,0,0,0,1342,1344,5,123,0,0,
  	1343,1345,3,106,53,0,1344,1343,1,0,0,0,1344,1345,1,0,0,0,1345,1347,1,
  	0,0,0,1346,1348,5,105,0,0,1347,1346,1,0,0,0,1347,1348,1,0,0,0,1348,1350,
  	1,0,0,0,1349,1351,3,114,57,0,1350,1349,1,0,0,0,1350,1351,1,0,0,0,1351,
  	1352,1,0,0,0,1352,1353,3,126,63,0,1353,1354,5,192,0,0,1354,1390,1,0,0,
  	0,1355,1357,5,123,0,0,1356,1358,3,112,56,0,1357,1356,1,0,0,0,1357,1358,
  	1,0,0,0,1358,1360,1,0,0,0,1359,1361,7,2,0,0,1360,1359,1,0,0,0,1360,1361,
  	1,0,0,0,1361,1363,1,0,0,0,1362,1364,5,105,0,0,1363,1362,1,0,0,0,1363,
  	1364,1,0,0,0,1364,1365,1,0,0,0,1365,1367,3,164,82,0,1366,1368,3,114,57,
  	0,1367,1366,1,0,0,0,1367,1368,1,0,0,0,1368,1369,1,0,0,0,1369,1370,3,128,
  	64,0,1370,1371,5,192,0,0,1371,1390,1,0,0,0,1372,1374,5,123,0,0,1373,1375,
  	3,106,53,0,1374,1373,1,0,0,0,1374,1375,1,0,0,0,1375,1377,1,0,0,0,1376,
  	1378,7,2,0,0,1377,1376,1,0,0,0,1377,1378,1,0,0,0,1378,1380,1,0,0,0,1379,
  	1381,5,105,0,0,1380,1379,1,0,0,0,1380,1381,1,0,0,0,1381,1382,1,0,0,0,
  	1382,1384,3,164,82,0,1383,1385,3,114,57,0,1384,1383,1,0,0,0,1384,1385,
  	1,0,0,0,1385,1386,1,0,0,0,1386,1387,3,126,63,0,1387,1388,5,192,0,0,1388,
  	1390,1,0,0,0,1389,1275,1,0,0,0,1389,1285,1,0,0,0,1389,1298,1,0,0,0,1389,
  	1312,1,0,0,0,1389,1329,1,0,0,0,1389,1342,1,0,0,0,1389,1355,1,0,0,0,1389,
  	1372,1,0,0,0,1390,83,1,0,0,0,1391,1392,5,93,0,0,1392,1393,3,136,68,0,
  	1393,1394,5,192,0,0,1394,85,1,0,0,0,1395,1396,5,94,0,0,1396,1397,3,136,
  	68,0,1397,1398,5,192,0,0,1398,87,1,0,0,0,1399,1401,5,95,0,0,1400,1402,
  	5,105,0,0,1401,1400,1,0,0,0,1401,1402,1,0,0,0,1402,1404,1,0,0,0,1403,
  	1405,3,164,82,0,1404,1403,1,0,0,0,1404,1405,1,0,0,0,1405,1406,1,0,0,0,
  	1406,1407,3,140,70,0,1407,1408,5,192,0,0,1408,89,1,0,0,0,1409,1410,5,
  	115,0,0,1410,1411,3,140,70,0,1411,1412,5,192,0,0,1412,91,1,0,0,0,1413,
  	1414,7,3,0,0,1414,93,1,0,0,0,1415,1416,5,140,0,0,1416,1417,3,732,366,
  	0,1417,1418,5,192,0,0,1418,95,1,0,0,0,1419,1420,5,141,0,0,1420,1421,3,
  	732,366,0,1421,1422,5,192,0,0,1422,97,1,0,0,0,1423,1424,5,138,0,0,1424,
  	1425,3,134,67,0,1425,1426,5,192,0,0,1426,99,1,0,0,0,1427,1428,7,4,0,0,
  	1428,101,1,0,0,0,1429,1433,3,752,376,0,1430,1432,3,162,81,0,1431,1430,
  	1,0,0,0,1432,1435,1,0,0,0,1433,1431,1,0,0,0,1433,1434,1,0,0,0,1434,1441,
  	1,0,0,0,1435,1433,1,0,0,0,1436,1437,3,752,376,0,1437,1438,5,176,0,0,1438,
  	1439,3,620,310,0,1439,1441,1,0,0,0,1440,1429,1,0,0,0,1440,1436,1,0,0,
  	0,1441,103,1,0,0,0,1442,1446,3,772,386,0,1443,1445,3,162,81,0,1444,1443,
  	1,0,0,0,1445,1448,1,0,0,0,1446,1444,1,0,0,0,1446,1447,1,0,0,0,1447,1454,
  	1,0,0,0,1448,1446,1,0,0,0,1449,1450,3,772,386,0,1450,1451,5,176,0,0,1451,
  	1452,3,620,310,0,1452,1454,1,0,0,0,1453,1442,1,0,0,0,1453,1449,1,0,0,
  	0,1454,105,1,0,0,0,1455,1456,5,182,0,0,1456,1457,3,108,54,0,1457,1458,
  	5,171,0,0,1458,1459,3,110,55,0,1459,1460,5,191,0,0,1460,1492,1,0,0,0,
  	1461,1462,5,182,0,0,1462,1463,3,110,55,0,1463,1464,5,171,0,0,1464,1465,
  	3,108,54,0,1465,1466,5,191,0,0,1466,1492,1,0,0,0,1467,1468,5,182,0,0,
  	1468,1469,3,108,54,0,1469,1470,5,171,0,0,1470,1471,5,52,0,0,1471,1472,
  	5,191,0,0,1472,1492,1,0,0,0,1473,1474,5,182,0,0,1474,1475,3,110,55,0,
  	1475,1476,5,171,0,0,1476,1477,5,53,0,0,1477,1478,5,191,0,0,1478,1492,
  	1,0,0,0,1479,1480,5,182,0,0,1480,1481,5,53,0,0,1481,1482,5,171,0,0,1482,
  	1483,3,110,55,0,1483,1484,5,191,0,0,1484,1492,1,0,0,0,1485,1486,5,182,
  	0,0,1486,1487,5,52,0,0,1487,1488,5,171,0,0,1488,1489,3,108,54,0,1489,
  	1490,5,191,0,0,1490,1492,1,0,0,0,1491,1455,1,0,0,0,1491,1461,1,0,0,0,
  	1491,1467,1,0,0,0,1491,1473,1,0,0,0,1491,1479,1,0,0,0,1491,1485,1,0,0,
  	0,1492,107,1,0,0,0,1493,1494,7,5,0,0,1494,109,1,0,0,0,1495,1496,7,6,0,
  	0,1496,111,1,0,0,0,1497,1498,5,182,0,0,1498,1499,5,106,0,0,1499,1507,
  	5,191,0,0,1500,1501,5,182,0,0,1501,1502,5,68,0,0,1502,1507,5,191,0,0,
  	1503,1504,5,182,0,0,1504,1505,5,63,0,0,1505,1507,5,191,0,0,1506,1497,
  	1,0,0,0,1506,1500,1,0,0,0,1506,1503,1,0,0,0,1507,113,1,0,0,0,1508,1509,
  	5,179,0,0,1509,1524,3,118,59,0,1510,1511,5,179,0,0,1511,1512,5,182,0,
  	0,1512,1519,3,632,316,0,1513,1514,5,171,0,0,1514,1517,3,632,316,0,1515,
  	1516,5,171,0,0,1516,1518,3,632,316,0,1517,1515,1,0,0,0,1517,1518,1,0,
  	0,0,1518,1520,1,0,0,0,1519,1513,1,0,0,0,1519,1520,1,0,0,0,1520,1521,1,
  	0,0,0,1521,1522,5,191,0,0,1522,1524,1,0,0,0,1523,1508,1,0,0,0,1523,1510,
  	1,0,0,0,1524,115,1,0,0,0,1525,1526,5,179,0,0,1526,1537,3,118,59,0,1527,
  	1528,5,179,0,0,1528,1529,5,182,0,0,1529,1532,3,632,316,0,1530,1531,5,
  	171,0,0,1531,1533,3,632,316,0,1532,1530,1,0,0,0,1532,1533,1,0,0,0,1533,
  	1534,1,0,0,0,1534,1535,5,191,0,0,1535,1537,1,0,0,0,1536,1525,1,0,0,0,
  	1536,1527,1,0,0,0,1537,117,1,0,0,0,1538,1542,3,684,342,0,1539,1542,3,
  	668,334,0,1540,1542,3,732,366,0,1541,1538,1,0,0,0,1541,1539,1,0,0,0,1541,
  	1540,1,0,0,0,1542,119,1,0,0,0,1543,1548,3,146,73,0,1544,1545,5,171,0,
  	0,1545,1547,3,146,73,0,1546,1544,1,0,0,0,1547,1550,1,0,0,0,1548,1546,
  	1,0,0,0,1548,1549,1,0,0,0,1549,121,1,0,0,0,1550,1548,1,0,0,0,1551,1556,
  	3,124,62,0,1552,1553,5,171,0,0,1553,1555,3,124,62,0,1554,1552,1,0,0,0,
  	1555,1558,1,0,0,0,1556,1554,1,0,0,0,1556,1557,1,0,0,0,1557,123,1,0,0,
  	0,1558,1556,1,0,0,0,1559,1563,3,718,359,0,1560,1562,3,162,81,0,1561,1560,
  	1,0,0,0,1562,1565,1,0,0,0,1563,1561,1,0,0,0,1563,1564,1,0,0,0,1564,125,
  	1,0,0,0,1565,1563,1,0,0,0,1566,1571,3,148,74,0,1567,1568,5,171,0,0,1568,
  	1570,3,148,74,0,1569,1567,1,0,0,0,1570,1573,1,0,0,0,1571,1569,1,0,0,0,
  	1571,1572,1,0,0,0,1572,127,1,0,0,0,1573,1571,1,0,0,0,1574,1579,3,130,
  	65,0,1575,1576,5,171,0,0,1576,1578,3,130,65,0,1577,1575,1,0,0,0,1578,
  	1581,1,0,0,0,1579,1577,1,0,0,0,1579,1580,1,0,0,0,1580,129,1,0,0,0,1581,
  	1579,1,0,0,0,1582,1586,3,744,372,0,1583,1585,3,162,81,0,1584,1583,1,0,
  	0,0,1585,1588,1,0,0,0,1586,1584,1,0,0,0,1586,1587,1,0,0,0,1587,131,1,
  	0,0,0,1588,1586,1,0,0,0,1589,1594,3,150,75,0,1590,1591,5,171,0,0,1591,
  	1593,3,150,75,0,1592,1590,1,0,0,0,1593,1596,1,0,0,0,1594,1592,1,0,0,0,
  	1594,1595,1,0,0,0,1595,133,1,0,0,0,1596,1594,1,0,0,0,1597,1602,3,750,
  	375,0,1598,1599,5,171,0,0,1599,1601,3,750,375,0,1600,1598,1,0,0,0,1601,
  	1604,1,0,0,0,1602,1600,1,0,0,0,1602,1603,1,0,0,0,1603,135,1,0,0,0,1604,
  	1602,1,0,0,0,1605,1610,3,102,51,0,1606,1607,5,171,0,0,1607,1609,3,102,
  	51,0,1608,1606,1,0,0,0,1609,1612,1,0,0,0,1610,1608,1,0,0,0,1610,1611,
  	1,0,0,0,1611,137,1,0,0,0,1612,1610,1,0,0,0,1613,1618,3,152,76,0,1614,
  	1615,5,171,0,0,1615,1617,3,152,76,0,1616,1614,1,0,0,0,1617,1620,1,0,0,
  	0,1618,1616,1,0,0,0,1618,1619,1,0,0,0,1619,139,1,0,0,0,1620,1618,1,0,
  	0,0,1621,1626,3,104,52,0,1622,1623,5,171,0,0,1623,1625,3,104,52,0,1624,
  	1622,1,0,0,0,1625,1628,1,0,0,0,1626,1624,1,0,0,0,1626,1627,1,0,0,0,1627,
  	141,1,0,0,0,1628,1626,1,0,0,0,1629,1634,3,144,72,0,1630,1631,5,171,0,
  	0,1631,1633,3,144,72,0,1632,1630,1,0,0,0,1633,1636,1,0,0,0,1634,1632,
  	1,0,0,0,1634,1635,1,0,0,0,1635,143,1,0,0,0,1636,1634,1,0,0,0,1637,1640,
  	3,750,375,0,1638,1639,5,176,0,0,1639,1641,3,620,310,0,1640,1638,1,0,0,
  	0,1640,1641,1,0,0,0,1641,145,1,0,0,0,1642,1643,3,728,364,0,1643,1644,
  	5,176,0,0,1644,1645,3,622,311,0,1645,147,1,0,0,0,1646,1647,3,744,372,
  	0,1647,1648,5,176,0,0,1648,1649,3,628,314,0,1649,149,1,0,0,0,1650,1651,
  	3,748,374,0,1651,1652,5,176,0,0,1652,1653,3,622,311,0,1653,151,1,0,0,
  	0,1654,1655,3,756,378,0,1655,1656,5,176,0,0,1656,1657,3,622,311,0,1657,
  	1660,1,0,0,0,1658,1660,3,154,77,0,1659,1654,1,0,0,0,1659,1658,1,0,0,0,
  	1660,153,1,0,0,0,1661,1662,5,82,0,0,1662,1663,5,176,0,0,1663,1664,5,182,
  	0,0,1664,1667,3,158,79,0,1665,1666,5,171,0,0,1666,1668,3,156,78,0,1667,
  	1665,1,0,0,0,1667,1668,1,0,0,0,1668,1669,1,0,0,0,1669,1670,5,191,0,0,
  	1670,1685,1,0,0,0,1671,1672,5,82,0,0,1672,1673,3,442,221,0,1673,1674,
  	5,172,0,0,1674,1675,3,444,222,0,1675,1676,5,176,0,0,1676,1677,5,182,0,
  	0,1677,1680,3,158,79,0,1678,1679,5,171,0,0,1679,1681,3,156,78,0,1680,
  	1678,1,0,0,0,1680,1681,1,0,0,0,1681,1682,1,0,0,0,1682,1683,5,191,0,0,
  	1683,1685,1,0,0,0,1684,1661,1,0,0,0,1684,1671,1,0,0,0,1685,155,1,0,0,
  	0,1686,1687,3,160,80,0,1687,157,1,0,0,0,1688,1689,3,160,80,0,1689,159,
  	1,0,0,0,1690,1691,3,622,311,0,1691,161,1,0,0,0,1692,1693,5,180,0,0,1693,
  	1694,3,626,313,0,1694,1695,5,170,0,0,1695,1696,3,626,313,0,1696,1697,
  	5,189,0,0,1697,163,1,0,0,0,1698,1699,5,180,0,0,1699,1700,3,638,319,0,
  	1700,1701,5,170,0,0,1701,1702,3,630,315,0,1702,1703,5,189,0,0,1703,165,
  	1,0,0,0,1704,1706,5,49,0,0,1705,1707,5,4,0,0,1706,1705,1,0,0,0,1706,1707,
  	1,0,0,0,1707,1709,1,0,0,0,1708,1710,3,174,87,0,1709,1708,1,0,0,0,1709,
  	1710,1,0,0,0,1710,1711,1,0,0,0,1711,1712,3,720,360,0,1712,1714,5,192,
  	0,0,1713,1715,3,168,84,0,1714,1713,1,0,0,0,1715,1716,1,0,0,0,1716,1714,
  	1,0,0,0,1716,1717,1,0,0,0,1717,1718,1,0,0,0,1718,1719,3,384,192,0,1719,
  	1720,5,37,0,0,1720,1743,1,0,0,0,1721,1723,5,49,0,0,1722,1724,5,4,0,0,
  	1723,1722,1,0,0,0,1723,1724,1,0,0,0,1724,1726,1,0,0,0,1725,1727,3,174,
  	87,0,1726,1725,1,0,0,0,1726,1727,1,0,0,0,1727,1728,1,0,0,0,1728,1729,
  	3,720,360,0,1729,1730,5,182,0,0,1730,1731,3,170,85,0,1731,1732,5,191,
  	0,0,1732,1736,5,192,0,0,1733,1735,3,192,96,0,1734,1733,1,0,0,0,1735,1738,
  	1,0,0,0,1736,1734,1,0,0,0,1736,1737,1,0,0,0,1737,1739,1,0,0,0,1738,1736,
  	1,0,0,0,1739,1740,3,384,192,0,1740,1741,5,37,0,0,1741,1743,1,0,0,0,1742,
  	1704,1,0,0,0,1742,1721,1,0,0,0,1743,167,1,0,0,0,1744,1755,3,192,96,0,
  	1745,1747,3,704,352,0,1746,1745,1,0,0,0,1747,1750,1,0,0,0,1748,1746,1,
  	0,0,0,1748,1749,1,0,0,0,1749,1751,1,0,0,0,1750,1748,1,0,0,0,1751,1752,
  	3,184,92,0,1752,1753,5,192,0,0,1753,1755,1,0,0,0,1754,1744,1,0,0,0,1754,
  	1748,1,0,0,0,1755,169,1,0,0,0,1756,1761,3,172,86,0,1757,1758,5,171,0,
  	0,1758,1760,3,172,86,0,1759,1757,1,0,0,0,1760,1763,1,0,0,0,1761,1759,
  	1,0,0,0,1761,1762,1,0,0,0,1762,171,1,0,0,0,1763,1761,1,0,0,0,1764,1766,
  	3,704,352,0,1765,1764,1,0,0,0,1766,1769,1,0,0,0,1767,1765,1,0,0,0,1767,
  	1768,1,0,0,0,1768,1770,1,0,0,0,1769,1767,1,0,0,0,1770,1771,3,184,92,0,
  	1771,173,1,0,0,0,1772,1782,3,164,82,0,1773,1775,5,105,0,0,1774,1776,3,
  	164,82,0,1775,1774,1,0,0,0,1775,1776,1,0,0,0,1776,1782,1,0,0,0,1777,1782,
  	5,61,0,0,1778,1782,5,93,0,0,1779,1782,5,94,0,0,1780,1782,5,115,0,0,1781,
  	1772,1,0,0,0,1781,1773,1,0,0,0,1781,1777,1,0,0,0,1781,1778,1,0,0,0,1781,
  	1779,1,0,0,0,1781,1780,1,0,0,0,1782,175,1,0,0,0,1783,1785,5,114,0,0,1784,
  	1786,5,4,0,0,1785,1784,1,0,0,0,1785,1786,1,0,0,0,1786,1787,1,0,0,0,1787,
  	1788,3,762,381,0,1788,1792,5,192,0,0,1789,1791,3,178,89,0,1790,1789,1,
  	0,0,0,1791,1794,1,0,0,0,1792,1790,1,0,0,0,1792,1793,1,0,0,0,1793,1795,
  	1,0,0,0,1794,1792,1,0,0,0,1795,1796,3,382,191,0,1796,1797,5,43,0,0,1797,
  	1819,1,0,0,0,1798,1800,5,114,0,0,1799,1801,5,4,0,0,1800,1799,1,0,0,0,
  	1800,1801,1,0,0,0,1801,1802,1,0,0,0,1802,1803,3,762,381,0,1803,1805,5,
  	182,0,0,1804,1806,3,180,90,0,1805,1804,1,0,0,0,1805,1806,1,0,0,0,1806,
  	1807,1,0,0,0,1807,1808,5,191,0,0,1808,1812,5,192,0,0,1809,1811,3,192,
  	96,0,1810,1809,1,0,0,0,1811,1814,1,0,0,0,1812,1810,1,0,0,0,1812,1813,
  	1,0,0,0,1813,1815,1,0,0,0,1814,1812,1,0,0,0,1815,1816,3,382,191,0,1816,
  	1817,5,43,0,0,1817,1819,1,0,0,0,1818,1783,1,0,0,0,1818,1798,1,0,0,0,1819,
  	177,1,0,0,0,1820,1849,3,192,96,0,1821,1823,3,704,352,0,1822,1821,1,0,
  	0,0,1823,1826,1,0,0,0,1824,1822,1,0,0,0,1824,1825,1,0,0,0,1825,1827,1,
  	0,0,0,1826,1824,1,0,0,0,1827,1828,3,184,92,0,1828,1829,5,192,0,0,1829,
  	1849,1,0,0,0,1830,1832,3,704,352,0,1831,1830,1,0,0,0,1832,1835,1,0,0,
  	0,1833,1831,1,0,0,0,1833,1834,1,0,0,0,1834,1836,1,0,0,0,1835,1833,1,0,
  	0,0,1836,1837,3,186,93,0,1837,1838,5,192,0,0,1838,1849,1,0,0,0,1839,1841,
  	3,704,352,0,1840,1839,1,0,0,0,1841,1844,1,0,0,0,1842,1840,1,0,0,0,1842,
  	1843,1,0,0,0,1843,1845,1,0,0,0,1844,1842,1,0,0,0,1845,1846,3,188,94,0,
  	1846,1847,5,192,0,0,1847,1849,1,0,0,0,1848,1820,1,0,0,0,1848,1824,1,0,
  	0,0,1848,1833,1,0,0,0,1848,1842,1,0,0,0,1849,179,1,0,0,0,1850,1855,3,
  	182,91,0,1851,1852,5,171,0,0,1852,1854,3,182,91,0,1853,1851,1,0,0,0,1854,
  	1857,1,0,0,0,1855,1853,1,0,0,0,1855,1856,1,0,0,0,1856,181,1,0,0,0,1857,
  	1855,1,0,0,0,1858,1860,3,704,352,0,1859,1858,1,0,0,0,1860,1863,1,0,0,
  	0,1861,1859,1,0,0,0,1861,1862,1,0,0,0,1862,1864,1,0,0,0,1863,1861,1,0,
  	0,0,1864,1880,3,184,92,0,1865,1867,3,704,352,0,1866,1865,1,0,0,0,1867,
  	1870,1,0,0,0,1868,1866,1,0,0,0,1868,1869,1,0,0,0,1869,1871,1,0,0,0,1870,
  	1868,1,0,0,0,1871,1880,3,186,93,0,1872,1874,3,704,352,0,1873,1872,1,0,
  	0,0,1874,1877,1,0,0,0,1875,1873,1,0,0,0,1875,1876,1,0,0,0,1876,1878,1,
  	0,0,0,1877,1875,1,0,0,0,1878,1880,3,188,94,0,1879,1861,1,0,0,0,1879,1868,
  	1,0,0,0,1879,1875,1,0,0,0,1880,183,1,0,0,0,1881,1883,5,59,0,0,1882,1884,
  	5,95,0,0,1883,1882,1,0,0,0,1883,1884,1,0,0,0,1884,1886,1,0,0,0,1885,1887,
  	5,105,0,0,1886,1885,1,0,0,0,1886,1887,1,0,0,0,1887,1889,1,0,0,0,1888,
  	1890,3,164,82,0,1889,1888,1,0,0,0,1889,1890,1,0,0,0,1890,1891,1,0,0,0,
  	1891,1897,3,134,67,0,1892,1893,5,59,0,0,1893,1894,3,190,95,0,1894,1895,
  	3,134,67,0,1895,1897,1,0,0,0,1896,1881,1,0,0,0,1896,1892,1,0,0,0,1897,
  	185,1,0,0,0,1898,1900,5,80,0,0,1899,1901,5,95,0,0,1900,1899,1,0,0,0,1900,
  	1901,1,0,0,0,1901,1903,1,0,0,0,1902,1904,5,105,0,0,1903,1902,1,0,0,0,
  	1903,1904,1,0,0,0,1904,1906,1,0,0,0,1905,1907,3,164,82,0,1906,1905,1,
  	0,0,0,1906,1907,1,0,0,0,1907,1908,1,0,0,0,1908,1914,3,134,67,0,1909,1910,
  	5,80,0,0,1910,1911,3,190,95,0,1911,1912,3,134,67,0,1912,1914,1,0,0,0,
  	1913,1898,1,0,0,0,1913,1909,1,0,0,0,1914,187,1,0,0,0,1915,1917,5,58,0,
  	0,1916,1918,5,95,0,0,1917,1916,1,0,0,0,1917,1918,1,0,0,0,1918,1920,1,
  	0,0,0,1919,1921,5,105,0,0,1920,1919,1,0,0,0,1920,1921,1,0,0,0,1921,1923,
  	1,0,0,0,1922,1924,3,164,82,0,1923,1922,1,0,0,0,1923,1924,1,0,0,0,1924,
  	1925,1,0,0,0,1925,1931,3,134,67,0,1926,1927,5,58,0,0,1927,1928,3,190,
  	95,0,1928,1929,3,134,67,0,1929,1931,1,0,0,0,1930,1915,1,0,0,0,1930,1926,
  	1,0,0,0,1931,189,1,0,0,0,1932,1933,7,1,0,0,1933,191,1,0,0,0,1934,1936,
  	3,704,352,0,1935,1934,1,0,0,0,1936,1939,1,0,0,0,1937,1935,1,0,0,0,1937,
  	1938,1,0,0,0,1938,1940,1,0,0,0,1939,1937,1,0,0,0,1940,1942,5,95,0,0,1941,
  	1943,5,105,0,0,1942,1941,1,0,0,0,1942,1943,1,0,0,0,1943,1945,1,0,0,0,
  	1944,1946,3,164,82,0,1945,1944,1,0,0,0,1945,1946,1,0,0,0,1946,1947,1,
  	0,0,0,1947,1948,3,194,97,0,1948,1949,5,192,0,0,1949,2016,1,0,0,0,1950,
  	1952,3,704,352,0,1951,1950,1,0,0,0,1952,1955,1,0,0,0,1953,1951,1,0,0,
  	0,1953,1954,1,0,0,0,1954,1956,1,0,0,0,1955,1953,1,0,0,0,1956,1957,5,61,
  	0,0,1957,1958,3,194,97,0,1958,1959,5,192,0,0,1959,2016,1,0,0,0,1960,1962,
  	3,704,352,0,1961,1960,1,0,0,0,1962,1965,1,0,0,0,1963,1961,1,0,0,0,1963,
  	1964,1,0,0,0,1964,1966,1,0,0,0,1965,1963,1,0,0,0,1966,1967,5,115,0,0,
  	1967,1968,3,194,97,0,1968,1969,5,192,0,0,1969,2016,1,0,0,0,1970,1972,
  	3,704,352,0,1971,1970,1,0,0,0,1972,1975,1,0,0,0,1973,1971,1,0,0,0,1973,
  	1974,1,0,0,0,1974,1976,1,0,0,0,1975,1973,1,0,0,0,1976,1977,5,93,0,0,1977,
  	1978,3,196,98,0,1978,1979,5,192,0,0,1979,2016,1,0,0,0,1980,1982,3,704,
  	352,0,1981,1980,1,0,0,0,1982,1985,1,0,0,0,1983,1981,1,0,0,0,1983,1984,
  	1,0,0,0,1984,1986,1,0,0,0,1985,1983,1,0,0,0,1986,1987,5,94,0,0,1987,1988,
  	3,196,98,0,1988,1989,5,192,0,0,1989,2016,1,0,0,0,1990,1992,3,704,352,
  	0,1991,1990,1,0,0,0,1992,1995,1,0,0,0,1993,1991,1,0,0,0,1993,1994,1,0,
  	0,0,1994,1996,1,0,0,0,1995,1993,1,0,0,0,1996,2016,3,78,39,0,1997,1999,
  	3,704,352,0,1998,1997,1,0,0,0,1999,2002,1,0,0,0,2000,1998,1,0,0,0,2000,
  	2001,1,0,0,0,2001,2003,1,0,0,0,2002,2000,1,0,0,0,2003,2004,3,64,32,0,
  	2004,2005,5,192,0,0,2005,2016,1,0,0,0,2006,2008,3,704,352,0,2007,2006,
  	1,0,0,0,2008,2011,1,0,0,0,2009,2007,1,0,0,0,2009,2010,1,0,0,0,2010,2012,
  	1,0,0,0,2011,2009,1,0,0,0,2012,2013,3,66,33,0,2013,2014,5,192,0,0,2014,
  	2016,1,0,0,0,2015,1937,1,0,0,0,2015,1953,1,0,0,0,2015,1963,1,0,0,0,2015,
  	1973,1,0,0,0,2015,1983,1,0,0,0,2015,1993,1,0,0,0,2015,2000,1,0,0,0,2015,
  	2009,1,0,0,0,2016,193,1,0,0,0,2017,2022,3,198,99,0,2018,2019,5,171,0,
  	0,2019,2021,3,198,99,0,2020,2018,1,0,0,0,2021,2024,1,0,0,0,2022,2020,
  	1,0,0,0,2022,2023,1,0,0,0,2023,195,1,0,0,0,2024,2022,1,0,0,0,2025,2030,
  	3,200,100,0,2026,2027,5,171,0,0,2027,2029,3,200,100,0,2028,2026,1,0,0,
  	0,2029,2032,1,0,0,0,2030,2028,1,0,0,0,2030,2031,1,0,0,0,2031,197,1,0,
  	0,0,2032,2030,1,0,0,0,2033,2037,3,772,386,0,2034,2036,3,162,81,0,2035,
  	2034,1,0,0,0,2036,2039,1,0,0,0,2037,2035,1,0,0,0,2037,2038,1,0,0,0,2038,
  	199,1,0,0,0,2039,2037,1,0,0,0,2040,2044,3,752,376,0,2041,2043,3,162,81,
  	0,2042,2041,1,0,0,0,2043,2046,1,0,0,0,2044,2042,1,0,0,0,2044,2045,1,0,
  	0,0,2045,201,1,0,0,0,2046,2044,1,0,0,0,2047,2049,3,238,119,0,2048,2050,
  	3,114,57,0,2049,2048,1,0,0,0,2049,2050,1,0,0,0,2050,2051,1,0,0,0,2051,
  	2056,3,204,102,0,2052,2053,5,171,0,0,2053,2055,3,204,102,0,2054,2052,
  	1,0,0,0,2055,2058,1,0,0,0,2056,2054,1,0,0,0,2056,2057,1,0,0,0,2057,2059,
  	1,0,0,0,2058,2056,1,0,0,0,2059,2060,5,192,0,0,2060,2180,1,0,0,0,2061,
  	2063,3,240,120,0,2062,2064,3,106,53,0,2063,2062,1,0,0,0,2063,2064,1,0,
  	0,0,2064,2066,1,0,0,0,2065,2067,3,114,57,0,2066,2065,1,0,0,0,2066,2067,
  	1,0,0,0,2067,2068,1,0,0,0,2068,2073,3,206,103,0,2069,2070,5,171,0,0,2070,
  	2072,3,206,103,0,2071,2069,1,0,0,0,2072,2075,1,0,0,0,2073,2071,1,0,0,
  	0,2073,2074,1,0,0,0,2074,2076,1,0,0,0,2075,2073,1,0,0,0,2076,2077,5,192,
  	0,0,2077,2180,1,0,0,0,2078,2080,3,242,121,0,2079,2081,3,114,57,0,2080,
  	2079,1,0,0,0,2080,2081,1,0,0,0,2081,2082,1,0,0,0,2082,2087,3,208,104,
  	0,2083,2084,5,171,0,0,2084,2086,3,208,104,0,2085,2083,1,0,0,0,2086,2089,
  	1,0,0,0,2087,2085,1,0,0,0,2087,2088,1,0,0,0,2088,2090,1,0,0,0,2089,2087,
  	1,0,0,0,2090,2091,5,192,0,0,2091,2180,1,0,0,0,2092,2094,3,244,122,0,2093,
  	2095,3,106,53,0,2094,2093,1,0,0,0,2094,2095,1,0,0,0,2095,2097,1,0,0,0,
  	2096,2098,3,116,58,0,2097,2096,1,0,0,0,2097,2098,1,0,0,0,2098,2099,1,
  	0,0,0,2099,2104,3,210,105,0,2100,2101,5,171,0,0,2101,2103,3,210,105,0,
  	2102,2100,1,0,0,0,2103,2106,1,0,0,0,2104,2102,1,0,0,0,2104,2105,1,0,0,
  	0,2105,2107,1,0,0,0,2106,2104,1,0,0,0,2107,2108,5,192,0,0,2108,2180,1,
  	0,0,0,2109,2111,3,246,123,0,2110,2112,3,106,53,0,2111,2110,1,0,0,0,2111,
  	2112,1,0,0,0,2112,2114,1,0,0,0,2113,2115,3,116,58,0,2114,2113,1,0,0,0,
  	2114,2115,1,0,0,0,2115,2116,1,0,0,0,2116,2121,3,212,106,0,2117,2118,5,
  	171,0,0,2118,2120,3,212,106,0,2119,2117,1,0,0,0,2120,2123,1,0,0,0,2121,
  	2119,1,0,0,0,2121,2122,1,0,0,0,2122,2124,1,0,0,0,2123,2121,1,0,0,0,2124,
  	2125,5,192,0,0,2125,2180,1,0,0,0,2126,2128,3,248,124,0,2127,2129,3,116,
  	58,0,2128,2127,1,0,0,0,2128,2129,1,0,0,0,2129,2130,1,0,0,0,2130,2135,
  	3,216,108,0,2131,2132,5,171,0,0,2132,2134,3,216,108,0,2133,2131,1,0,0,
  	0,2134,2137,1,0,0,0,2135,2133,1,0,0,0,2135,2136,1,0,0,0,2136,2138,1,0,
  	0,0,2137,2135,1,0,0,0,2138,2139,5,192,0,0,2139,2180,1,0,0,0,2140,2141,
  	3,250,125,0,2141,2146,3,214,107,0,2142,2143,5,171,0,0,2143,2145,3,214,
  	107,0,2144,2142,1,0,0,0,2145,2148,1,0,0,0,2146,2144,1,0,0,0,2146,2147,
  	1,0,0,0,2147,2149,1,0,0,0,2148,2146,1,0,0,0,2149,2150,5,192,0,0,2150,
  	2180,1,0,0,0,2151,2153,5,86,0,0,2152,2154,3,222,111,0,2153,2152,1,0,0,
  	0,2153,2154,1,0,0,0,2154,2155,1,0,0,0,2155,2160,3,218,109,0,2156,2157,
  	5,171,0,0,2157,2159,3,218,109,0,2158,2156,1,0,0,0,2159,2162,1,0,0,0,2160,
  	2158,1,0,0,0,2160,2161,1,0,0,0,2161,2163,1,0,0,0,2162,2160,1,0,0,0,2163,
  	2164,5,192,0,0,2164,2180,1,0,0,0,2165,2167,5,88,0,0,2166,2168,3,224,112,
  	0,2167,2166,1,0,0,0,2167,2168,1,0,0,0,2168,2169,1,0,0,0,2169,2174,3,218,
  	109,0,2170,2171,5,171,0,0,2171,2173,3,218,109,0,2172,2170,1,0,0,0,2173,
  	2176,1,0,0,0,2174,2172,1,0,0,0,2174,2175,1,0,0,0,2175,2177,1,0,0,0,2176,
  	2174,1,0,0,0,2177,2178,5,192,0,0,2178,2180,1,0,0,0,2179,2047,1,0,0,0,
  	2179,2061,1,0,0,0,2179,2078,1,0,0,0,2179,2092,1,0,0,0,2179,2109,1,0,0,
  	0,2179,2126,1,0,0,0,2179,2140,1,0,0,0,2179,2151,1,0,0,0,2179,2165,1,0,
  	0,0,2180,203,1,0,0,0,2181,2183,3,220,110,0,2182,2181,1,0,0,0,2182,2183,
  	1,0,0,0,2183,2184,1,0,0,0,2184,2185,5,182,0,0,2185,2186,3,234,117,0,2186,
  	2187,5,171,0,0,2187,2188,3,230,115,0,2188,2189,5,171,0,0,2189,2190,3,
  	232,116,0,2190,2191,5,171,0,0,2191,2192,3,236,118,0,2192,2193,5,191,0,
  	0,2193,205,1,0,0,0,2194,2196,3,220,110,0,2195,2194,1,0,0,0,2195,2196,
  	1,0,0,0,2196,2197,1,0,0,0,2197,2198,5,182,0,0,2198,2199,3,234,117,0,2199,
  	2200,5,171,0,0,2200,2201,3,230,115,0,2201,2202,5,171,0,0,2202,2203,3,
  	226,113,0,2203,2204,5,191,0,0,2204,207,1,0,0,0,2205,2207,3,220,110,0,
  	2206,2205,1,0,0,0,2206,2207,1,0,0,0,2207,2208,1,0,0,0,2208,2209,5,182,
  	0,0,2209,2210,3,234,117,0,2210,2211,5,171,0,0,2211,2212,3,230,115,0,2212,
  	2213,5,171,0,0,2213,2214,3,226,113,0,2214,2215,5,191,0,0,2215,209,1,0,
  	0,0,2216,2218,3,220,110,0,2217,2216,1,0,0,0,2217,2218,1,0,0,0,2218,2219,
  	1,0,0,0,2219,2220,5,182,0,0,2220,2221,3,234,117,0,2221,2222,5,171,0,0,
  	2222,2227,3,230,115,0,2223,2224,5,171,0,0,2224,2226,3,230,115,0,2225,
  	2223,1,0,0,0,2226,2229,1,0,0,0,2227,2225,1,0,0,0,2227,2228,1,0,0,0,2228,
  	2230,1,0,0,0,2229,2227,1,0,0,0,2230,2231,5,191,0,0,2231,211,1,0,0,0,2232,
  	2234,3,220,110,0,2233,2232,1,0,0,0,2233,2234,1,0,0,0,2234,2235,1,0,0,
  	0,2235,2236,5,182,0,0,2236,2241,3,234,117,0,2237,2238,5,171,0,0,2238,
  	2240,3,234,117,0,2239,2237,1,0,0,0,2240,2243,1,0,0,0,2241,2239,1,0,0,
  	0,2241,2242,1,0,0,0,2242,2244,1,0,0,0,2243,2241,1,0,0,0,2244,2245,5,171,
  	0,0,2245,2246,3,230,115,0,2246,2247,5,191,0,0,2247,213,1,0,0,0,2248,2250,
  	3,220,110,0,2249,2248,1,0,0,0,2249,2250,1,0,0,0,2250,2251,1,0,0,0,2251,
  	2252,5,182,0,0,2252,2253,3,228,114,0,2253,2254,5,171,0,0,2254,2255,3,
  	228,114,0,2255,2256,5,191,0,0,2256,215,1,0,0,0,2257,2259,3,220,110,0,
  	2258,2257,1,0,0,0,2258,2259,1,0,0,0,2259,2260,1,0,0,0,2260,2261,5,182,
  	0,0,2261,2262,3,228,114,0,2262,2263,5,171,0,0,2263,2264,3,228,114,0,2264,
  	2265,5,171,0,0,2265,2266,3,226,113,0,2266,2267,5,191,0,0,2267,217,1,0,
  	0,0,2268,2270,3,220,110,0,2269,2268,1,0,0,0,2269,2270,1,0,0,0,2270,2271,
  	1,0,0,0,2271,2272,5,182,0,0,2272,2273,3,234,117,0,2273,2274,5,191,0,0,
  	2274,219,1,0,0,0,2275,2277,3,722,361,0,2276,2278,3,164,82,0,2277,2276,
  	1,0,0,0,2277,2278,1,0,0,0,2278,221,1,0,0,0,2279,2280,5,182,0,0,2280,2281,
  	3,108,54,0,2281,2282,5,171,0,0,2282,2283,3,110,55,0,2283,2284,5,191,0,
  	0,2284,2296,1,0,0,0,2285,2286,5,182,0,0,2286,2287,3,110,55,0,2287,2288,
  	5,171,0,0,2288,2289,3,108,54,0,2289,2290,5,191,0,0,2290,2296,1,0,0,0,
  	2291,2292,5,182,0,0,2292,2293,3,108,54,0,2293,2294,5,191,0,0,2294,2296,
  	1,0,0,0,2295,2279,1,0,0,0,2295,2285,1,0,0,0,2295,2291,1,0,0,0,2296,223,
  	1,0,0,0,2297,2298,5,182,0,0,2298,2299,3,108,54,0,2299,2300,5,171,0,0,
  	2300,2301,3,110,55,0,2301,2302,5,191,0,0,2302,2314,1,0,0,0,2303,2304,
  	5,182,0,0,2304,2305,3,110,55,0,2305,2306,5,171,0,0,2306,2307,3,108,54,
  	0,2307,2308,5,191,0,0,2308,2314,1,0,0,0,2309,2310,5,182,0,0,2310,2311,
  	3,110,55,0,2311,2312,5,191,0,0,2312,2314,1,0,0,0,2313,2297,1,0,0,0,2313,
  	2303,1,0,0,0,2313,2309,1,0,0,0,2314,225,1,0,0,0,2315,2316,3,628,314,0,
  	2316,227,1,0,0,0,2317,2318,3,654,327,0,2318,229,1,0,0,0,2319,2320,3,628,
  	314,0,2320,231,1,0,0,0,2321,2322,3,628,314,0,2322,233,1,0,0,0,2323,2324,
  	3,654,327,0,2324,235,1,0,0,0,2325,2326,3,628,314,0,2326,237,1,0,0,0,2327,
  	2328,7,7,0,0,2328,239,1,0,0,0,2329,2330,7,8,0,0,2330,241,1,0,0,0,2331,
  	2332,7,9,0,0,2332,243,1,0,0,0,2333,2334,7,10,0,0,2334,245,1,0,0,0,2335,
  	2336,7,11,0,0,2336,247,1,0,0,0,2337,2338,7,12,0,0,2338,249,1,0,0,0,2339,
  	2340,7,13,0,0,2340,251,1,0,0,0,2341,2343,3,740,370,0,2342,2344,3,254,
  	127,0,2343,2342,1,0,0,0,2343,2344,1,0,0,0,2344,2345,1,0,0,0,2345,2350,
  	3,262,131,0,2346,2347,5,171,0,0,2347,2349,3,262,131,0,2348,2346,1,0,0,
  	0,2349,2352,1,0,0,0,2350,2348,1,0,0,0,2350,2351,1,0,0,0,2351,2353,1,0,
  	0,0,2352,2350,1,0,0,0,2353,2354,5,192,0,0,2354,253,1,0,0,0,2355,2356,
  	5,179,0,0,2356,2357,5,182,0,0,2357,2358,3,256,128,0,2358,2359,5,191,0,
  	0,2359,255,1,0,0,0,2360,2365,3,258,129,0,2361,2362,5,171,0,0,2362,2364,
  	3,258,129,0,2363,2361,1,0,0,0,2364,2367,1,0,0,0,2365,2363,1,0,0,0,2365,
  	2366,1,0,0,0,2366,2377,1,0,0,0,2367,2365,1,0,0,0,2368,2373,3,260,130,
  	0,2369,2370,5,171,0,0,2370,2372,3,260,130,0,2371,2369,1,0,0,0,2372,2375,
  	1,0,0,0,2373,2371,1,0,0,0,2373,2374,1,0,0,0,2374,2377,1,0,0,0,2375,2373,
  	1,0,0,0,2376,2360,1,0,0,0,2376,2368,1,0,0,0,2377,257,1,0,0,0,2378,2379,
  	3,628,314,0,2379,259,1,0,0,0,2380,2381,5,174,0,0,2381,2382,3,748,374,
  	0,2382,2384,5,182,0,0,2383,2385,3,632,316,0,2384,2383,1,0,0,0,2384,2385,
  	1,0,0,0,2385,2386,1,0,0,0,2386,2387,5,191,0,0,2387,261,1,0,0,0,2388,2389,
  	3,264,132,0,2389,2390,5,182,0,0,2390,2391,3,266,133,0,2391,2392,5,191,
  	0,0,2392,263,1,0,0,0,2393,2395,3,742,371,0,2394,2396,3,164,82,0,2395,
  	2394,1,0,0,0,2395,2396,1,0,0,0,2396,265,1,0,0,0,2397,2402,3,268,134,0,
  	2398,2399,5,171,0,0,2399,2401,3,268,134,0,2400,2398,1,0,0,0,2401,2404,
  	1,0,0,0,2402,2400,1,0,0,0,2402,2403,1,0,0,0,2403,2414,1,0,0,0,2404,2402,
  	1,0,0,0,2405,2410,3,270,135,0,2406,2407,5,171,0,0,2407,2409,3,270,135,
  	0,2408,2406,1,0,0,0,2409,2412,1,0,0,0,2410,2408,1,0,0,0,2410,2411,1,0,
  	0,0,2411,2414,1,0,0,0,2412,2410,1,0,0,0,2413,2397,1,0,0,0,2413,2405,1,
  	0,0,0,2414,267,1,0,0,0,2415,2417,3,704,352,0,2416,2415,1,0,0,0,2417,2420,
  	1,0,0,0,2418,2416,1,0,0,0,2418,2419,1,0,0,0,2419,2422,1,0,0,0,2420,2418,
  	1,0,0,0,2421,2423,3,628,314,0,2422,2421,1,0,0,0,2422,2423,1,0,0,0,2423,
  	269,1,0,0,0,2424,2426,3,704,352,0,2425,2424,1,0,0,0,2426,2429,1,0,0,0,
  	2427,2425,1,0,0,0,2427,2428,1,0,0,0,2428,2430,1,0,0,0,2429,2427,1,0,0,
  	0,2430,2431,5,174,0,0,2431,2432,3,750,375,0,2432,2434,5,182,0,0,2433,
  	2435,3,628,314,0,2434,2433,1,0,0,0,2434,2435,1,0,0,0,2435,2436,1,0,0,
  	0,2436,2437,5,191,0,0,2437,271,1,0,0,0,2438,2442,5,50,0,0,2439,2441,3,
  	38,19,0,2440,2439,1,0,0,0,2441,2444,1,0,0,0,2442,2440,1,0,0,0,2442,2443,
  	1,0,0,0,2443,2445,1,0,0,0,2444,2442,1,0,0,0,2445,2446,5,38,0,0,2446,273,
  	1,0,0,0,2447,2448,5,51,0,0,2448,2449,3,276,138,0,2449,2450,5,192,0,0,
  	2450,275,1,0,0,0,2451,2456,3,726,363,0,2452,2453,5,171,0,0,2453,2455,
  	3,726,363,0,2454,2452,1,0,0,0,2455,2458,1,0,0,0,2456,2454,1,0,0,0,2456,
  	2457,1,0,0,0,2457,277,1,0,0,0,2458,2456,1,0,0,0,2459,2460,5,45,0,0,2460,
  	2461,5,182,0,0,2461,2462,3,280,140,0,2462,2463,5,192,0,0,2463,2464,3,
  	282,141,0,2464,2465,5,192,0,0,2465,2466,3,284,142,0,2466,2467,5,191,0,
  	0,2467,2468,3,294,147,0,2468,279,1,0,0,0,2469,2470,3,726,363,0,2470,2471,
  	5,176,0,0,2471,2472,3,620,310,0,2472,281,1,0,0,0,2473,2474,3,620,310,
  	0,2474,283,1,0,0,0,2475,2476,3,726,363,0,2476,2477,5,176,0,0,2477,2478,
  	3,282,141,0,2478,285,1,0,0,0,2479,2482,3,288,144,0,2480,2482,3,290,145,
  	0,2481,2479,1,0,0,0,2481,2480,1,0,0,0,2482,287,1,0,0,0,2483,2484,5,54,
  	0,0,2484,2485,5,182,0,0,2485,2486,3,620,310,0,2486,2487,5,191,0,0,2487,
  	2490,3,298,149,0,2488,2489,5,33,0,0,2489,2491,3,298,149,0,2490,2488,1,
  	0,0,0,2490,2491,1,0,0,0,2491,289,1,0,0,0,2492,2493,5,9,0,0,2493,2494,
  	5,182,0,0,2494,2495,3,620,310,0,2495,2497,5,191,0,0,2496,2498,3,292,146,
  	0,2497,2496,1,0,0,0,2498,2499,1,0,0,0,2499,2497,1,0,0,0,2499,2500,1,0,
  	0,0,2500,2501,1,0,0,0,2501,2502,5,35,0,0,2502,291,1,0,0,0,2503,2508,3,
  	620,310,0,2504,2505,5,171,0,0,2505,2507,3,620,310,0,2506,2504,1,0,0,0,
  	2507,2510,1,0,0,0,2508,2506,1,0,0,0,2508,2509,1,0,0,0,2509,2511,1,0,0,
  	0,2510,2508,1,0,0,0,2511,2512,5,170,0,0,2512,2513,3,298,149,0,2513,2520,
  	1,0,0,0,2514,2516,5,16,0,0,2515,2517,5,170,0,0,2516,2515,1,0,0,0,2516,
  	2517,1,0,0,0,2517,2518,1,0,0,0,2518,2520,3,298,149,0,2519,2503,1,0,0,
  	0,2519,2514,1,0,0,0,2520,293,1,0,0,0,2521,2534,3,38,19,0,2522,2524,5,
  	5,0,0,2523,2525,3,296,148,0,2524,2523,1,0,0,0,2524,2525,1,0,0,0,2525,
  	2529,1,0,0,0,2526,2528,3,38,19,0,2527,2526,1,0,0,0,2528,2531,1,0,0,0,
  	2529,2527,1,0,0,0,2529,2530,1,0,0,0,2530,2532,1,0,0,0,2531,2529,1,0,0,
  	0,2532,2534,5,34,0,0,2533,2521,1,0,0,0,2533,2522,1,0,0,0,2534,295,1,0,
  	0,0,2535,2536,5,170,0,0,2536,2537,3,724,362,0,2537,297,1,0,0,0,2538,2541,
  	3,294,147,0,2539,2541,5,192,0,0,2540,2538,1,0,0,0,2540,2539,1,0,0,0,2541,
  	299,1,0,0,0,2542,2544,3,704,352,0,2543,2542,1,0,0,0,2544,2547,1,0,0,0,
  	2545,2543,1,0,0,0,2545,2546,1,0,0,0,2546,2548,1,0,0,0,2547,2545,1,0,0,
  	0,2548,2549,5,85,0,0,2549,2550,3,768,384,0,2550,2551,5,182,0,0,2551,2552,
  	3,302,151,0,2552,2553,5,191,0,0,2553,2555,5,192,0,0,2554,2556,3,306,153,
  	0,2555,2554,1,0,0,0,2556,2557,1,0,0,0,2557,2555,1,0,0,0,2557,2558,1,0,
  	0,0,2558,2559,1,0,0,0,2559,2560,3,314,157,0,2560,2561,5,40,0,0,2561,2578,
  	1,0,0,0,2562,2564,3,704,352,0,2563,2562,1,0,0,0,2564,2567,1,0,0,0,2565,
  	2563,1,0,0,0,2565,2566,1,0,0,0,2566,2568,1,0,0,0,2567,2565,1,0,0,0,2568,
  	2569,5,85,0,0,2569,2570,3,768,384,0,2570,2571,5,182,0,0,2571,2572,3,304,
  	152,0,2572,2573,5,191,0,0,2573,2574,5,192,0,0,2574,2575,3,314,157,0,2575,
  	2576,5,40,0,0,2576,2578,1,0,0,0,2577,2545,1,0,0,0,2577,2565,1,0,0,0,2578,
  	301,1,0,0,0,2579,2580,3,746,373,0,2580,2581,5,171,0,0,2581,2586,3,734,
  	367,0,2582,2583,5,171,0,0,2583,2585,3,734,367,0,2584,2582,1,0,0,0,2585,
  	2588,1,0,0,0,2586,2584,1,0,0,0,2586,2587,1,0,0,0,2587,303,1,0,0,0,2588,
  	2586,1,0,0,0,2589,2590,3,308,154,0,2590,2591,5,171,0,0,2591,2596,3,310,
  	155,0,2592,2593,5,171,0,0,2593,2595,3,310,155,0,2594,2592,1,0,0,0,2595,
  	2598,1,0,0,0,2596,2594,1,0,0,0,2596,2597,1,0,0,0,2597,305,1,0,0,0,2598,
  	2596,1,0,0,0,2599,2600,3,308,154,0,2600,2601,5,192,0,0,2601,2609,1,0,
  	0,0,2602,2603,3,310,155,0,2603,2604,5,192,0,0,2604,2609,1,0,0,0,2605,
  	2606,3,312,156,0,2606,2607,5,192,0,0,2607,2609,1,0,0,0,2608,2599,1,0,
  	0,0,2608,2602,1,0,0,0,2608,2605,1,0,0,0,2609,307,1,0,0,0,2610,2612,3,
  	704,352,0,2611,2610,1,0,0,0,2612,2615,1,0,0,0,2613,2611,1,0,0,0,2613,
  	2614,1,0,0,0,2614,2616,1,0,0,0,2615,2613,1,0,0,0,2616,2617,5,80,0,0,2617,
  	2632,3,750,375,0,2618,2620,3,704,352,0,2619,2618,1,0,0,0,2620,2623,1,
  	0,0,0,2621,2619,1,0,0,0,2621,2622,1,0,0,0,2622,2624,1,0,0,0,2623,2621,
  	1,0,0,0,2624,2625,5,80,0,0,2625,2626,5,95,0,0,2626,2629,3,750,375,0,2627,
  	2628,5,176,0,0,2628,2630,3,620,310,0,2629,2627,1,0,0,0,2629,2630,1,0,
  	0,0,2630,2632,1,0,0,0,2631,2613,1,0,0,0,2631,2621,1,0,0,0,2632,309,1,
  	0,0,0,2633,2635,3,704,352,0,2634,2633,1,0,0,0,2635,2638,1,0,0,0,2636,
  	2634,1,0,0,0,2636,2637,1,0,0,0,2637,2639,1,0,0,0,2638,2636,1,0,0,0,2639,
  	2640,5,59,0,0,2640,2641,3,134,67,0,2641,311,1,0,0,0,2642,2644,3,704,352,
  	0,2643,2642,1,0,0,0,2644,2647,1,0,0,0,2645,2643,1,0,0,0,2645,2646,1,0,
  	0,0,2646,2648,1,0,0,0,2647,2645,1,0,0,0,2648,2649,5,95,0,0,2649,2650,
  	3,772,386,0,2650,313,1,0,0,0,2651,2654,3,316,158,0,2652,2654,3,320,160,
  	0,2653,2651,1,0,0,0,2653,2652,1,0,0,0,2654,315,1,0,0,0,2655,2657,5,113,
  	0,0,2656,2658,3,318,159,0,2657,2656,1,0,0,0,2658,2659,1,0,0,0,2659,2657,
  	1,0,0,0,2659,2660,1,0,0,0,2660,2661,1,0,0,0,2661,2662,5,42,0,0,2662,317,
  	1,0,0,0,2663,2664,3,330,165,0,2664,2665,5,170,0,0,2665,2666,3,340,170,
  	0,2666,2667,5,192,0,0,2667,319,1,0,0,0,2668,2670,3,322,161,0,2669,2668,
  	1,0,0,0,2669,2670,1,0,0,0,2670,2671,1,0,0,0,2671,2673,5,113,0,0,2672,
  	2674,3,326,163,0,2673,2672,1,0,0,0,2674,2675,1,0,0,0,2675,2673,1,0,0,
  	0,2675,2676,1,0,0,0,2676,2677,1,0,0,0,2677,2678,5,42,0,0,2678,321,1,0,
  	0,0,2679,2680,5,57,0,0,2680,2681,3,746,373,0,2681,2682,5,176,0,0,2682,
  	2683,3,324,162,0,2683,2684,5,192,0,0,2684,323,1,0,0,0,2685,2688,3,672,
  	336,0,2686,2688,3,684,342,0,2687,2685,1,0,0,0,2687,2686,1,0,0,0,2688,
  	325,1,0,0,0,2689,2690,3,328,164,0,2690,2691,5,170,0,0,2691,2692,3,336,
  	168,0,2692,2693,5,170,0,0,2693,2694,3,338,169,0,2694,2695,5,192,0,0,2695,
  	327,1,0,0,0,2696,2699,3,330,165,0,2697,2699,3,332,166,0,2698,2696,1,0,
  	0,0,2698,2697,1,0,0,0,2699,329,1,0,0,0,2700,2702,3,342,171,0,2701,2700,
  	1,0,0,0,2702,2703,1,0,0,0,2703,2701,1,0,0,0,2703,2704,1,0,0,0,2704,331,
  	1,0,0,0,2705,2707,3,342,171,0,2706,2705,1,0,0,0,2707,2710,1,0,0,0,2708,
  	2706,1,0,0,0,2708,2709,1,0,0,0,2709,2711,1,0,0,0,2710,2708,1,0,0,0,2711,
  	2715,3,334,167,0,2712,2714,3,342,171,0,2713,2712,1,0,0,0,2714,2717,1,
  	0,0,0,2715,2713,1,0,0,0,2715,2716,1,0,0,0,2716,333,1,0,0,0,2717,2715,
  	1,0,0,0,2718,2719,5,182,0,0,2719,2720,3,342,171,0,2720,2721,3,342,171,
  	0,2721,2722,5,191,0,0,2722,2725,1,0,0,0,2723,2725,3,344,172,0,2724,2718,
  	1,0,0,0,2724,2723,1,0,0,0,2725,335,1,0,0,0,2726,2727,3,342,171,0,2727,
  	337,1,0,0,0,2728,2731,3,340,170,0,2729,2731,5,184,0,0,2730,2728,1,0,0,
  	0,2730,2729,1,0,0,0,2731,339,1,0,0,0,2732,2733,5,218,0,0,2733,341,1,0,
  	0,0,2734,2735,7,14,0,0,2735,343,1,0,0,0,2736,2737,5,216,0,0,2737,345,
  	1,0,0,0,2738,2740,3,768,384,0,2739,2741,3,106,53,0,2740,2739,1,0,0,0,
  	2740,2741,1,0,0,0,2741,2743,1,0,0,0,2742,2744,3,116,58,0,2743,2742,1,
  	0,0,0,2743,2744,1,0,0,0,2744,2745,1,0,0,0,2745,2750,3,348,174,0,2746,
  	2747,5,171,0,0,2747,2749,3,348,174,0,2748,2746,1,0,0,0,2749,2752,1,0,
  	0,0,2750,2748,1,0,0,0,2750,2751,1,0,0,0,2751,2753,1,0,0,0,2752,2750,1,
  	0,0,0,2753,2754,5,192,0,0,2754,347,1,0,0,0,2755,2757,3,350,175,0,2756,
  	2755,1,0,0,0,2756,2757,1,0,0,0,2757,2758,1,0,0,0,2758,2759,5,182,0,0,
  	2759,2760,3,234,117,0,2760,2761,5,171,0,0,2761,2766,3,230,115,0,2762,
  	2763,5,171,0,0,2763,2765,3,230,115,0,2764,2762,1,0,0,0,2765,2768,1,0,
  	0,0,2766,2764,1,0,0,0,2766,2767,1,0,0,0,2767,2769,1,0,0,0,2768,2766,1,
  	0,0,0,2769,2770,5,191,0,0,2770,349,1,0,0,0,2771,2773,3,770,385,0,2772,
  	2774,3,164,82,0,2773,2772,1,0,0,0,2773,2774,1,0,0,0,2774,351,1,0,0,0,
  	2775,2777,5,3,0,0,2776,2778,3,106,53,0,2777,2776,1,0,0,0,2777,2778,1,
  	0,0,0,2778,2780,1,0,0,0,2779,2781,3,114,57,0,2780,2779,1,0,0,0,2780,2781,
  	1,0,0,0,2781,2782,1,0,0,0,2782,2783,3,354,177,0,2783,2784,5,192,0,0,2784,
  	353,1,0,0,0,2785,2790,3,356,178,0,2786,2787,5,171,0,0,2787,2789,3,356,
  	178,0,2788,2786,1,0,0,0,2789,2792,1,0,0,0,2790,2788,1,0,0,0,2790,2791,
  	1,0,0,0,2791,355,1,0,0,0,2792,2790,1,0,0,0,2793,2794,3,654,327,0,2794,
  	2795,5,176,0,0,2795,2796,3,628,314,0,2796,357,1,0,0,0,2797,2798,5,57,
  	0,0,2798,2799,3,380,190,0,2799,359,1,0,0,0,2800,2801,5,1,0,0,2801,2802,
  	3,380,190,0,2802,361,1,0,0,0,2803,2804,5,137,0,0,2804,2805,3,380,190,
  	0,2805,363,1,0,0,0,2806,2807,3,660,330,0,2807,2809,5,176,0,0,2808,2810,
  	3,388,194,0,2809,2808,1,0,0,0,2809,2810,1,0,0,0,2810,2811,1,0,0,0,2811,
  	2812,3,628,314,0,2812,365,1,0,0,0,2813,2814,3,660,330,0,2814,2816,5,150,
  	0,0,2815,2817,3,388,194,0,2816,2815,1,0,0,0,2816,2817,1,0,0,0,2817,2818,
  	1,0,0,0,2818,2819,3,628,314,0,2819,367,1,0,0,0,2820,2821,3,610,305,0,
  	2821,2823,5,142,0,0,2822,2824,3,388,194,0,2823,2822,1,0,0,0,2823,2824,
  	1,0,0,0,2824,2825,1,0,0,0,2825,2826,3,628,314,0,2826,369,1,0,0,0,2827,
  	2828,5,3,0,0,2828,2836,3,372,186,0,2829,2830,5,15,0,0,2830,2836,3,660,
  	330,0,2831,2832,5,46,0,0,2832,2836,3,372,186,0,2833,2834,5,96,0,0,2834,
  	2836,3,660,330,0,2835,2827,1,0,0,0,2835,2829,1,0,0,0,2835,2831,1,0,0,
  	0,2835,2833,1,0,0,0,2836,371,1,0,0,0,2837,2838,3,660,330,0,2838,2839,
  	5,176,0,0,2839,2840,3,628,314,0,2840,373,1,0,0,0,2841,2849,5,48,0,0,2842,
  	2846,3,376,188,0,2843,2845,3,192,96,0,2844,2843,1,0,0,0,2845,2848,1,0,
  	0,0,2846,2844,1,0,0,0,2846,2847,1,0,0,0,2847,2850,1,0,0,0,2848,2846,1,
  	0,0,0,2849,2842,1,0,0,0,2849,2850,1,0,0,0,2850,2854,1,0,0,0,2851,2853,
  	3,380,190,0,2852,2851,1,0,0,0,2853,2856,1,0,0,0,2854,2852,1,0,0,0,2854,
  	2855,1,0,0,0,2855,2857,1,0,0,0,2856,2854,1,0,0,0,2857,2858,5,62,0,0,2858,
  	375,1,0,0,0,2859,2860,5,170,0,0,2860,2861,3,710,355,0,2861,377,1,0,0,
  	0,2862,2870,5,5,0,0,2863,2867,3,376,188,0,2864,2866,3,192,96,0,2865,2864,
  	1,0,0,0,2866,2869,1,0,0,0,2867,2865,1,0,0,0,2867,2868,1,0,0,0,2868,2871,
  	1,0,0,0,2869,2867,1,0,0,0,2870,2863,1,0,0,0,2870,2871,1,0,0,0,2871,2875,
  	1,0,0,0,2872,2874,3,380,190,0,2873,2872,1,0,0,0,2874,2877,1,0,0,0,2875,
  	2873,1,0,0,0,2875,2876,1,0,0,0,2876,2878,1,0,0,0,2877,2875,1,0,0,0,2878,
  	2879,5,34,0,0,2879,379,1,0,0,0,2880,2882,3,704,352,0,2881,2880,1,0,0,
  	0,2882,2885,1,0,0,0,2883,2881,1,0,0,0,2883,2884,1,0,0,0,2884,2886,1,0,
  	0,0,2885,2883,1,0,0,0,2886,2887,3,364,182,0,2887,2888,5,192,0,0,2888,
  	2994,1,0,0,0,2889,2891,3,704,352,0,2890,2889,1,0,0,0,2891,2894,1,0,0,
  	0,2892,2890,1,0,0,0,2892,2893,1,0,0,0,2893,2895,1,0,0,0,2894,2892,1,0,
  	0,0,2895,2994,3,406,203,0,2896,2898,3,704,352,0,2897,2896,1,0,0,0,2898,
  	2901,1,0,0,0,2899,2897,1,0,0,0,2899,2900,1,0,0,0,2900,2902,1,0,0,0,2901,
  	2899,1,0,0,0,2902,2994,3,404,202,0,2903,2905,3,704,352,0,2904,2903,1,
  	0,0,0,2905,2908,1,0,0,0,2906,2904,1,0,0,0,2906,2907,1,0,0,0,2907,2909,
  	1,0,0,0,2908,2906,1,0,0,0,2909,2994,3,390,195,0,2910,2912,3,704,352,0,
  	2911,2910,1,0,0,0,2912,2915,1,0,0,0,2913,2911,1,0,0,0,2913,2914,1,0,0,
  	0,2914,2916,1,0,0,0,2915,2913,1,0,0,0,2916,2994,3,394,197,0,2917,2919,
  	3,704,352,0,2918,2917,1,0,0,0,2919,2922,1,0,0,0,2920,2918,1,0,0,0,2920,
  	2921,1,0,0,0,2921,2923,1,0,0,0,2922,2920,1,0,0,0,2923,2994,3,410,205,
  	0,2924,2926,3,704,352,0,2925,2924,1,0,0,0,2926,2929,1,0,0,0,2927,2925,
  	1,0,0,0,2927,2928,1,0,0,0,2928,2930,1,0,0,0,2929,2927,1,0,0,0,2930,2931,
  	3,366,183,0,2931,2932,5,192,0,0,2932,2994,1,0,0,0,2933,2935,3,704,352,
  	0,2934,2933,1,0,0,0,2935,2938,1,0,0,0,2936,2934,1,0,0,0,2936,2937,1,0,
  	0,0,2937,2939,1,0,0,0,2938,2936,1,0,0,0,2939,2940,3,368,184,0,2940,2941,
  	5,192,0,0,2941,2994,1,0,0,0,2942,2944,3,704,352,0,2943,2942,1,0,0,0,2944,
  	2947,1,0,0,0,2945,2943,1,0,0,0,2945,2946,1,0,0,0,2946,2948,1,0,0,0,2947,
  	2945,1,0,0,0,2948,2994,3,374,187,0,2949,2951,3,704,352,0,2950,2949,1,
  	0,0,0,2951,2954,1,0,0,0,2952,2950,1,0,0,0,2952,2953,1,0,0,0,2953,2955,
  	1,0,0,0,2954,2952,1,0,0,0,2955,2956,3,370,185,0,2956,2957,5,192,0,0,2957,
  	2994,1,0,0,0,2958,2960,3,704,352,0,2959,2958,1,0,0,0,2960,2963,1,0,0,
  	0,2961,2959,1,0,0,0,2961,2962,1,0,0,0,2962,2964,1,0,0,0,2963,2961,1,0,
  	0,0,2964,2994,3,400,200,0,2965,2967,3,704,352,0,2966,2965,1,0,0,0,2967,
  	2970,1,0,0,0,2968,2966,1,0,0,0,2968,2969,1,0,0,0,2969,2971,1,0,0,0,2970,
  	2968,1,0,0,0,2971,2994,3,378,189,0,2972,2974,3,704,352,0,2973,2972,1,
  	0,0,0,2974,2977,1,0,0,0,2975,2973,1,0,0,0,2975,2976,1,0,0,0,2976,2978,
  	1,0,0,0,2977,2975,1,0,0,0,2978,2994,3,412,206,0,2979,2981,3,704,352,0,
  	2980,2979,1,0,0,0,2981,2984,1,0,0,0,2982,2980,1,0,0,0,2982,2983,1,0,0,
  	0,2983,2985,1,0,0,0,2984,2982,1,0,0,0,2985,2994,3,418,209,0,2986,2988,
  	3,704,352,0,2987,2986,1,0,0,0,2988,2991,1,0,0,0,2989,2987,1,0,0,0,2989,
  	2990,1,0,0,0,2990,2992,1,0,0,0,2991,2989,1,0,0,0,2992,2994,3,402,201,
  	0,2993,2883,1,0,0,0,2993,2892,1,0,0,0,2993,2899,1,0,0,0,2993,2906,1,0,
  	0,0,2993,2913,1,0,0,0,2993,2920,1,0,0,0,2993,2927,1,0,0,0,2993,2936,1,
  	0,0,0,2993,2945,1,0,0,0,2993,2952,1,0,0,0,2993,2961,1,0,0,0,2993,2968,
  	1,0,0,0,2993,2975,1,0,0,0,2993,2982,1,0,0,0,2993,2989,1,0,0,0,2994,381,
  	1,0,0,0,2995,3004,3,380,190,0,2996,2998,3,704,352,0,2997,2996,1,0,0,0,
  	2998,3001,1,0,0,0,2999,2997,1,0,0,0,2999,3000,1,0,0,0,3000,3002,1,0,0,
  	0,3001,2999,1,0,0,0,3002,3004,5,192,0,0,3003,2995,1,0,0,0,3003,2999,1,
  	0,0,0,3004,383,1,0,0,0,3005,3006,3,380,190,0,3006,385,1,0,0,0,3007,3008,
  	5,179,0,0,3008,3015,3,118,59,0,3009,3010,5,179,0,0,3010,3011,5,182,0,
  	0,3011,3012,3,632,316,0,3012,3013,5,191,0,0,3013,3015,1,0,0,0,3014,3007,
  	1,0,0,0,3014,3009,1,0,0,0,3015,387,1,0,0,0,3016,3025,3,386,193,0,3017,
  	3025,3,392,196,0,3018,3019,5,97,0,0,3019,3020,5,182,0,0,3020,3021,3,628,
  	314,0,3021,3022,5,191,0,0,3022,3023,3,392,196,0,3023,3025,1,0,0,0,3024,
  	3016,1,0,0,0,3024,3017,1,0,0,0,3024,3018,1,0,0,0,3025,389,1,0,0,0,3026,
  	3027,5,19,0,0,3027,3028,3,728,364,0,3028,3029,5,192,0,0,3029,391,1,0,
  	0,0,3030,3031,5,168,0,0,3031,3044,3,728,364,0,3032,3033,5,168,0,0,3033,
  	3034,5,182,0,0,3034,3035,3,396,198,0,3035,3036,5,191,0,0,3036,3044,1,
  	0,0,0,3037,3038,5,168,0,0,3038,3044,5,167,0,0,3039,3040,5,168,0,0,3040,
  	3041,5,182,0,0,3041,3042,5,167,0,0,3042,3044,5,191,0,0,3043,3030,1,0,
  	0,0,3043,3032,1,0,0,0,3043,3037,1,0,0,0,3043,3039,1,0,0,0,3044,393,1,
  	0,0,0,3045,3046,5,149,0,0,3046,3048,3,728,364,0,3047,3049,3,652,326,0,
  	3048,3047,1,0,0,0,3048,3049,1,0,0,0,3049,3050,1,0,0,0,3050,3051,5,192,
  	0,0,3051,395,1,0,0,0,3052,3053,6,198,-1,0,3053,3059,3,628,314,0,3054,
  	3055,5,84,0,0,3055,3059,3,628,314,0,3056,3057,5,72,0,0,3057,3059,3,628,
  	314,0,3058,3052,1,0,0,0,3058,3054,1,0,0,0,3058,3056,1,0,0,0,3059,3068,
  	1,0,0,0,3060,3061,10,2,0,0,3061,3062,5,79,0,0,3062,3067,3,396,198,3,3063,
  	3064,10,1,0,0,3064,3065,5,171,0,0,3065,3067,3,396,198,2,3066,3060,1,0,
  	0,0,3066,3063,1,0,0,0,3067,3070,1,0,0,0,3068,3066,1,0,0,0,3068,3069,1,
  	0,0,0,3069,397,1,0,0,0,3070,3068,1,0,0,0,3071,3074,3,386,193,0,3072,3074,
  	3,392,196,0,3073,3071,1,0,0,0,3073,3072,1,0,0,0,3074,399,1,0,0,0,3075,
  	3076,3,398,199,0,3076,3077,3,382,191,0,3077,401,1,0,0,0,3078,3079,5,128,
  	0,0,3079,3080,5,182,0,0,3080,3081,3,628,314,0,3081,3082,5,191,0,0,3082,
  	3083,3,382,191,0,3083,403,1,0,0,0,3084,3085,5,54,0,0,3085,3086,5,182,
  	0,0,3086,3087,3,628,314,0,3087,3088,5,191,0,0,3088,3091,3,382,191,0,3089,
  	3090,5,33,0,0,3090,3092,3,382,191,0,3091,3089,1,0,0,0,3091,3092,1,0,0,
  	0,3092,405,1,0,0,0,3093,3094,5,9,0,0,3094,3095,5,182,0,0,3095,3096,3,
  	628,314,0,3096,3098,5,191,0,0,3097,3099,3,408,204,0,3098,3097,1,0,0,0,
  	3099,3100,1,0,0,0,3100,3098,1,0,0,0,3100,3101,1,0,0,0,3101,3102,1,0,0,
  	0,3102,3103,5,35,0,0,3103,3127,1,0,0,0,3104,3105,5,11,0,0,3105,3106,5,
  	182,0,0,3106,3107,3,628,314,0,3107,3109,5,191,0,0,3108,3110,3,408,204,
  	0,3109,3108,1,0,0,0,3110,3111,1,0,0,0,3111,3109,1,0,0,0,3111,3112,1,0,
  	0,0,3112,3113,1,0,0,0,3113,3114,5,35,0,0,3114,3127,1,0,0,0,3115,3116,
  	5,10,0,0,3116,3117,5,182,0,0,3117,3118,3,628,314,0,3118,3120,5,191,0,
  	0,3119,3121,3,408,204,0,3120,3119,1,0,0,0,3121,3122,1,0,0,0,3122,3120,
  	1,0,0,0,3122,3123,1,0,0,0,3123,3124,1,0,0,0,3124,3125,5,35,0,0,3125,3127,
  	1,0,0,0,3126,3093,1,0,0,0,3126,3104,1,0,0,0,3126,3115,1,0,0,0,3127,407,
  	1,0,0,0,3128,3133,3,628,314,0,3129,3130,5,171,0,0,3130,3132,3,628,314,
  	0,3131,3129,1,0,0,0,3132,3135,1,0,0,0,3133,3131,1,0,0,0,3133,3134,1,0,
  	0,0,3134,3136,1,0,0,0,3135,3133,1,0,0,0,3136,3137,5,170,0,0,3137,3138,
  	3,382,191,0,3138,3145,1,0,0,0,3139,3141,5,16,0,0,3140,3142,5,170,0,0,
  	3141,3140,1,0,0,0,3141,3142,1,0,0,0,3142,3143,1,0,0,0,3143,3145,3,382,
  	191,0,3144,3128,1,0,0,0,3144,3139,1,0,0,0,3145,409,1,0,0,0,3146,3147,
  	5,47,0,0,3147,3171,3,380,190,0,3148,3149,5,97,0,0,3149,3150,5,182,0,0,
  	3150,3151,3,628,314,0,3151,3152,5,191,0,0,3152,3153,3,380,190,0,3153,
  	3171,1,0,0,0,3154,3155,5,132,0,0,3155,3156,5,182,0,0,3156,3157,3,628,
  	314,0,3157,3158,5,191,0,0,3158,3159,3,380,190,0,3159,3171,1,0,0,0,3160,
  	3161,5,45,0,0,3161,3162,5,182,0,0,3162,3163,3,372,186,0,3163,3164,5,192,
  	0,0,3164,3165,3,628,314,0,3165,3166,5,192,0,0,3166,3167,3,372,186,0,3167,
  	3168,5,191,0,0,3168,3169,3,380,190,0,3169,3171,1,0,0,0,3170,3146,1,0,
  	0,0,3170,3148,1,0,0,0,3170,3154,1,0,0,0,3170,3160,1,0,0,0,3171,411,1,
  	0,0,0,3172,3174,3,760,380,0,3173,3175,3,414,207,0,3174,3173,1,0,0,0,3174,
  	3175,1,0,0,0,3175,3176,1,0,0,0,3176,3177,5,192,0,0,3177,413,1,0,0,0,3178,
  	3179,5,182,0,0,3179,3184,3,416,208,0,3180,3181,5,171,0,0,3181,3183,3,
  	416,208,0,3182,3180,1,0,0,0,3183,3186,1,0,0,0,3184,3182,1,0,0,0,3184,
  	3185,1,0,0,0,3185,3187,1,0,0,0,3186,3184,1,0,0,0,3187,3188,5,191,0,0,
  	3188,415,1,0,0,0,3189,3191,3,628,314,0,3190,3189,1,0,0,0,3190,3191,1,
  	0,0,0,3191,417,1,0,0,0,3192,3194,3,728,364,0,3193,3195,3,420,210,0,3194,
  	3193,1,0,0,0,3194,3195,1,0,0,0,3195,3196,1,0,0,0,3196,3197,5,192,0,0,
  	3197,419,1,0,0,0,3198,3199,5,182,0,0,3199,3204,3,628,314,0,3200,3201,
  	5,171,0,0,3201,3203,3,628,314,0,3202,3200,1,0,0,0,3203,3206,1,0,0,0,3204,
  	3202,1,0,0,0,3204,3205,1,0,0,0,3205,3207,1,0,0,0,3206,3204,1,0,0,0,3207,
  	3208,5,191,0,0,3208,421,1,0,0,0,3209,3213,5,107,0,0,3210,3212,3,424,212,
  	0,3211,3210,1,0,0,0,3212,3215,1,0,0,0,3213,3211,1,0,0,0,3213,3214,1,0,
  	0,0,3214,3216,1,0,0,0,3215,3213,1,0,0,0,3216,3217,5,41,0,0,3217,423,1,
  	0,0,0,3218,3224,3,68,34,0,3219,3224,3,426,213,0,3220,3224,3,428,214,0,
  	3221,3224,3,430,215,0,3222,3224,3,502,251,0,3223,3218,1,0,0,0,3223,3219,
  	1,0,0,0,3223,3220,1,0,0,0,3223,3221,1,0,0,0,3223,3222,1,0,0,0,3224,425,
  	1,0,0,0,3225,3226,5,91,0,0,3226,3227,3,440,220,0,3227,3228,5,192,0,0,
  	3228,3234,1,0,0,0,3229,3230,5,90,0,0,3230,3231,3,440,220,0,3231,3232,
  	5,192,0,0,3232,3234,1,0,0,0,3233,3225,1,0,0,0,3233,3229,1,0,0,0,3234,
  	427,1,0,0,0,3235,3236,5,104,0,0,3236,3237,3,440,220,0,3237,3238,5,192,
  	0,0,3238,3244,1,0,0,0,3239,3240,5,75,0,0,3240,3241,3,440,220,0,3241,3242,
  	5,192,0,0,3242,3244,1,0,0,0,3243,3235,1,0,0,0,3243,3239,1,0,0,0,3244,
  	429,1,0,0,0,3245,3246,3,432,216,0,3246,3247,5,192,0,0,3247,3255,1,0,0,
  	0,3248,3249,3,488,244,0,3249,3250,5,192,0,0,3250,3255,1,0,0,0,3251,3252,
  	3,498,249,0,3252,3253,5,192,0,0,3253,3255,1,0,0,0,3254,3245,1,0,0,0,3254,
  	3248,1,0,0,0,3254,3251,1,0,0,0,3255,431,1,0,0,0,3256,3257,3,434,217,0,
  	3257,3258,5,176,0,0,3258,3259,3,450,225,0,3259,3265,1,0,0,0,3260,3261,
  	3,436,218,0,3261,3262,5,176,0,0,3262,3263,3,450,225,0,3263,3265,1,0,0,
  	0,3264,3256,1,0,0,0,3264,3260,1,0,0,0,3265,433,1,0,0,0,3266,3267,5,182,
  	0,0,3267,3269,3,442,221,0,3268,3270,3,500,250,0,3269,3268,1,0,0,0,3269,
  	3270,1,0,0,0,3270,3271,1,0,0,0,3271,3272,5,160,0,0,3272,3273,3,444,222,
  	0,3273,3274,5,191,0,0,3274,435,1,0,0,0,3275,3276,5,182,0,0,3276,3278,
  	3,438,219,0,3277,3279,3,500,250,0,3278,3277,1,0,0,0,3278,3279,1,0,0,0,
  	3279,3280,1,0,0,0,3280,3281,5,153,0,0,3281,3282,3,440,220,0,3282,3283,
  	5,191,0,0,3283,437,1,0,0,0,3284,3289,3,442,221,0,3285,3286,5,171,0,0,
  	3286,3288,3,442,221,0,3287,3285,1,0,0,0,3288,3291,1,0,0,0,3289,3287,1,
  	0,0,0,3289,3290,1,0,0,0,3290,439,1,0,0,0,3291,3289,1,0,0,0,3292,3297,
  	3,444,222,0,3293,3294,5,171,0,0,3294,3296,3,444,222,0,3295,3293,1,0,0,
  	0,3296,3299,1,0,0,0,3297,3295,1,0,0,0,3297,3298,1,0,0,0,3298,441,1,0,
  	0,0,3299,3297,1,0,0,0,3300,3305,3,446,223,0,3301,3302,5,180,0,0,3302,
  	3303,3,624,312,0,3303,3304,5,189,0,0,3304,3306,1,0,0,0,3305,3301,1,0,
  	0,0,3305,3306,1,0,0,0,3306,443,1,0,0,0,3307,3312,3,448,224,0,3308,3309,
  	5,180,0,0,3309,3310,3,624,312,0,3310,3311,5,189,0,0,3311,3313,1,0,0,0,
  	3312,3308,1,0,0,0,3312,3313,1,0,0,0,3313,445,1,0,0,0,3314,3315,3,750,
  	375,0,3315,447,1,0,0,0,3316,3317,3,750,375,0,3317,449,1,0,0,0,3318,3324,
  	3,452,226,0,3319,3320,5,182,0,0,3320,3321,3,452,226,0,3321,3322,5,191,
  	0,0,3322,3324,1,0,0,0,3323,3318,1,0,0,0,3323,3319,1,0,0,0,3324,451,1,
  	0,0,0,3325,3360,3,454,227,0,3326,3327,3,456,228,0,3327,3328,5,171,0,0,
  	3328,3331,3,458,229,0,3329,3330,5,171,0,0,3330,3332,3,460,230,0,3331,
  	3329,1,0,0,0,3331,3332,1,0,0,0,3332,3360,1,0,0,0,3333,3334,3,462,231,
  	0,3334,3335,5,171,0,0,3335,3336,3,464,232,0,3336,3337,5,171,0,0,3337,
  	3338,3,466,233,0,3338,3339,5,171,0,0,3339,3340,3,468,234,0,3340,3341,
  	5,171,0,0,3341,3342,3,470,235,0,3342,3343,5,171,0,0,3343,3357,3,472,236,
  	0,3344,3345,5,171,0,0,3345,3346,3,474,237,0,3346,3347,5,171,0,0,3347,
  	3348,3,476,238,0,3348,3349,5,171,0,0,3349,3350,3,478,239,0,3350,3351,
  	5,171,0,0,3351,3352,3,480,240,0,3352,3353,5,171,0,0,3353,3354,3,482,241,
  	0,3354,3355,5,171,0,0,3355,3356,3,484,242,0,3356,3358,1,0,0,0,3357,3344,
  	1,0,0,0,3357,3358,1,0,0,0,3358,3360,1,0,0,0,3359,3325,1,0,0,0,3359,3326,
  	1,0,0,0,3359,3333,1,0,0,0,3360,453,1,0,0,0,3361,3362,3,486,243,0,3362,
  	455,1,0,0,0,3363,3364,3,486,243,0,3364,457,1,0,0,0,3365,3366,3,486,243,
  	0,3366,459,1,0,0,0,3367,3368,3,486,243,0,3368,461,1,0,0,0,3369,3370,3,
  	486,243,0,3370,463,1,0,0,0,3371,3372,3,486,243,0,3372,465,1,0,0,0,3373,
  	3374,3,486,243,0,3374,467,1,0,0,0,3375,3376,3,486,243,0,3376,469,1,0,
  	0,0,3377,3378,3,486,243,0,3378,471,1,0,0,0,3379,3380,3,486,243,0,3380,
  	473,1,0,0,0,3381,3382,3,486,243,0,3382,475,1,0,0,0,3383,3384,3,486,243,
  	0,3384,477,1,0,0,0,3385,3386,3,486,243,0,3386,479,1,0,0,0,3387,3388,3,
  	486,243,0,3388,481,1,0,0,0,3389,3390,3,486,243,0,3390,483,1,0,0,0,3391,
  	3392,3,486,243,0,3392,485,1,0,0,0,3393,3394,3,622,311,0,3394,487,1,0,
  	0,0,3395,3396,3,490,245,0,3396,3397,5,176,0,0,3397,3398,3,450,225,0,3398,
  	3404,1,0,0,0,3399,3400,3,492,246,0,3400,3401,5,176,0,0,3401,3402,3,450,
  	225,0,3402,3404,1,0,0,0,3403,3395,1,0,0,0,3403,3399,1,0,0,0,3404,489,
  	1,0,0,0,3405,3407,5,182,0,0,3406,3408,3,496,248,0,3407,3406,1,0,0,0,3407,
  	3408,1,0,0,0,3408,3409,1,0,0,0,3409,3410,3,442,221,0,3410,3411,5,160,
  	0,0,3411,3412,5,182,0,0,3412,3414,3,444,222,0,3413,3415,3,500,250,0,3414,
  	3413,1,0,0,0,3414,3415,1,0,0,0,3415,3416,1,0,0,0,3416,3417,5,170,0,0,
  	3417,3418,3,494,247,0,3418,3419,5,191,0,0,3419,3420,5,191,0,0,3420,491,
  	1,0,0,0,3421,3423,5,182,0,0,3422,3424,3,496,248,0,3423,3422,1,0,0,0,3423,
  	3424,1,0,0,0,3424,3425,1,0,0,0,3425,3426,3,438,219,0,3426,3427,5,153,
  	0,0,3427,3428,5,182,0,0,3428,3430,3,440,220,0,3429,3431,3,500,250,0,3430,
  	3429,1,0,0,0,3430,3431,1,0,0,0,3431,3432,1,0,0,0,3432,3433,5,170,0,0,
  	3433,3434,3,494,247,0,3434,3435,5,191,0,0,3435,3436,5,191,0,0,3436,493,
  	1,0,0,0,3437,3438,3,628,314,0,3438,495,1,0,0,0,3439,3440,7,15,0,0,3440,
  	497,1,0,0,0,3441,3442,5,54,0,0,3442,3443,5,182,0,0,3443,3444,3,634,317,
  	0,3444,3445,5,191,0,0,3445,3446,3,432,216,0,3446,3456,1,0,0,0,3447,3448,
  	5,54,0,0,3448,3449,5,182,0,0,3449,3450,3,634,317,0,3450,3451,5,191,0,
  	0,3451,3452,3,488,244,0,3452,3456,1,0,0,0,3453,3454,5,55,0,0,3454,3456,
  	3,432,216,0,3455,3441,1,0,0,0,3455,3447,1,0,0,0,3455,3453,1,0,0,0,3456,
  	499,1,0,0,0,3457,3458,7,16,0,0,3458,501,1,0,0,0,3459,3472,3,504,252,0,
  	3460,3472,3,508,254,0,3461,3472,3,510,255,0,3462,3472,3,522,261,0,3463,
  	3472,3,524,262,0,3464,3472,3,526,263,0,3465,3472,3,528,264,0,3466,3472,
  	3,530,265,0,3467,3472,3,538,269,0,3468,3472,3,540,270,0,3469,3472,3,542,
  	271,0,3470,3472,3,546,273,0,3471,3459,1,0,0,0,3471,3460,1,0,0,0,3471,
  	3461,1,0,0,0,3471,3462,1,0,0,0,3471,3463,1,0,0,0,3471,3464,1,0,0,0,3471,
  	3465,1,0,0,0,3471,3466,1,0,0,0,3471,3467,1,0,0,0,3471,3468,1,0,0,0,3471,
  	3469,1,0,0,0,3471,3470,1,0,0,0,3472,503,1,0,0,0,3473,3474,5,27,0,0,3474,
  	3475,5,182,0,0,3475,3476,3,552,276,0,3476,3477,5,171,0,0,3477,3478,3,
  	564,282,0,3478,3479,5,171,0,0,3479,3481,3,574,287,0,3480,3482,3,506,253,
  	0,3481,3480,1,0,0,0,3481,3482,1,0,0,0,3482,3483,1,0,0,0,3483,3484,5,191,
  	0,0,3484,3485,5,192,0,0,3485,505,1,0,0,0,3486,3488,5,171,0,0,3487,3489,
  	3,562,281,0,3488,3487,1,0,0,0,3488,3489,1,0,0,0,3489,507,1,0,0,0,3490,
  	3491,5,21,0,0,3491,3492,5,182,0,0,3492,3493,3,564,282,0,3493,3494,5,171,
  	0,0,3494,3495,3,552,276,0,3495,3496,5,171,0,0,3496,3498,3,574,287,0,3497,
  	3499,3,506,253,0,3498,3497,1,0,0,0,3498,3499,1,0,0,0,3499,3500,1,0,0,
  	0,3500,3501,5,191,0,0,3501,3502,5,192,0,0,3502,509,1,0,0,0,3503,3504,
  	5,28,0,0,3504,3505,5,182,0,0,3505,3506,3,564,282,0,3506,3507,5,171,0,
  	0,3507,3508,3,552,276,0,3508,3509,5,171,0,0,3509,3510,3,574,287,0,3510,
  	3511,5,171,0,0,3511,3513,3,574,287,0,3512,3514,3,512,256,0,3513,3512,
  	1,0,0,0,3513,3514,1,0,0,0,3514,3515,1,0,0,0,3515,3516,5,191,0,0,3516,
  	3517,5,192,0,0,3517,511,1,0,0,0,3518,3520,5,171,0,0,3519,3521,3,562,281,
  	0,3520,3519,1,0,0,0,3520,3521,1,0,0,0,3521,3523,1,0,0,0,3522,3524,3,514,
  	257,0,3523,3522,1,0,0,0,3523,3524,1,0,0,0,3524,513,1,0,0,0,3525,3527,
  	5,171,0,0,3526,3528,3,568,284,0,3527,3526,1,0,0,0,3527,3528,1,0,0,0,3528,
  	3530,1,0,0,0,3529,3531,3,516,258,0,3530,3529,1,0,0,0,3530,3531,1,0,0,
  	0,3531,515,1,0,0,0,3532,3534,5,171,0,0,3533,3535,3,548,274,0,3534,3533,
  	1,0,0,0,3534,3535,1,0,0,0,3535,3537,1,0,0,0,3536,3538,3,518,259,0,3537,
  	3536,1,0,0,0,3537,3538,1,0,0,0,3538,517,1,0,0,0,3539,3541,5,171,0,0,3540,
  	3542,3,556,278,0,3541,3540,1,0,0,0,3541,3542,1,0,0,0,3542,3544,1,0,0,
  	0,3543,3545,3,520,260,0,3544,3543,1,0,0,0,3544,3545,1,0,0,0,3545,519,
  	1,0,0,0,3546,3548,5,171,0,0,3547,3549,3,554,277,0,3548,3547,1,0,0,0,3548,
  	3549,1,0,0,0,3549,521,1,0,0,0,3550,3551,5,24,0,0,3551,3552,5,182,0,0,
  	3552,3553,3,564,282,0,3553,3554,5,171,0,0,3554,3555,3,552,276,0,3555,
  	3556,5,171,0,0,3556,3558,3,574,287,0,3557,3559,3,506,253,0,3558,3557,
  	1,0,0,0,3558,3559,1,0,0,0,3559,3560,1,0,0,0,3560,3561,5,191,0,0,3561,
  	3562,5,192,0,0,3562,523,1,0,0,0,3563,3564,5,26,0,0,3564,3565,5,182,0,
  	0,3565,3566,3,564,282,0,3566,3567,5,171,0,0,3567,3568,3,552,276,0,3568,
  	3569,5,171,0,0,3569,3571,3,574,287,0,3570,3572,3,506,253,0,3571,3570,
  	1,0,0,0,3571,3572,1,0,0,0,3572,3573,1,0,0,0,3573,3574,5,191,0,0,3574,
  	3575,5,192,0,0,3575,525,1,0,0,0,3576,3577,5,25,0,0,3577,3578,5,182,0,
  	0,3578,3579,3,564,282,0,3579,3580,5,171,0,0,3580,3581,3,552,276,0,3581,
  	3582,5,171,0,0,3582,3583,3,574,287,0,3583,3584,5,171,0,0,3584,3586,3,
  	574,287,0,3585,3587,3,512,256,0,3586,3585,1,0,0,0,3586,3587,1,0,0,0,3587,
  	3588,1,0,0,0,3588,3589,5,191,0,0,3589,3590,5,192,0,0,3590,527,1,0,0,0,
  	3591,3592,5,29,0,0,3592,3593,5,182,0,0,3593,3594,3,564,282,0,3594,3595,
  	5,171,0,0,3595,3596,3,552,276,0,3596,3597,5,171,0,0,3597,3599,3,574,287,
  	0,3598,3600,3,506,253,0,3599,3598,1,0,0,0,3599,3600,1,0,0,0,3600,3601,
  	1,0,0,0,3601,3602,5,191,0,0,3602,3603,5,192,0,0,3603,529,1,0,0,0,3604,
  	3605,5,30,0,0,3605,3606,5,182,0,0,3606,3607,3,564,282,0,3607,3608,5,171,
  	0,0,3608,3609,3,552,276,0,3609,3610,5,171,0,0,3610,3612,3,574,287,0,3611,
  	3613,3,532,266,0,3612,3611,1,0,0,0,3612,3613,1,0,0,0,3613,3614,1,0,0,
  	0,3614,3615,5,191,0,0,3615,3616,5,192,0,0,3616,531,1,0,0,0,3617,3619,
  	5,171,0,0,3618,3620,3,562,281,0,3619,3618,1,0,0,0,3619,3620,1,0,0,0,3620,
  	3622,1,0,0,0,3621,3623,3,534,267,0,3622,3621,1,0,0,0,3622,3623,1,0,0,
  	0,3623,533,1,0,0,0,3624,3626,5,171,0,0,3625,3627,3,560,280,0,3626,3625,
  	1,0,0,0,3626,3627,1,0,0,0,3627,3629,1,0,0,0,3628,3630,3,536,268,0,3629,
  	3628,1,0,0,0,3629,3630,1,0,0,0,3630,535,1,0,0,0,3631,3633,5,171,0,0,3632,
  	3634,3,566,283,0,3633,3632,1,0,0,0,3633,3634,1,0,0,0,3634,537,1,0,0,0,
  	3635,3636,5,20,0,0,3636,3637,5,182,0,0,3637,3638,3,564,282,0,3638,3639,
  	5,171,0,0,3639,3640,3,552,276,0,3640,3641,5,171,0,0,3641,3642,3,574,287,
  	0,3642,3643,5,171,0,0,3643,3645,3,574,287,0,3644,3646,3,532,266,0,3645,
  	3644,1,0,0,0,3645,3646,1,0,0,0,3646,3647,1,0,0,0,3647,3648,5,191,0,0,
  	3648,3649,5,192,0,0,3649,539,1,0,0,0,3650,3651,5,23,0,0,3651,3652,5,182,
  	0,0,3652,3653,3,550,275,0,3653,3654,5,171,0,0,3654,3656,3,574,287,0,3655,
  	3657,3,506,253,0,3656,3655,1,0,0,0,3656,3657,1,0,0,0,3657,3658,1,0,0,
  	0,3658,3659,5,191,0,0,3659,3660,5,192,0,0,3660,541,1,0,0,0,3661,3662,
  	5,31,0,0,3662,3663,5,182,0,0,3663,3664,3,550,275,0,3664,3665,5,171,0,
  	0,3665,3667,3,574,287,0,3666,3668,3,544,272,0,3667,3666,1,0,0,0,3667,
  	3668,1,0,0,0,3668,3669,1,0,0,0,3669,3670,5,191,0,0,3670,3671,5,192,0,
  	0,3671,543,1,0,0,0,3672,3673,5,171,0,0,3673,3676,3,572,286,0,3674,3675,
  	5,171,0,0,3675,3677,3,562,281,0,3676,3674,1,0,0,0,3676,3677,1,0,0,0,3677,
  	545,1,0,0,0,3678,3679,5,22,0,0,3679,3680,5,182,0,0,3680,3681,3,564,282,
  	0,3681,3682,5,171,0,0,3682,3683,3,552,276,0,3683,3684,5,171,0,0,3684,
  	3685,3,570,285,0,3685,3686,5,171,0,0,3686,3688,3,558,279,0,3687,3689,
  	3,506,253,0,3688,3687,1,0,0,0,3688,3689,1,0,0,0,3689,3690,1,0,0,0,3690,
  	3691,5,191,0,0,3691,3692,5,192,0,0,3692,547,1,0,0,0,3693,3694,3,632,316,
  	0,3694,549,1,0,0,0,3695,3696,3,578,289,0,3696,551,1,0,0,0,3697,3698,3,
  	576,288,0,3698,553,1,0,0,0,3699,3704,3,764,382,0,3700,3701,5,180,0,0,
  	3701,3702,3,622,311,0,3702,3703,5,189,0,0,3703,3705,1,0,0,0,3704,3700,
  	1,0,0,0,3704,3705,1,0,0,0,3705,555,1,0,0,0,3706,3711,3,764,382,0,3707,
  	3708,5,180,0,0,3708,3709,3,622,311,0,3709,3710,5,189,0,0,3710,3712,1,
  	0,0,0,3711,3707,1,0,0,0,3711,3712,1,0,0,0,3712,557,1,0,0,0,3713,3714,
  	3,632,316,0,3714,559,1,0,0,0,3715,3716,3,620,310,0,3716,561,1,0,0,0,3717,
  	3718,3,772,386,0,3718,563,1,0,0,0,3719,3720,3,576,288,0,3720,565,1,0,
  	0,0,3721,3722,3,620,310,0,3722,567,1,0,0,0,3723,3724,3,632,316,0,3724,
  	569,1,0,0,0,3725,3726,3,632,316,0,3726,571,1,0,0,0,3727,3728,3,620,310,
  	0,3728,573,1,0,0,0,3729,3730,3,628,314,0,3730,575,1,0,0,0,3731,3733,3,
  	580,290,0,3732,3731,1,0,0,0,3732,3733,1,0,0,0,3733,3734,1,0,0,0,3734,
  	3737,3,582,291,0,3735,3736,5,143,0,0,3736,3738,3,588,294,0,3737,3735,
  	1,0,0,0,3737,3738,1,0,0,0,3738,577,1,0,0,0,3739,3740,3,580,290,0,3740,
  	3743,3,582,291,0,3741,3742,5,143,0,0,3742,3744,3,588,294,0,3743,3741,
  	1,0,0,0,3743,3744,1,0,0,0,3744,579,1,0,0,0,3745,3749,5,84,0,0,3746,3749,
  	5,72,0,0,3747,3749,3,584,292,0,3748,3745,1,0,0,0,3748,3746,1,0,0,0,3748,
  	3747,1,0,0,0,3749,581,1,0,0,0,3750,3753,3,442,221,0,3751,3753,3,444,222,
  	0,3752,3750,1,0,0,0,3752,3751,1,0,0,0,3753,583,1,0,0,0,3754,3755,5,32,
  	0,0,3755,3756,5,180,0,0,3756,3761,3,586,293,0,3757,3758,5,171,0,0,3758,
  	3760,3,586,293,0,3759,3757,1,0,0,0,3760,3763,1,0,0,0,3761,3759,1,0,0,
  	0,3761,3762,1,0,0,0,3762,3764,1,0,0,0,3763,3761,1,0,0,0,3764,3765,5,189,
  	0,0,3765,585,1,0,0,0,3766,3767,5,212,0,0,3767,587,1,0,0,0,3768,3774,3,
  	590,295,0,3769,3770,5,182,0,0,3770,3771,3,590,295,0,3771,3772,5,191,0,
  	0,3772,3774,1,0,0,0,3773,3768,1,0,0,0,3773,3769,1,0,0,0,3774,589,1,0,
  	0,0,3775,3795,3,628,314,0,3776,3777,5,194,0,0,3777,3795,3,628,314,0,3778,
  	3779,3,628,314,0,3779,3780,5,154,0,0,3780,3781,3,592,296,0,3781,3795,
  	1,0,0,0,3782,3783,3,628,314,0,3783,3784,5,145,0,0,3784,3785,3,592,296,
  	0,3785,3795,1,0,0,0,3786,3787,3,628,314,0,3787,3788,5,157,0,0,3788,3789,
  	3,592,296,0,3789,3795,1,0,0,0,3790,3791,3,628,314,0,3791,3792,5,144,0,
  	0,3792,3793,3,592,296,0,3793,3795,1,0,0,0,3794,3775,1,0,0,0,3794,3776,
  	1,0,0,0,3794,3778,1,0,0,0,3794,3782,1,0,0,0,3794,3786,1,0,0,0,3794,3790,
  	1,0,0,0,3795,591,1,0,0,0,3796,3799,3,672,336,0,3797,3799,3,684,342,0,
  	3798,3796,1,0,0,0,3798,3797,1,0,0,0,3799,593,1,0,0,0,3800,3801,5,181,
  	0,0,3801,3806,3,628,314,0,3802,3803,5,171,0,0,3803,3805,3,628,314,0,3804,
  	3802,1,0,0,0,3805,3808,1,0,0,0,3806,3804,1,0,0,0,3806,3807,1,0,0,0,3807,
  	3809,1,0,0,0,3808,3806,1,0,0,0,3809,3810,5,190,0,0,3810,595,1,0,0,0,3811,
  	3812,5,181,0,0,3812,3817,3,620,310,0,3813,3814,5,171,0,0,3814,3816,3,
  	620,310,0,3815,3813,1,0,0,0,3816,3819,1,0,0,0,3817,3815,1,0,0,0,3817,
  	3818,1,0,0,0,3818,3820,1,0,0,0,3819,3817,1,0,0,0,3820,3821,5,190,0,0,
  	3821,597,1,0,0,0,3822,3823,5,181,0,0,3823,3824,3,620,310,0,3824,3825,
  	3,596,298,0,3825,3826,5,190,0,0,3826,599,1,0,0,0,3827,3828,5,181,0,0,
  	3828,3833,3,634,317,0,3829,3830,5,171,0,0,3830,3832,3,634,317,0,3831,
  	3829,1,0,0,0,3832,3835,1,0,0,0,3833,3831,1,0,0,0,3833,3834,1,0,0,0,3834,
  	3836,1,0,0,0,3835,3833,1,0,0,0,3836,3837,5,190,0,0,3837,601,1,0,0,0,3838,
  	3839,5,181,0,0,3839,3840,3,620,310,0,3840,3841,3,600,300,0,3841,3842,
  	5,190,0,0,3842,603,1,0,0,0,3843,3844,5,181,0,0,3844,3845,3,620,310,0,
  	3845,3846,3,594,297,0,3846,3847,5,190,0,0,3847,605,1,0,0,0,3848,3852,
  	3,720,360,0,3849,3851,3,704,352,0,3850,3849,1,0,0,0,3851,3854,1,0,0,0,
  	3852,3850,1,0,0,0,3852,3853,1,0,0,0,3853,3855,1,0,0,0,3854,3852,1,0,0,
  	0,3855,3856,5,182,0,0,3856,3861,3,620,310,0,3857,3858,5,171,0,0,3858,
  	3860,3,620,310,0,3859,3857,1,0,0,0,3860,3863,1,0,0,0,3861,3859,1,0,0,
  	0,3861,3862,1,0,0,0,3862,3864,1,0,0,0,3863,3861,1,0,0,0,3864,3865,5,191,
  	0,0,3865,607,1,0,0,0,3866,3867,3,758,379,0,3867,3868,5,182,0,0,3868,3873,
  	3,620,310,0,3869,3870,5,171,0,0,3870,3872,3,620,310,0,3871,3869,1,0,0,
  	0,3872,3875,1,0,0,0,3873,3871,1,0,0,0,3873,3874,1,0,0,0,3874,3876,1,0,
  	0,0,3875,3873,1,0,0,0,3876,3877,5,191,0,0,3877,609,1,0,0,0,3878,3882,
  	3,728,364,0,3879,3881,3,704,352,0,3880,3879,1,0,0,0,3881,3884,1,0,0,0,
  	3882,3880,1,0,0,0,3882,3883,1,0,0,0,3883,3885,1,0,0,0,3884,3882,1,0,0,
  	0,3885,3886,5,182,0,0,3886,3891,3,628,314,0,3887,3888,5,171,0,0,3888,
  	3890,3,628,314,0,3889,3887,1,0,0,0,3890,3893,1,0,0,0,3891,3889,1,0,0,
  	0,3891,3892,1,0,0,0,3892,3894,1,0,0,0,3893,3891,1,0,0,0,3894,3895,5,191,
  	0,0,3895,611,1,0,0,0,3896,3898,3,758,379,0,3897,3899,3,614,307,0,3898,
  	3897,1,0,0,0,3898,3899,1,0,0,0,3899,613,1,0,0,0,3900,3901,5,182,0,0,3901,
  	3906,3,628,314,0,3902,3903,5,171,0,0,3903,3905,3,628,314,0,3904,3902,
  	1,0,0,0,3905,3908,1,0,0,0,3906,3904,1,0,0,0,3906,3907,1,0,0,0,3907,3909,
  	1,0,0,0,3908,3906,1,0,0,0,3909,3910,5,191,0,0,3910,615,1,0,0,0,3911,3912,
  	3,628,314,0,3912,617,1,0,0,0,3913,3914,3,620,310,0,3914,619,1,0,0,0,3915,
  	3916,6,310,-1,0,3916,3927,3,644,322,0,3917,3921,3,662,331,0,3918,3920,
  	3,704,352,0,3919,3918,1,0,0,0,3920,3923,1,0,0,0,3921,3919,1,0,0,0,3921,
  	3922,1,0,0,0,3922,3924,1,0,0,0,3923,3921,1,0,0,0,3924,3925,3,644,322,
  	0,3925,3927,1,0,0,0,3926,3915,1,0,0,0,3926,3917,1,0,0,0,3927,4041,1,0,
  	0,0,3928,3929,10,12,0,0,3929,3933,5,155,0,0,3930,3932,3,704,352,0,3931,
  	3930,1,0,0,0,3932,3935,1,0,0,0,3933,3931,1,0,0,0,3933,3934,1,0,0,0,3934,
  	3936,1,0,0,0,3935,3933,1,0,0,0,3936,4040,3,620,310,13,3937,3938,10,11,
  	0,0,3938,3942,7,17,0,0,3939,3941,3,704,352,0,3940,3939,1,0,0,0,3941,3944,
  	1,0,0,0,3942,3940,1,0,0,0,3942,3943,1,0,0,0,3943,3945,1,0,0,0,3944,3942,
  	1,0,0,0,3945,4040,3,620,310,12,3946,3947,10,10,0,0,3947,3951,7,16,0,0,
  	3948,3950,3,704,352,0,3949,3948,1,0,0,0,3950,3953,1,0,0,0,3951,3949,1,
  	0,0,0,3951,3952,1,0,0,0,3952,3954,1,0,0,0,3953,3951,1,0,0,0,3954,4040,
  	3,620,310,11,3955,3956,10,9,0,0,3956,3960,7,18,0,0,3957,3959,3,704,352,
  	0,3958,3957,1,0,0,0,3959,3962,1,0,0,0,3960,3958,1,0,0,0,3960,3961,1,0,
  	0,0,3961,3963,1,0,0,0,3962,3960,1,0,0,0,3963,4040,3,620,310,10,3964,3965,
  	10,8,0,0,3965,3969,7,19,0,0,3966,3968,3,704,352,0,3967,3966,1,0,0,0,3968,
  	3971,1,0,0,0,3969,3967,1,0,0,0,3969,3970,1,0,0,0,3970,3972,1,0,0,0,3971,
  	3969,1,0,0,0,3972,4040,3,620,310,9,3973,3974,10,7,0,0,3974,3978,7,20,
  	0,0,3975,3977,3,704,352,0,3976,3975,1,0,0,0,3977,3980,1,0,0,0,3978,3976,
  	1,0,0,0,3978,3979,1,0,0,0,3979,3981,1,0,0,0,3980,3978,1,0,0,0,3981,4040,
  	3,620,310,8,3982,3983,10,6,0,0,3983,3987,5,166,0,0,3984,3986,3,704,352,
  	0,3985,3984,1,0,0,0,3986,3989,1,0,0,0,3987,3985,1,0,0,0,3987,3988,1,0,
  	0,0,3988,3990,1,0,0,0,3989,3987,1,0,0,0,3990,4040,3,620,310,7,3991,3992,
  	10,5,0,0,3992,3996,7,21,0,0,3993,3995,3,704,352,0,3994,3993,1,0,0,0,3995,
  	3998,1,0,0,0,3996,3994,1,0,0,0,3996,3997,1,0,0,0,3997,3999,1,0,0,0,3998,
  	3996,1,0,0,0,3999,4040,3,620,310,6,4000,4001,10,4,0,0,4001,4005,5,165,
  	0,0,4002,4004,3,704,352,0,4003,4002,1,0,0,0,4004,4007,1,0,0,0,4005,4003,
  	1,0,0,0,4005,4006,1,0,0,0,4006,4008,1,0,0,0,4007,4005,1,0,0,0,4008,4040,
  	3,620,310,5,4009,4010,10,3,0,0,4010,4014,5,152,0,0,4011,4013,3,704,352,
  	0,4012,4011,1,0,0,0,4013,4016,1,0,0,0,4014,4012,1,0,0,0,4014,4015,1,0,
  	0,0,4015,4017,1,0,0,0,4016,4014,1,0,0,0,4017,4040,3,620,310,4,4018,4019,
  	10,2,0,0,4019,4023,5,164,0,0,4020,4022,3,704,352,0,4021,4020,1,0,0,0,
  	4022,4025,1,0,0,0,4023,4021,1,0,0,0,4023,4024,1,0,0,0,4024,4026,1,0,0,
  	0,4025,4023,1,0,0,0,4026,4040,3,620,310,3,4027,4028,10,1,0,0,4028,4032,
  	5,188,0,0,4029,4031,3,704,352,0,4030,4029,1,0,0,0,4031,4034,1,0,0,0,4032,
  	4030,1,0,0,0,4032,4033,1,0,0,0,4033,4035,1,0,0,0,4034,4032,1,0,0,0,4035,
  	4036,3,620,310,0,4036,4037,5,170,0,0,4037,4038,3,620,310,1,4038,4040,
  	1,0,0,0,4039,3928,1,0,0,0,4039,3937,1,0,0,0,4039,3946,1,0,0,0,4039,3955,
  	1,0,0,0,4039,3964,1,0,0,0,4039,3973,1,0,0,0,4039,3982,1,0,0,0,4039,3991,
  	1,0,0,0,4039,4000,1,0,0,0,4039,4009,1,0,0,0,4039,4018,1,0,0,0,4039,4027,
  	1,0,0,0,4040,4043,1,0,0,0,4041,4039,1,0,0,0,4041,4042,1,0,0,0,4042,621,
  	1,0,0,0,4043,4041,1,0,0,0,4044,4050,3,620,310,0,4045,4046,5,170,0,0,4046,
  	4047,3,620,310,0,4047,4048,5,170,0,0,4048,4049,3,620,310,0,4049,4051,
  	1,0,0,0,4050,4045,1,0,0,0,4050,4051,1,0,0,0,4051,623,1,0,0,0,4052,4066,
  	3,620,310,0,4053,4054,3,638,319,0,4054,4055,5,170,0,0,4055,4056,3,630,
  	315,0,4056,4066,1,0,0,0,4057,4058,3,618,309,0,4058,4059,5,187,0,0,4059,
  	4060,3,642,321,0,4060,4066,1,0,0,0,4061,4062,3,618,309,0,4062,4063,5,
  	148,0,0,4063,4064,3,642,321,0,4064,4066,1,0,0,0,4065,4052,1,0,0,0,4065,
  	4053,1,0,0,0,4065,4057,1,0,0,0,4065,4061,1,0,0,0,4066,625,1,0,0,0,4067,
  	4068,3,620,310,0,4068,627,1,0,0,0,4069,4070,6,314,-1,0,4070,4081,3,648,
  	324,0,4071,4075,3,662,331,0,4072,4074,3,704,352,0,4073,4072,1,0,0,0,4074,
  	4077,1,0,0,0,4075,4073,1,0,0,0,4075,4076,1,0,0,0,4076,4078,1,0,0,0,4077,
  	4075,1,0,0,0,4078,4079,3,648,324,0,4079,4081,1,0,0,0,4080,4069,1,0,0,
  	0,4080,4071,1,0,0,0,4081,4195,1,0,0,0,4082,4083,10,12,0,0,4083,4087,5,
  	155,0,0,4084,4086,3,704,352,0,4085,4084,1,0,0,0,4086,4089,1,0,0,0,4087,
  	4085,1,0,0,0,4087,4088,1,0,0,0,4088,4090,1,0,0,0,4089,4087,1,0,0,0,4090,
  	4194,3,628,314,13,4091,4092,10,11,0,0,4092,4096,7,17,0,0,4093,4095,3,
  	704,352,0,4094,4093,1,0,0,0,4095,4098,1,0,0,0,4096,4094,1,0,0,0,4096,
  	4097,1,0,0,0,4097,4099,1,0,0,0,4098,4096,1,0,0,0,4099,4194,3,628,314,
  	12,4100,4101,10,10,0,0,4101,4105,7,16,0,0,4102,4104,3,704,352,0,4103,
  	4102,1,0,0,0,4104,4107,1,0,0,0,4105,4103,1,0,0,0,4105,4106,1,0,0,0,4106,
  	4108,1,0,0,0,4107,4105,1,0,0,0,4108,4194,3,628,314,11,4109,4110,10,9,
  	0,0,4110,4114,7,18,0,0,4111,4113,3,704,352,0,4112,4111,1,0,0,0,4113,4116,
  	1,0,0,0,4114,4112,1,0,0,0,4114,4115,1,0,0,0,4115,4117,1,0,0,0,4116,4114,
  	1,0,0,0,4117,4194,3,628,314,10,4118,4119,10,8,0,0,4119,4123,7,19,0,0,
  	4120,4122,3,704,352,0,4121,4120,1,0,0,0,4122,4125,1,0,0,0,4123,4121,1,
  	0,0,0,4123,4124,1,0,0,0,4124,4126,1,0,0,0,4125,4123,1,0,0,0,4126,4194,
  	3,628,314,9,4127,4128,10,7,0,0,4128,4132,7,20,0,0,4129,4131,3,704,352,
  	0,4130,4129,1,0,0,0,4131,4134,1,0,0,0,4132,4130,1,0,0,0,4132,4133,1,0,
  	0,0,4133,4135,1,0,0,0,4134,4132,1,0,0,0,4135,4194,3,628,314,8,4136,4137,
  	10,6,0,0,4137,4141,5,166,0,0,4138,4140,3,704,352,0,4139,4138,1,0,0,0,
  	4140,4143,1,0,0,0,4141,4139,1,0,0,0,4141,4142,1,0,0,0,4142,4144,1,0,0,
  	0,4143,4141,1,0,0,0,4144,4194,3,628,314,7,4145,4146,10,5,0,0,4146,4150,
  	7,21,0,0,4147,4149,3,704,352,0,4148,4147,1,0,0,0,4149,4152,1,0,0,0,4150,
  	4148,1,0,0,0,4150,4151,1,0,0,0,4151,4153,1,0,0,0,4152,4150,1,0,0,0,4153,
  	4194,3,628,314,6,4154,4155,10,4,0,0,4155,4159,5,165,0,0,4156,4158,3,704,
  	352,0,4157,4156,1,0,0,0,4158,4161,1,0,0,0,4159,4157,1,0,0,0,4159,4160,
  	1,0,0,0,4160,4162,1,0,0,0,4161,4159,1,0,0,0,4162,4194,3,628,314,5,4163,
  	4164,10,3,0,0,4164,4168,5,152,0,0,4165,4167,3,704,352,0,4166,4165,1,0,
  	0,0,4167,4170,1,0,0,0,4168,4166,1,0,0,0,4168,4169,1,0,0,0,4169,4171,1,
  	0,0,0,4170,4168,1,0,0,0,4171,4194,3,628,314,4,4172,4173,10,2,0,0,4173,
  	4177,5,164,0,0,4174,4176,3,704,352,0,4175,4174,1,0,0,0,4176,4179,1,0,
  	0,0,4177,4175,1,0,0,0,4177,4178,1,0,0,0,4178,4180,1,0,0,0,4179,4177,1,
  	0,0,0,4180,4194,3,628,314,3,4181,4182,10,1,0,0,4182,4186,5,188,0,0,4183,
  	4185,3,704,352,0,4184,4183,1,0,0,0,4185,4188,1,0,0,0,4186,4184,1,0,0,
  	0,4186,4187,1,0,0,0,4187,4189,1,0,0,0,4188,4186,1,0,0,0,4189,4190,3,628,
  	314,0,4190,4191,5,170,0,0,4191,4192,3,628,314,1,4192,4194,1,0,0,0,4193,
  	4082,1,0,0,0,4193,4091,1,0,0,0,4193,4100,1,0,0,0,4193,4109,1,0,0,0,4193,
  	4118,1,0,0,0,4193,4127,1,0,0,0,4193,4136,1,0,0,0,4193,4145,1,0,0,0,4193,
  	4154,1,0,0,0,4193,4163,1,0,0,0,4193,4172,1,0,0,0,4193,4181,1,0,0,0,4194,
  	4197,1,0,0,0,4195,4193,1,0,0,0,4195,4196,1,0,0,0,4196,629,1,0,0,0,4197,
  	4195,1,0,0,0,4198,4199,3,620,310,0,4199,631,1,0,0,0,4200,4206,3,628,314,
  	0,4201,4202,5,170,0,0,4202,4203,3,628,314,0,4203,4204,5,170,0,0,4204,
  	4205,3,628,314,0,4205,4207,1,0,0,0,4206,4201,1,0,0,0,4206,4207,1,0,0,
  	0,4207,633,1,0,0,0,4208,4209,6,317,-1,0,4209,4220,3,646,323,0,4210,4214,
  	3,664,332,0,4211,4213,3,704,352,0,4212,4211,1,0,0,0,4213,4216,1,0,0,0,
  	4214,4212,1,0,0,0,4214,4215,1,0,0,0,4215,4217,1,0,0,0,4216,4214,1,0,0,
  	0,4217,4218,3,646,323,0,4218,4220,1,0,0,0,4219,4208,1,0,0,0,4219,4210,
  	1,0,0,0,4220,4289,1,0,0,0,4221,4222,10,7,0,0,4222,4226,7,22,0,0,4223,
  	4225,3,704,352,0,4224,4223,1,0,0,0,4225,4228,1,0,0,0,4226,4224,1,0,0,
  	0,4226,4227,1,0,0,0,4227,4229,1,0,0,0,4228,4226,1,0,0,0,4229,4288,3,634,
  	317,8,4230,4231,10,6,0,0,4231,4235,5,166,0,0,4232,4234,3,704,352,0,4233,
  	4232,1,0,0,0,4234,4237,1,0,0,0,4235,4233,1,0,0,0,4235,4236,1,0,0,0,4236,
  	4238,1,0,0,0,4237,4235,1,0,0,0,4238,4288,3,634,317,7,4239,4240,10,5,0,
  	0,4240,4244,7,21,0,0,4241,4243,3,704,352,0,4242,4241,1,0,0,0,4243,4246,
  	1,0,0,0,4244,4242,1,0,0,0,4244,4245,1,0,0,0,4245,4247,1,0,0,0,4246,4244,
  	1,0,0,0,4247,4288,3,634,317,6,4248,4249,10,4,0,0,4249,4253,5,165,0,0,
  	4250,4252,3,704,352,0,4251,4250,1,0,0,0,4252,4255,1,0,0,0,4253,4251,1,
  	0,0,0,4253,4254,1,0,0,0,4254,4256,1,0,0,0,4255,4253,1,0,0,0,4256,4288,
  	3,634,317,5,4257,4258,10,3,0,0,4258,4262,5,152,0,0,4259,4261,3,704,352,
  	0,4260,4259,1,0,0,0,4261,4264,1,0,0,0,4262,4260,1,0,0,0,4262,4263,1,0,
  	0,0,4263,4265,1,0,0,0,4264,4262,1,0,0,0,4265,4288,3,634,317,4,4266,4267,
  	10,2,0,0,4267,4271,5,164,0,0,4268,4270,3,704,352,0,4269,4268,1,0,0,0,
  	4270,4273,1,0,0,0,4271,4269,1,0,0,0,4271,4272,1,0,0,0,4272,4274,1,0,0,
  	0,4273,4271,1,0,0,0,4274,4288,3,634,317,3,4275,4276,10,1,0,0,4276,4280,
  	5,188,0,0,4277,4279,3,704,352,0,4278,4277,1,0,0,0,4279,4282,1,0,0,0,4280,
  	4278,1,0,0,0,4280,4281,1,0,0,0,4281,4283,1,0,0,0,4282,4280,1,0,0,0,4283,
  	4284,3,634,317,0,4284,4285,5,170,0,0,4285,4286,3,634,317,1,4286,4288,
  	1,0,0,0,4287,4221,1,0,0,0,4287,4230,1,0,0,0,4287,4239,1,0,0,0,4287,4248,
  	1,0,0,0,4287,4257,1,0,0,0,4287,4266,1,0,0,0,4287,4275,1,0,0,0,4288,4291,
  	1,0,0,0,4289,4287,1,0,0,0,4289,4290,1,0,0,0,4290,635,1,0,0,0,4291,4289,
  	1,0,0,0,4292,4298,3,634,317,0,4293,4294,5,170,0,0,4294,4295,3,634,317,
  	0,4295,4296,5,170,0,0,4296,4297,3,634,317,0,4297,4299,1,0,0,0,4298,4293,
  	1,0,0,0,4298,4299,1,0,0,0,4299,637,1,0,0,0,4300,4301,3,620,310,0,4301,
  	639,1,0,0,0,4302,4316,3,628,314,0,4303,4304,3,638,319,0,4304,4305,5,170,
  	0,0,4305,4306,3,630,315,0,4306,4316,1,0,0,0,4307,4308,3,616,308,0,4308,
  	4309,5,187,0,0,4309,4310,3,642,321,0,4310,4316,1,0,0,0,4311,4312,3,616,
  	308,0,4312,4313,5,148,0,0,4313,4314,3,642,321,0,4314,4316,1,0,0,0,4315,
  	4302,1,0,0,0,4315,4303,1,0,0,0,4315,4307,1,0,0,0,4315,4311,1,0,0,0,4316,
  	641,1,0,0,0,4317,4318,3,620,310,0,4318,643,1,0,0,0,4319,4337,3,666,333,
  	0,4320,4325,3,732,366,0,4321,4322,5,180,0,0,4322,4323,3,624,312,0,4323,
  	4324,5,189,0,0,4324,4326,1,0,0,0,4325,4321,1,0,0,0,4325,4326,1,0,0,0,
  	4326,4337,1,0,0,0,4327,4337,3,596,298,0,4328,4337,3,598,299,0,4329,4337,
  	3,606,303,0,4330,4337,3,608,304,0,4331,4332,5,182,0,0,4332,4333,3,622,
  	311,0,4333,4334,5,191,0,0,4334,4337,1,0,0,0,4335,4337,3,702,351,0,4336,
  	4319,1,0,0,0,4336,4320,1,0,0,0,4336,4327,1,0,0,0,4336,4328,1,0,0,0,4336,
  	4329,1,0,0,0,4336,4330,1,0,0,0,4336,4331,1,0,0,0,4336,4335,1,0,0,0,4337,
  	645,1,0,0,0,4338,4349,3,666,333,0,4339,4349,3,732,366,0,4340,4349,3,600,
  	300,0,4341,4349,3,602,301,0,4342,4349,3,610,305,0,4343,4349,3,612,306,
  	0,4344,4345,5,182,0,0,4345,4346,3,636,318,0,4346,4347,5,191,0,0,4347,
  	4349,1,0,0,0,4348,4338,1,0,0,0,4348,4339,1,0,0,0,4348,4340,1,0,0,0,4348,
  	4341,1,0,0,0,4348,4342,1,0,0,0,4348,4343,1,0,0,0,4348,4344,1,0,0,0,4349,
  	647,1,0,0,0,4350,4365,3,666,333,0,4351,4353,3,728,364,0,4352,4354,3,650,
  	325,0,4353,4352,1,0,0,0,4353,4354,1,0,0,0,4354,4365,1,0,0,0,4355,4365,
  	3,594,297,0,4356,4365,3,604,302,0,4357,4365,3,610,305,0,4358,4365,3,612,
  	306,0,4359,4360,5,182,0,0,4360,4361,3,632,316,0,4361,4362,5,191,0,0,4362,
  	4365,1,0,0,0,4363,4365,3,702,351,0,4364,4350,1,0,0,0,4364,4351,1,0,0,
  	0,4364,4355,1,0,0,0,4364,4356,1,0,0,0,4364,4357,1,0,0,0,4364,4358,1,0,
  	0,0,4364,4359,1,0,0,0,4364,4363,1,0,0,0,4365,649,1,0,0,0,4366,4368,3,
  	652,326,0,4367,4366,1,0,0,0,4367,4368,1,0,0,0,4368,4369,1,0,0,0,4369,
  	4370,5,180,0,0,4370,4371,3,640,320,0,4371,4372,5,189,0,0,4372,651,1,0,
  	0,0,4373,4374,5,180,0,0,4374,4375,3,628,314,0,4375,4376,5,189,0,0,4376,
  	4378,1,0,0,0,4377,4373,1,0,0,0,4378,4379,1,0,0,0,4379,4377,1,0,0,0,4379,
  	4380,1,0,0,0,4380,653,1,0,0,0,4381,4383,3,728,364,0,4382,4384,3,656,328,
  	0,4383,4382,1,0,0,0,4383,4384,1,0,0,0,4384,4397,1,0,0,0,4385,4386,5,181,
  	0,0,4386,4391,3,654,327,0,4387,4388,5,171,0,0,4388,4390,3,654,327,0,4389,
  	4387,1,0,0,0,4390,4393,1,0,0,0,4391,4389,1,0,0,0,4391,4392,1,0,0,0,4392,
  	4394,1,0,0,0,4393,4391,1,0,0,0,4394,4395,5,190,0,0,4395,4397,1,0,0,0,
  	4396,4381,1,0,0,0,4396,4385,1,0,0,0,4397,655,1,0,0,0,4398,4400,3,658,
  	329,0,4399,4398,1,0,0,0,4399,4400,1,0,0,0,4400,4401,1,0,0,0,4401,4402,
  	5,180,0,0,4402,4403,3,624,312,0,4403,4404,5,189,0,0,4404,657,1,0,0,0,
  	4405,4406,5,180,0,0,4406,4407,3,620,310,0,4407,4408,5,189,0,0,4408,4410,
  	1,0,0,0,4409,4405,1,0,0,0,4410,4411,1,0,0,0,4411,4409,1,0,0,0,4411,4412,
  	1,0,0,0,4412,659,1,0,0,0,4413,4415,3,728,364,0,4414,4416,3,650,325,0,
  	4415,4414,1,0,0,0,4415,4416,1,0,0,0,4416,4429,1,0,0,0,4417,4418,5,181,
  	0,0,4418,4423,3,660,330,0,4419,4420,5,171,0,0,4420,4422,3,660,330,0,4421,
  	4419,1,0,0,0,4422,4425,1,0,0,0,4423,4421,1,0,0,0,4423,4424,1,0,0,0,4424,
  	4426,1,0,0,0,4425,4423,1,0,0,0,4426,4427,5,190,0,0,4427,4429,1,0,0,0,
  	4428,4413,1,0,0,0,4428,4417,1,0,0,0,4429,661,1,0,0,0,4430,4431,7,23,0,
  	0,4431,663,1,0,0,0,4432,4433,7,24,0,0,4433,665,1,0,0,0,4434,4440,3,670,
  	335,0,4435,4440,3,674,337,0,4436,4440,3,672,336,0,4437,4440,3,676,338,
  	0,4438,4440,3,668,334,0,4439,4434,1,0,0,0,4439,4435,1,0,0,0,4439,4436,
  	1,0,0,0,4439,4437,1,0,0,0,4439,4438,1,0,0,0,4440,667,1,0,0,0,4441,4443,
  	3,680,340,0,4442,4444,5,200,0,0,4443,4442,1,0,0,0,4443,4444,1,0,0,0,4444,
  	4450,1,0,0,0,4445,4447,3,682,341,0,4446,4448,5,200,0,0,4447,4446,1,0,
  	0,0,4447,4448,1,0,0,0,4448,4450,1,0,0,0,4449,4441,1,0,0,0,4449,4445,1,
  	0,0,0,4450,669,1,0,0,0,4451,4459,3,684,342,0,4452,4454,3,678,339,0,4453,
  	4452,1,0,0,0,4453,4454,1,0,0,0,4454,4455,1,0,0,0,4455,4456,3,694,347,
  	0,4456,4457,3,686,343,0,4457,4459,1,0,0,0,4458,4451,1,0,0,0,4458,4453,
  	1,0,0,0,4459,671,1,0,0,0,4460,4462,3,678,339,0,4461,4460,1,0,0,0,4461,
  	4462,1,0,0,0,4462,4463,1,0,0,0,4463,4464,3,696,348,0,4464,4465,3,688,
  	344,0,4465,673,1,0,0,0,4466,4468,3,678,339,0,4467,4466,1,0,0,0,4467,4468,
  	1,0,0,0,4468,4469,1,0,0,0,4469,4470,3,698,349,0,4470,4471,3,690,345,0,
  	4471,675,1,0,0,0,4472,4474,3,678,339,0,4473,4472,1,0,0,0,4473,4474,1,
  	0,0,0,4474,4475,1,0,0,0,4475,4476,3,700,350,0,4476,4477,3,692,346,0,4477,
  	677,1,0,0,0,4478,4479,5,208,0,0,4479,679,1,0,0,0,4480,4481,5,201,0,0,
  	4481,681,1,0,0,0,4482,4483,5,199,0,0,4483,683,1,0,0,0,4484,4485,5,208,
  	0,0,4485,685,1,0,0,0,4486,4487,7,25,0,0,4487,687,1,0,0,0,4488,4489,5,
  	210,0,0,4489,689,1,0,0,0,4490,4491,5,215,0,0,4491,691,1,0,0,0,4492,4493,
  	5,213,0,0,4493,693,1,0,0,0,4494,4495,5,197,0,0,4495,695,1,0,0,0,4496,
  	4497,5,195,0,0,4497,697,1,0,0,0,4498,4499,5,204,0,0,4499,699,1,0,0,0,
  	4500,4501,5,202,0,0,4501,701,1,0,0,0,4502,4503,5,206,0,0,4503,703,1,0,
  	0,0,4504,4505,5,182,0,0,4505,4506,5,167,0,0,4506,4511,3,706,353,0,4507,
  	4508,5,171,0,0,4508,4510,3,706,353,0,4509,4507,1,0,0,0,4510,4513,1,0,
  	0,0,4511,4509,1,0,0,0,4511,4512,1,0,0,0,4512,4514,1,0,0,0,4513,4511,1,
  	0,0,0,4514,4515,5,167,0,0,4515,4516,5,191,0,0,4516,705,1,0,0,0,4517,4520,
  	3,708,354,0,4518,4519,5,176,0,0,4519,4521,3,620,310,0,4520,4518,1,0,0,
  	0,4520,4521,1,0,0,0,4521,707,1,0,0,0,4522,4523,3,732,366,0,4523,709,1,
  	0,0,0,4524,4525,3,732,366,0,4525,711,1,0,0,0,4526,4527,3,732,366,0,4527,
  	713,1,0,0,0,4528,4529,3,732,366,0,4529,715,1,0,0,0,4530,4531,5,198,0,
  	0,4531,717,1,0,0,0,4532,4533,3,732,366,0,4533,719,1,0,0,0,4534,4535,3,
  	732,366,0,4535,721,1,0,0,0,4536,4537,3,732,366,0,4537,723,1,0,0,0,4538,
  	4539,3,732,366,0,4539,725,1,0,0,0,4540,4541,3,732,366,0,4541,727,1,0,
  	0,0,4542,4544,3,730,365,0,4543,4542,1,0,0,0,4544,4547,1,0,0,0,4545,4543,
  	1,0,0,0,4545,4546,1,0,0,0,4546,4548,1,0,0,0,4547,4545,1,0,0,0,4548,4549,
  	3,732,366,0,4549,729,1,0,0,0,4550,4552,3,732,366,0,4551,4553,3,658,329,
  	0,4552,4551,1,0,0,0,4552,4553,1,0,0,0,4553,4554,1,0,0,0,4554,4555,5,174,
  	0,0,4555,731,1,0,0,0,4556,4559,3,716,358,0,4557,4559,3,754,377,0,4558,
  	4556,1,0,0,0,4558,4557,1,0,0,0,4559,733,1,0,0,0,4560,4561,3,732,366,0,
  	4561,735,1,0,0,0,4562,4563,3,732,366,0,4563,737,1,0,0,0,4564,4565,3,732,
  	366,0,4565,739,1,0,0,0,4566,4567,3,732,366,0,4567,741,1,0,0,0,4568,4569,
  	3,732,366,0,4569,743,1,0,0,0,4570,4571,3,732,366,0,4571,745,1,0,0,0,4572,
  	4573,3,732,366,0,4573,747,1,0,0,0,4574,4575,3,732,366,0,4575,749,1,0,
  	0,0,4576,4577,3,732,366,0,4577,751,1,0,0,0,4578,4579,3,732,366,0,4579,
  	753,1,0,0,0,4580,4581,5,205,0,0,4581,755,1,0,0,0,4582,4583,3,732,366,
  	0,4583,757,1,0,0,0,4584,4585,5,207,0,0,4585,759,1,0,0,0,4586,4587,5,207,
  	0,0,4587,761,1,0,0,0,4588,4589,3,732,366,0,4589,763,1,0,0,0,4590,4591,
  	3,732,366,0,4591,765,1,0,0,0,4592,4593,3,732,366,0,4593,767,1,0,0,0,4594,
  	4595,3,732,366,0,4595,769,1,0,0,0,4596,4597,3,732,366,0,4597,771,1,0,
  	0,0,4598,4599,3,732,366,0,4599,773,1,0,0,0,475,777,785,794,798,808,820,
  	830,835,841,844,850,864,875,886,900,903,906,914,925,930,937,942,949,956,
  	960,971,980,985,990,997,1006,1013,1020,1027,1034,1041,1048,1055,1062,
  	1069,1073,1085,1098,1107,1115,1139,1151,1158,1166,1173,1178,1182,1185,
  	1192,1196,1199,1206,1210,1219,1222,1225,1231,1234,1237,1243,1246,1249,
  	1255,1258,1265,1277,1280,1287,1290,1293,1300,1303,1307,1314,1317,1320,
  	1324,1331,1334,1337,1344,1347,1350,1357,1360,1363,1367,1374,1377,1380,
  	1384,1389,1401,1404,1433,1440,1446,1453,1491,1506,1517,1519,1523,1532,
  	1536,1541,1548,1556,1563,1571,1579,1586,1594,1602,1610,1618,1626,1634,
  	1640,1659,1667,1680,1684,1706,1709,1716,1723,1726,1736,1742,1748,1754,
  	1761,1767,1775,1781,1785,1792,1800,1805,1812,1818,1824,1833,1842,1848,
  	1855,1861,1868,1875,1879,1883,1886,1889,1896,1900,1903,1906,1913,1917,
  	1920,1923,1930,1937,1942,1945,1953,1963,1973,1983,1993,2000,2009,2015,
  	2022,2030,2037,2044,2049,2056,2063,2066,2073,2080,2087,2094,2097,2104,
  	2111,2114,2121,2128,2135,2146,2153,2160,2167,2174,2179,2182,2195,2206,
  	2217,2227,2233,2241,2249,2258,2269,2277,2295,2313,2343,2350,2365,2373,
  	2376,2384,2395,2402,2410,2413,2418,2422,2427,2434,2442,2456,2481,2490,
  	2499,2508,2516,2519,2524,2529,2533,2540,2545,2557,2565,2577,2586,2596,
  	2608,2613,2621,2629,2631,2636,2645,2653,2659,2669,2675,2687,2698,2703,
  	2708,2715,2724,2730,2740,2743,2750,2756,2766,2773,2777,2780,2790,2809,
  	2816,2823,2835,2846,2849,2854,2867,2870,2875,2883,2892,2899,2906,2913,
  	2920,2927,2936,2945,2952,2961,2968,2975,2982,2989,2993,2999,3003,3014,
  	3024,3043,3048,3058,3066,3068,3073,3091,3100,3111,3122,3126,3133,3141,
  	3144,3170,3174,3184,3190,3194,3204,3213,3223,3233,3243,3254,3264,3269,
  	3278,3289,3297,3305,3312,3323,3331,3357,3359,3403,3407,3414,3423,3430,
  	3455,3471,3481,3488,3498,3513,3520,3523,3527,3530,3534,3537,3541,3544,
  	3548,3558,3571,3586,3599,3612,3619,3622,3626,3629,3633,3645,3656,3667,
  	3676,3688,3704,3711,3732,3737,3743,3748,3752,3761,3773,3794,3798,3806,
  	3817,3833,3852,3861,3873,3882,3891,3898,3906,3921,3926,3933,3942,3951,
  	3960,3969,3978,3987,3996,4005,4014,4023,4032,4039,4041,4050,4065,4075,
  	4080,4087,4096,4105,4114,4123,4132,4141,4150,4159,4168,4177,4186,4193,
  	4195,4206,4214,4219,4226,4235,4244,4253,4262,4271,4280,4287,4289,4298,
  	4315,4325,4336,4348,4353,4364,4367,4379,4383,4391,4396,4399,4411,4415,
  	4423,4428,4439,4443,4447,4449,4453,4458,4461,4467,4473,4511,4520,4545,
  	4552,4558
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  verilogparserParserStaticData = std::move(staticData);
}

}

VerilogParser::VerilogParser(TokenStream *input) : VerilogParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

VerilogParser::VerilogParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  VerilogParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *verilogparserParserStaticData->atn, verilogparserParserStaticData->decisionToDFA, verilogparserParserStaticData->sharedContextCache, options);
}

VerilogParser::~VerilogParser() {
  delete _interpreter;
}

const atn::ATN& VerilogParser::getATN() const {
  return *verilogparserParserStaticData->atn;
}

std::string VerilogParser::getGrammarFileName() const {
  return "VerilogParser.g4";
}

const std::vector<std::string>& VerilogParser::getRuleNames() const {
  return verilogparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& VerilogParser::getVocabulary() const {
  return verilogparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView VerilogParser::getSerializedATN() const {
  return verilogparserParserStaticData->serializedATN;
}


//----------------- Library_textContext ------------------------------------------------------------------

VerilogParser::Library_textContext::Library_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::Library_descriptionContext *> VerilogParser::Library_textContext::library_description() {
  return getRuleContexts<VerilogParser::Library_descriptionContext>();
}

VerilogParser::Library_descriptionContext* VerilogParser::Library_textContext::library_description(size_t i) {
  return getRuleContext<VerilogParser::Library_descriptionContext>(i);
}


size_t VerilogParser::Library_textContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_text;
}


std::any VerilogParser::Library_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_textContext* VerilogParser::library_text() {
  Library_textContext *_localctx = _tracker.createInstance<Library_textContext>(_ctx, getState());
  enterRule(_localctx, 0, VerilogParser::RuleLibrary_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(777);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 14) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 14)) & 2256197860196353) != 0)) {
      setState(774);
      library_description();
      setState(779);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(780);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_descriptionContext ------------------------------------------------------------------

VerilogParser::Library_descriptionContext::Library_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Library_declarationContext* VerilogParser::Library_descriptionContext::library_declaration() {
  return getRuleContext<VerilogParser::Library_declarationContext>(0);
}

VerilogParser::Include_statementContext* VerilogParser::Library_descriptionContext::include_statement() {
  return getRuleContext<VerilogParser::Include_statementContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::Library_descriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}


size_t VerilogParser::Library_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_description;
}


std::any VerilogParser::Library_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_descriptionContext* VerilogParser::library_description() {
  Library_descriptionContext *_localctx = _tracker.createInstance<Library_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 2, VerilogParser::RuleLibrary_description);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(785);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LIBRARY: {
        enterOuterAlt(_localctx, 1);
        setState(782);
        library_declaration();
        break;
      }

      case VerilogParser::INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(783);
        include_statement();
        break;
      }

      case VerilogParser::CONFIG: {
        enterOuterAlt(_localctx, 3);
        setState(784);
        config_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_declarationContext ------------------------------------------------------------------

VerilogParser::Library_declarationContext::Library_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_declarationContext::LIBRARY() {
  return getToken(VerilogParser::LIBRARY, 0);
}

VerilogParser::Library_identifierContext* VerilogParser::Library_declarationContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_declarationContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_declarationContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_declarationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Library_incdirContext* VerilogParser::Library_declarationContext::library_incdir() {
  return getRuleContext<VerilogParser::Library_incdirContext>(0);
}


size_t VerilogParser::Library_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_declaration;
}


std::any VerilogParser::Library_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_declarationContext* VerilogParser::library_declaration() {
  Library_declarationContext *_localctx = _tracker.createInstance<Library_declarationContext>(_ctx, getState());
  enterRule(_localctx, 4, VerilogParser::RuleLibrary_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(787);
    match(VerilogParser::LIBRARY);
    setState(788);
    library_identifier();
    setState(789);
    file_path_spec();
    setState(794);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(790);
      match(VerilogParser::CO);
      setState(791);
      file_path_spec();
      setState(796);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MIINCDIR) {
      setState(797);
      library_incdir();
    }
    setState(800);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_incdirContext ------------------------------------------------------------------

VerilogParser::Library_incdirContext::Library_incdirContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_incdirContext::MIINCDIR() {
  return getToken(VerilogParser::MIINCDIR, 0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_incdirContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_incdirContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_incdirContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_incdirContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Library_incdirContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_incdir;
}


std::any VerilogParser::Library_incdirContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_incdir(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_incdirContext* VerilogParser::library_incdir() {
  Library_incdirContext *_localctx = _tracker.createInstance<Library_incdirContext>(_ctx, getState());
  enterRule(_localctx, 6, VerilogParser::RuleLibrary_incdir);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(802);
    match(VerilogParser::MIINCDIR);
    setState(803);
    file_path_spec();
    setState(808);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(804);
      match(VerilogParser::CO);
      setState(805);
      file_path_spec();
      setState(810);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_statementContext ------------------------------------------------------------------

VerilogParser::Include_statementContext::Include_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Include_statementContext::INCLUDE() {
  return getToken(VerilogParser::INCLUDE, 0);
}

VerilogParser::File_path_specContext* VerilogParser::Include_statementContext::file_path_spec() {
  return getRuleContext<VerilogParser::File_path_specContext>(0);
}

tree::TerminalNode* VerilogParser::Include_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Include_statementContext::getRuleIndex() const {
  return VerilogParser::RuleInclude_statement;
}


std::any VerilogParser::Include_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInclude_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Include_statementContext* VerilogParser::include_statement() {
  Include_statementContext *_localctx = _tracker.createInstance<Include_statementContext>(_ctx, getState());
  enterRule(_localctx, 8, VerilogParser::RuleInclude_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(811);
    match(VerilogParser::INCLUDE);
    setState(812);
    file_path_spec();
    setState(813);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_path_specContext ------------------------------------------------------------------

VerilogParser::File_path_specContext::File_path_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::File_path_specContext::FILE_PATH_SPEC() {
  return getToken(VerilogParser::FILE_PATH_SPEC, 0);
}


size_t VerilogParser::File_path_specContext::getRuleIndex() const {
  return VerilogParser::RuleFile_path_spec;
}


std::any VerilogParser::File_path_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFile_path_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::File_path_specContext* VerilogParser::file_path_spec() {
  File_path_specContext *_localctx = _tracker.createInstance<File_path_specContext>(_ctx, getState());
  enterRule(_localctx, 10, VerilogParser::RuleFile_path_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(815);
    match(VerilogParser::FILE_PATH_SPEC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_textContext ------------------------------------------------------------------

VerilogParser::Source_textContext::Source_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Source_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::DescriptionContext *> VerilogParser::Source_textContext::description() {
  return getRuleContexts<VerilogParser::DescriptionContext>();
}

VerilogParser::DescriptionContext* VerilogParser::Source_textContext::description(size_t i) {
  return getRuleContext<VerilogParser::DescriptionContext>(i);
}


size_t VerilogParser::Source_textContext::getRuleIndex() const {
  return VerilogParser::RuleSource_text;
}


std::any VerilogParser::Source_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSource_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Source_textContext* VerilogParser::source_text() {
  Source_textContext *_localctx = _tracker.createInstance<Source_textContext>(_ctx, getState());
  enterRule(_localctx, 12, VerilogParser::RuleSource_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(820);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CONFIG || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 262153) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 140)) & 4398046511107) != 0)) {
      setState(817);
      description();
      setState(822);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(823);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescriptionContext ------------------------------------------------------------------

VerilogParser::DescriptionContext::DescriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_declarationContext* VerilogParser::DescriptionContext::module_declaration() {
  return getRuleContext<VerilogParser::Module_declarationContext>(0);
}

VerilogParser::Udp_declarationContext* VerilogParser::DescriptionContext::udp_declaration() {
  return getRuleContext<VerilogParser::Udp_declarationContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::DescriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}

VerilogParser::Nature_declarationContext* VerilogParser::DescriptionContext::nature_declaration() {
  return getRuleContext<VerilogParser::Nature_declarationContext>(0);
}

VerilogParser::Discipline_declarationContext* VerilogParser::DescriptionContext::discipline_declaration() {
  return getRuleContext<VerilogParser::Discipline_declarationContext>(0);
}


size_t VerilogParser::DescriptionContext::getRuleIndex() const {
  return VerilogParser::RuleDescription;
}


std::any VerilogParser::DescriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDescription(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DescriptionContext* VerilogParser::description() {
  DescriptionContext *_localctx = _tracker.createInstance<DescriptionContext>(_ctx, getState());
  enterRule(_localctx, 14, VerilogParser::RuleDescription);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(830);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(825);
      module_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(826);
      udp_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(827);
      config_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(828);
      nature_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(829);
      discipline_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_declarationContext ------------------------------------------------------------------

VerilogParser::Module_declarationContext::Module_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_keywordContext* VerilogParser::Module_declarationContext::module_keyword() {
  return getRuleContext<VerilogParser::Module_keywordContext>(0);
}

VerilogParser::Module_identifierContext* VerilogParser::Module_declarationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::ENDMODULE() {
  return getToken(VerilogParser::ENDMODULE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::Module_declarationContext::module_parameter_port_list() {
  return getRuleContext<VerilogParser::Module_parameter_port_listContext>(0);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::Module_declarationContext::list_of_port_declarations() {
  return getRuleContext<VerilogParser::List_of_port_declarationsContext>(0);
}

std::vector<VerilogParser::Module_itemContext *> VerilogParser::Module_declarationContext::module_item() {
  return getRuleContexts<VerilogParser::Module_itemContext>();
}

VerilogParser::Module_itemContext* VerilogParser::Module_declarationContext::module_item(size_t i) {
  return getRuleContext<VerilogParser::Module_itemContext>(i);
}


size_t VerilogParser::Module_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_declaration;
}


std::any VerilogParser::Module_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_declarationContext* VerilogParser::module_declaration() {
  Module_declarationContext *_localctx = _tracker.createInstance<Module_declarationContext>(_ctx, getState());
  enterRule(_localctx, 16, VerilogParser::RuleModule_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(832);
      attribute_instance();
      setState(837);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(838);
    module_keyword();
    setState(839);
    module_identifier();
    setState(841);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(840);
      module_parameter_port_list();
    }
    setState(844);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(843);
      list_of_port_declarations();
    }
    setState(846);
    match(VerilogParser::SC);
    setState(850);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3336657150486389710) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7494158970579124831) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 562949953421375) != 0) || _la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(847);
      module_item();
      setState(852);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(853);
    match(VerilogParser::ENDMODULE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_keywordContext ------------------------------------------------------------------

VerilogParser::Module_keywordContext::Module_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MODULE() {
  return getToken(VerilogParser::MODULE, 0);
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MACROMODULE() {
  return getToken(VerilogParser::MACROMODULE, 0);
}


size_t VerilogParser::Module_keywordContext::getRuleIndex() const {
  return VerilogParser::RuleModule_keyword;
}


std::any VerilogParser::Module_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_keyword(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_keywordContext* VerilogParser::module_keyword() {
  Module_keywordContext *_localctx = _tracker.createInstance<Module_keywordContext>(_ctx, getState());
  enterRule(_localctx, 18, VerilogParser::RuleModule_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(855);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MACROMODULE

    || _la == VerilogParser::MODULE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_parameter_port_listContext ------------------------------------------------------------------

VerilogParser::Module_parameter_port_listContext::Module_parameter_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Parameter_declarationContext *> VerilogParser::Module_parameter_port_listContext::parameter_declaration() {
  return getRuleContexts<VerilogParser::Parameter_declarationContext>();
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_parameter_port_listContext::parameter_declaration(size_t i) {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_parameter_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_parameter_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleModule_parameter_port_list;
}


std::any VerilogParser::Module_parameter_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_parameter_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::module_parameter_port_list() {
  Module_parameter_port_listContext *_localctx = _tracker.createInstance<Module_parameter_port_listContext>(_ctx, getState());
  enterRule(_localctx, 20, VerilogParser::RuleModule_parameter_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(857);
    match(VerilogParser::HA);
    setState(858);
    match(VerilogParser::LP);
    setState(859);
    parameter_declaration();
    setState(864);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(860);
      match(VerilogParser::CO);
      setState(861);
      parameter_declaration();
      setState(866);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(867);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_declarationsContext ------------------------------------------------------------------

VerilogParser::List_of_port_declarationsContext::List_of_port_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Port_declarationContext *> VerilogParser::List_of_port_declarationsContext::port_declaration() {
  return getRuleContexts<VerilogParser::Port_declarationContext>();
}

VerilogParser::Port_declarationContext* VerilogParser::List_of_port_declarationsContext::port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Port_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_declarationsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::PortContext *> VerilogParser::List_of_port_declarationsContext::port() {
  return getRuleContexts<VerilogParser::PortContext>();
}

VerilogParser::PortContext* VerilogParser::List_of_port_declarationsContext::port(size_t i) {
  return getRuleContext<VerilogParser::PortContext>(i);
}

VerilogParser::Port_implicitContext* VerilogParser::List_of_port_declarationsContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::List_of_port_declarationsContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::List_of_port_declarationsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_declarations;
}


std::any VerilogParser::List_of_port_declarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_declarations(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::list_of_port_declarations() {
  List_of_port_declarationsContext *_localctx = _tracker.createInstance<List_of_port_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 22, VerilogParser::RuleList_of_port_declarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(900);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(869);
      match(VerilogParser::LP);
      setState(870);
      port_declaration();
      setState(875);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(871);
        match(VerilogParser::CO);
        setState(872);
        port_declaration();
        setState(877);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(878);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(880);
      match(VerilogParser::LP);
      setState(881);
      port();
      setState(884); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(882);
        match(VerilogParser::CO);
        setState(883);
        port();
        setState(886); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == VerilogParser::CO);
      setState(888);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(890);
      match(VerilogParser::LP);
      setState(891);
      port_implicit();
      setState(892);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(894);
      match(VerilogParser::LP);
      setState(895);
      port_explicit();
      setState(896);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(898);
      match(VerilogParser::LP);
      setState(899);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

VerilogParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_implicitContext* VerilogParser::PortContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::PortContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::PortContext::getRuleIndex() const {
  return VerilogParser::RulePort;
}


std::any VerilogParser::PortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PortContext* VerilogParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 24, VerilogParser::RulePort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(906);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CO:
      case VerilogParser::LC:
      case VerilogParser::RP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(903);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 181) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 181)) & 16908289) != 0)) {
          setState(902);
          port_implicit();
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(905);
        port_explicit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_implicitContext ------------------------------------------------------------------

VerilogParser::Port_implicitContext::Port_implicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_expressionContext* VerilogParser::Port_implicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_implicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_implicit;
}


std::any VerilogParser::Port_implicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_implicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_implicitContext* VerilogParser::port_implicit() {
  Port_implicitContext *_localctx = _tracker.createInstance<Port_implicitContext>(_ctx, getState());
  enterRule(_localctx, 26, VerilogParser::RulePort_implicit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    port_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_explicitContext ------------------------------------------------------------------

VerilogParser::Port_explicitContext::Port_explicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Port_explicitContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Port_explicitContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Port_expressionContext* VerilogParser::Port_explicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_explicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_explicit;
}


std::any VerilogParser::Port_explicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_explicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_explicitContext* VerilogParser::port_explicit() {
  Port_explicitContext *_localctx = _tracker.createInstance<Port_explicitContext>(_ctx, getState());
  enterRule(_localctx, 28, VerilogParser::RulePort_explicit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(910);
    match(VerilogParser::DT);
    setState(911);
    port_identifier();
    setState(912);
    match(VerilogParser::LP);
    setState(914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 181) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 181)) & 16908289) != 0)) {
      setState(913);
      port_expression();
    }
    setState(916);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_expressionContext ------------------------------------------------------------------

VerilogParser::Port_expressionContext::Port_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_referenceContext *> VerilogParser::Port_expressionContext::port_reference() {
  return getRuleContexts<VerilogParser::Port_referenceContext>();
}

VerilogParser::Port_referenceContext* VerilogParser::Port_expressionContext::port_reference(size_t i) {
  return getRuleContext<VerilogParser::Port_referenceContext>(i);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Port_expressionContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Port_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePort_expression;
}


std::any VerilogParser::Port_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_expressionContext* VerilogParser::port_expression() {
  Port_expressionContext *_localctx = _tracker.createInstance<Port_expressionContext>(_ctx, getState());
  enterRule(_localctx, 30, VerilogParser::RulePort_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(930);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(918);
        port_reference();
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(919);
        match(VerilogParser::LC);
        setState(920);
        port_reference();
        setState(925);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(921);
          match(VerilogParser::CO);
          setState(922);
          port_reference();
          setState(927);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(928);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_referenceContext ------------------------------------------------------------------

VerilogParser::Port_referenceContext::Port_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Port_referenceContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Port_referenceContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Port_referenceContext::getRuleIndex() const {
  return VerilogParser::RulePort_reference;
}


std::any VerilogParser::Port_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_referenceContext* VerilogParser::port_reference() {
  Port_referenceContext *_localctx = _tracker.createInstance<Port_referenceContext>(_ctx, getState());
  enterRule(_localctx, 32, VerilogParser::RulePort_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(932);
    port_identifier();
    setState(937);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(933);
      match(VerilogParser::LB);
      setState(934);
      constant_range_expression();
      setState(935);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_declarationContext ------------------------------------------------------------------

VerilogParser::Port_declarationContext::Port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Inout_declarationContext* VerilogParser::Port_declarationContext::inout_declaration() {
  return getRuleContext<VerilogParser::Inout_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Port_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Port_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Input_declarationContext* VerilogParser::Port_declarationContext::input_declaration() {
  return getRuleContext<VerilogParser::Input_declarationContext>(0);
}

VerilogParser::Output_declarationContext* VerilogParser::Port_declarationContext::output_declaration() {
  return getRuleContext<VerilogParser::Output_declarationContext>(0);
}


size_t VerilogParser::Port_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePort_declaration;
}


std::any VerilogParser::Port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_declarationContext* VerilogParser::port_declaration() {
  Port_declarationContext *_localctx = _tracker.createInstance<Port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 34, VerilogParser::RulePort_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(960);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(942);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(939);
        attribute_instance();
        setState(944);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(945);
      inout_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(949);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(946);
        attribute_instance();
        setState(951);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(952);
      input_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(956);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(953);
        attribute_instance();
        setState(958);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(959);
      output_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_itemContext ------------------------------------------------------------------

VerilogParser::Module_itemContext::Module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_declarationContext* VerilogParser::Module_itemContext::port_declaration() {
  return getRuleContext<VerilogParser::Port_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Module_itemContext::module_or_generate_item() {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(0);
}

VerilogParser::Generate_regionContext* VerilogParser::Module_itemContext::generate_region() {
  return getRuleContext<VerilogParser::Generate_regionContext>(0);
}

VerilogParser::Specify_blockContext* VerilogParser::Module_itemContext::specify_block() {
  return getRuleContext<VerilogParser::Specify_blockContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_itemContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Specparam_declarationContext* VerilogParser::Module_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}

VerilogParser::Electrical_declarationContext* VerilogParser::Module_itemContext::electrical_declaration() {
  return getRuleContext<VerilogParser::Electrical_declarationContext>(0);
}


size_t VerilogParser::Module_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_item;
}


std::any VerilogParser::Module_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_itemContext* VerilogParser::module_item() {
  Module_itemContext *_localctx = _tracker.createInstance<Module_itemContext>(_ctx, getState());
  enterRule(_localctx, 36, VerilogParser::RuleModule_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(985);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(962);
      port_declaration();
      setState(963);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(965);
      module_or_generate_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(966);
      generate_region();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(967);
      specify_block();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(971);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(968);
        attribute_instance();
        setState(973);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(974);
      parameter_declaration();
      setState(975);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(980);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(977);
        attribute_instance();
        setState(982);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(983);
      specparam_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(984);
      electrical_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_itemContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_itemContext::Module_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::Module_or_generate_itemContext::module_or_generate_item_declaration() {
  return getRuleContext<VerilogParser::Module_or_generate_item_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_or_generate_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_or_generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Module_or_generate_itemContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_or_generate_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_overrideContext* VerilogParser::Module_or_generate_itemContext::parameter_override() {
  return getRuleContext<VerilogParser::Parameter_overrideContext>(0);
}

VerilogParser::Continuous_assignContext* VerilogParser::Module_or_generate_itemContext::continuous_assign() {
  return getRuleContext<VerilogParser::Continuous_assignContext>(0);
}

VerilogParser::Gate_instantiationContext* VerilogParser::Module_or_generate_itemContext::gate_instantiation() {
  return getRuleContext<VerilogParser::Gate_instantiationContext>(0);
}

VerilogParser::Module_instantiationContext* VerilogParser::Module_or_generate_itemContext::module_instantiation() {
  return getRuleContext<VerilogParser::Module_instantiationContext>(0);
}

VerilogParser::Udp_instantiationContext* VerilogParser::Module_or_generate_itemContext::udp_instantiation() {
  return getRuleContext<VerilogParser::Udp_instantiationContext>(0);
}

VerilogParser::Initial_constructContext* VerilogParser::Module_or_generate_itemContext::initial_construct() {
  return getRuleContext<VerilogParser::Initial_constructContext>(0);
}

VerilogParser::Always_constructContext* VerilogParser::Module_or_generate_itemContext::always_construct() {
  return getRuleContext<VerilogParser::Always_constructContext>(0);
}

VerilogParser::Analog_constructContext* VerilogParser::Module_or_generate_itemContext::analog_construct() {
  return getRuleContext<VerilogParser::Analog_constructContext>(0);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::Module_or_generate_itemContext::loop_generate_construct() {
  return getRuleContext<VerilogParser::Loop_generate_constructContext>(0);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::Module_or_generate_itemContext::conditional_generate_construct() {
  return getRuleContext<VerilogParser::Conditional_generate_constructContext>(0);
}


size_t VerilogParser::Module_or_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item;
}


std::any VerilogParser::Module_or_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::module_or_generate_item() {
  Module_or_generate_itemContext *_localctx = _tracker.createInstance<Module_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 38, VerilogParser::RuleModule_or_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1073);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(990);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(987);
        attribute_instance();
        setState(992);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(993);
      module_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(997);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(994);
        attribute_instance();
        setState(999);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1000);
      local_parameter_declaration();
      setState(1001);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1006);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1003);
        attribute_instance();
        setState(1008);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1009);
      parameter_override();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1013);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1010);
        attribute_instance();
        setState(1015);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1016);
      continuous_assign();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1020);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1017);
        attribute_instance();
        setState(1022);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1023);
      gate_instantiation();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1027);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1024);
        attribute_instance();
        setState(1029);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1030);
      module_instantiation();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1034);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1031);
        attribute_instance();
        setState(1036);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1037);
      udp_instantiation();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1041);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1038);
        attribute_instance();
        setState(1043);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1044);
      initial_construct();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1048);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1045);
        attribute_instance();
        setState(1050);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1051);
      always_construct();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1055);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1052);
        attribute_instance();
        setState(1057);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1058);
      analog_construct();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1062);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1059);
        attribute_instance();
        setState(1064);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1065);
      loop_generate_construct();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1069);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1066);
        attribute_instance();
        setState(1071);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1072);
      conditional_generate_construct();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_item_declarationContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_item_declarationContext::Module_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::net_declaration() {
  return getRuleContext<VerilogParser::Net_declarationContext>(0);
}

VerilogParser::Reg_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::reg_declaration() {
  return getRuleContext<VerilogParser::Reg_declarationContext>(0);
}

VerilogParser::Integer_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::integer_declaration() {
  return getRuleContext<VerilogParser::Integer_declarationContext>(0);
}

VerilogParser::Real_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::real_declaration() {
  return getRuleContext<VerilogParser::Real_declarationContext>(0);
}

VerilogParser::Time_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::time_declaration() {
  return getRuleContext<VerilogParser::Time_declarationContext>(0);
}

VerilogParser::Realtime_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::realtime_declaration() {
  return getRuleContext<VerilogParser::Realtime_declarationContext>(0);
}

VerilogParser::Event_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Genvar_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::genvar_declaration() {
  return getRuleContext<VerilogParser::Genvar_declarationContext>(0);
}

VerilogParser::Task_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::task_declaration() {
  return getRuleContext<VerilogParser::Task_declarationContext>(0);
}

VerilogParser::Function_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::function_declaration() {
  return getRuleContext<VerilogParser::Function_declarationContext>(0);
}


size_t VerilogParser::Module_or_generate_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item_declaration;
}


std::any VerilogParser::Module_or_generate_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::module_or_generate_item_declaration() {
  Module_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Module_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 40, VerilogParser::RuleModule_or_generate_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1085);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR: {
        enterOuterAlt(_localctx, 1);
        setState(1075);
        net_declaration();
        break;
      }

      case VerilogParser::REG: {
        enterOuterAlt(_localctx, 2);
        setState(1076);
        reg_declaration();
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1077);
        integer_declaration();
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1078);
        real_declaration();
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 5);
        setState(1079);
        time_declaration();
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 6);
        setState(1080);
        realtime_declaration();
        break;
      }

      case VerilogParser::EVENT: {
        enterOuterAlt(_localctx, 7);
        setState(1081);
        event_declaration();
        break;
      }

      case VerilogParser::GENVAR: {
        enterOuterAlt(_localctx, 8);
        setState(1082);
        genvar_declaration();
        break;
      }

      case VerilogParser::TASK: {
        enterOuterAlt(_localctx, 9);
        setState(1083);
        task_declaration();
        break;
      }

      case VerilogParser::FUNCTION: {
        enterOuterAlt(_localctx, 10);
        setState(1084);
        function_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_overrideContext ------------------------------------------------------------------

VerilogParser::Parameter_overrideContext::Parameter_overrideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::DEFPARAM() {
  return getToken(VerilogParser::DEFPARAM, 0);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::Parameter_overrideContext::list_of_defparam_assignments() {
  return getRuleContext<VerilogParser::List_of_defparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Parameter_overrideContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_override;
}


std::any VerilogParser::Parameter_overrideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_override(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_overrideContext* VerilogParser::parameter_override() {
  Parameter_overrideContext *_localctx = _tracker.createInstance<Parameter_overrideContext>(_ctx, getState());
  enterRule(_localctx, 42, VerilogParser::RuleParameter_override);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1087);
    match(VerilogParser::DEFPARAM);
    setState(1088);
    list_of_defparam_assignments();
    setState(1089);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_declarationContext ------------------------------------------------------------------

VerilogParser::Config_declarationContext::Config_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Config_declarationContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}

VerilogParser::Config_identifierContext* VerilogParser::Config_declarationContext::config_identifier() {
  return getRuleContext<VerilogParser::Config_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Design_statementContext* VerilogParser::Config_declarationContext::design_statement() {
  return getRuleContext<VerilogParser::Design_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::ENDCONFIG() {
  return getToken(VerilogParser::ENDCONFIG, 0);
}

std::vector<VerilogParser::Config_rule_statementContext *> VerilogParser::Config_declarationContext::config_rule_statement() {
  return getRuleContexts<VerilogParser::Config_rule_statementContext>();
}

VerilogParser::Config_rule_statementContext* VerilogParser::Config_declarationContext::config_rule_statement(size_t i) {
  return getRuleContext<VerilogParser::Config_rule_statementContext>(i);
}


size_t VerilogParser::Config_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_declaration;
}


std::any VerilogParser::Config_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_declarationContext* VerilogParser::config_declaration() {
  Config_declarationContext *_localctx = _tracker.createInstance<Config_declarationContext>(_ctx, getState());
  enterRule(_localctx, 44, VerilogParser::RuleConfig_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1091);
    match(VerilogParser::CONFIG);
    setState(1092);
    config_identifier();
    setState(1093);
    match(VerilogParser::SC);
    setState(1094);
    design_statement();
    setState(1098);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1152921504606916608) != 0)) {
      setState(1095);
      config_rule_statement();
      setState(1100);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1101);
    match(VerilogParser::ENDCONFIG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statementContext ------------------------------------------------------------------

VerilogParser::Design_statementContext::Design_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Design_statementContext::DESIGN() {
  return getToken(VerilogParser::DESIGN, 0);
}

tree::TerminalNode* VerilogParser::Design_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Design_statement_itemContext *> VerilogParser::Design_statementContext::design_statement_item() {
  return getRuleContexts<VerilogParser::Design_statement_itemContext>();
}

VerilogParser::Design_statement_itemContext* VerilogParser::Design_statementContext::design_statement_item(size_t i) {
  return getRuleContext<VerilogParser::Design_statement_itemContext>(i);
}


size_t VerilogParser::Design_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement;
}


std::any VerilogParser::Design_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statementContext* VerilogParser::design_statement() {
  Design_statementContext *_localctx = _tracker.createInstance<Design_statementContext>(_ctx, getState());
  enterRule(_localctx, 46, VerilogParser::RuleDesign_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1103);
    match(VerilogParser::DESIGN);
    setState(1107);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(1104);
      design_statement_item();
      setState(1109);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1110);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statement_itemContext ------------------------------------------------------------------

VerilogParser::Design_statement_itemContext::Design_statement_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cell_identifierContext* VerilogParser::Design_statement_itemContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Design_statement_itemContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Design_statement_itemContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Design_statement_itemContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement_item;
}


std::any VerilogParser::Design_statement_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statement_itemContext* VerilogParser::design_statement_item() {
  Design_statement_itemContext *_localctx = _tracker.createInstance<Design_statement_itemContext>(_ctx, getState());
  enterRule(_localctx, 48, VerilogParser::RuleDesign_statement_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1115);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(1112);
      library_identifier();
      setState(1113);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1117);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_rule_statementContext ------------------------------------------------------------------

VerilogParser::Config_rule_statementContext::Config_rule_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Default_clauseContext* VerilogParser::Config_rule_statementContext::default_clause() {
  return getRuleContext<VerilogParser::Default_clauseContext>(0);
}

VerilogParser::Liblist_clauseContext* VerilogParser::Config_rule_statementContext::liblist_clause() {
  return getRuleContext<VerilogParser::Liblist_clauseContext>(0);
}

tree::TerminalNode* VerilogParser::Config_rule_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Inst_clauseContext* VerilogParser::Config_rule_statementContext::inst_clause() {
  return getRuleContext<VerilogParser::Inst_clauseContext>(0);
}

VerilogParser::Use_clauseContext* VerilogParser::Config_rule_statementContext::use_clause() {
  return getRuleContext<VerilogParser::Use_clauseContext>(0);
}

VerilogParser::Cell_clauseContext* VerilogParser::Config_rule_statementContext::cell_clause() {
  return getRuleContext<VerilogParser::Cell_clauseContext>(0);
}


size_t VerilogParser::Config_rule_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_rule_statement;
}


std::any VerilogParser::Config_rule_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_rule_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_rule_statementContext* VerilogParser::config_rule_statement() {
  Config_rule_statementContext *_localctx = _tracker.createInstance<Config_rule_statementContext>(_ctx, getState());
  enterRule(_localctx, 50, VerilogParser::RuleConfig_rule_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1139);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1119);
      default_clause();
      setState(1120);
      liblist_clause();
      setState(1121);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1123);
      inst_clause();
      setState(1124);
      liblist_clause();
      setState(1125);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1127);
      inst_clause();
      setState(1128);
      use_clause();
      setState(1129);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1131);
      cell_clause();
      setState(1132);
      liblist_clause();
      setState(1133);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1135);
      cell_clause();
      setState(1136);
      use_clause();
      setState(1137);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_clauseContext ------------------------------------------------------------------

VerilogParser::Default_clauseContext::Default_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Default_clauseContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Default_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleDefault_clause;
}


std::any VerilogParser::Default_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefault_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Default_clauseContext* VerilogParser::default_clause() {
  Default_clauseContext *_localctx = _tracker.createInstance<Default_clauseContext>(_ctx, getState());
  enterRule(_localctx, 52, VerilogParser::RuleDefault_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1141);
    match(VerilogParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_clauseContext ------------------------------------------------------------------

VerilogParser::Inst_clauseContext::Inst_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inst_clauseContext::INSTANCE() {
  return getToken(VerilogParser::INSTANCE, 0);
}

VerilogParser::Inst_nameContext* VerilogParser::Inst_clauseContext::inst_name() {
  return getRuleContext<VerilogParser::Inst_nameContext>(0);
}


size_t VerilogParser::Inst_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleInst_clause;
}


std::any VerilogParser::Inst_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_clauseContext* VerilogParser::inst_clause() {
  Inst_clauseContext *_localctx = _tracker.createInstance<Inst_clauseContext>(_ctx, getState());
  enterRule(_localctx, 54, VerilogParser::RuleInst_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1143);
    match(VerilogParser::INSTANCE);
    setState(1144);
    inst_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_nameContext ------------------------------------------------------------------

VerilogParser::Inst_nameContext::Inst_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Topmodule_identifierContext* VerilogParser::Inst_nameContext::topmodule_identifier() {
  return getRuleContext<VerilogParser::Topmodule_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Inst_nameContext::DT() {
  return getTokens(VerilogParser::DT);
}

tree::TerminalNode* VerilogParser::Inst_nameContext::DT(size_t i) {
  return getToken(VerilogParser::DT, i);
}

std::vector<VerilogParser::Instance_identifierContext *> VerilogParser::Inst_nameContext::instance_identifier() {
  return getRuleContexts<VerilogParser::Instance_identifierContext>();
}

VerilogParser::Instance_identifierContext* VerilogParser::Inst_nameContext::instance_identifier(size_t i) {
  return getRuleContext<VerilogParser::Instance_identifierContext>(i);
}


size_t VerilogParser::Inst_nameContext::getRuleIndex() const {
  return VerilogParser::RuleInst_name;
}


std::any VerilogParser::Inst_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_nameContext* VerilogParser::inst_name() {
  Inst_nameContext *_localctx = _tracker.createInstance<Inst_nameContext>(_ctx, getState());
  enterRule(_localctx, 56, VerilogParser::RuleInst_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1146);
    topmodule_identifier();
    setState(1151);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::DT) {
      setState(1147);
      match(VerilogParser::DT);
      setState(1148);
      instance_identifier();
      setState(1153);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_clauseContext ------------------------------------------------------------------

VerilogParser::Cell_clauseContext::Cell_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::CELL() {
  return getToken(VerilogParser::CELL, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Cell_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Cell_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Cell_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleCell_clause;
}


std::any VerilogParser::Cell_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_clauseContext* VerilogParser::cell_clause() {
  Cell_clauseContext *_localctx = _tracker.createInstance<Cell_clauseContext>(_ctx, getState());
  enterRule(_localctx, 58, VerilogParser::RuleCell_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1154);
    match(VerilogParser::CELL);
    setState(1158);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(1155);
      library_identifier();
      setState(1156);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1160);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Liblist_clauseContext ------------------------------------------------------------------

VerilogParser::Liblist_clauseContext::Liblist_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Liblist_clauseContext::LIBLIST() {
  return getToken(VerilogParser::LIBLIST, 0);
}

std::vector<VerilogParser::Library_identifierContext *> VerilogParser::Liblist_clauseContext::library_identifier() {
  return getRuleContexts<VerilogParser::Library_identifierContext>();
}

VerilogParser::Library_identifierContext* VerilogParser::Liblist_clauseContext::library_identifier(size_t i) {
  return getRuleContext<VerilogParser::Library_identifierContext>(i);
}


size_t VerilogParser::Liblist_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleLiblist_clause;
}


std::any VerilogParser::Liblist_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLiblist_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Liblist_clauseContext* VerilogParser::liblist_clause() {
  Liblist_clauseContext *_localctx = _tracker.createInstance<Liblist_clauseContext>(_ctx, getState());
  enterRule(_localctx, 60, VerilogParser::RuleLiblist_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1162);
    match(VerilogParser::LIBLIST);
    setState(1166);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(1163);
      library_identifier();
      setState(1168);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_clauseContext ------------------------------------------------------------------

VerilogParser::Use_clauseContext::Use_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Use_clauseContext::USE() {
  return getToken(VerilogParser::USE, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Use_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Use_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}


size_t VerilogParser::Use_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleUse_clause;
}


std::any VerilogParser::Use_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUse_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Use_clauseContext* VerilogParser::use_clause() {
  Use_clauseContext *_localctx = _tracker.createInstance<Use_clauseContext>(_ctx, getState());
  enterRule(_localctx, 62, VerilogParser::RuleUse_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1169);
    match(VerilogParser::USE);
    setState(1173);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(1170);
      library_identifier();
      setState(1171);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1175);
    cell_identifier();
    setState(1178);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(1176);
      match(VerilogParser::CL);
      setState(1177);
      match(VerilogParser::CONFIG);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Local_parameter_declarationContext::Local_parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::LOCALPARAM() {
  return getToken(VerilogParser::LOCALPARAM, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Local_parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Local_parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Local_parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Local_parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLocal_parameter_declaration;
}


std::any VerilogParser::Local_parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLocal_parameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::local_parameter_declaration() {
  Local_parameter_declarationContext *_localctx = _tracker.createInstance<Local_parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 64, VerilogParser::RuleLocal_parameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1192);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1180);
      match(VerilogParser::LOCALPARAM);
      setState(1182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1181);
        match(VerilogParser::SIGNED);
      }
      setState(1185);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1184);
        range_();
      }
      setState(1187);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1188);
      match(VerilogParser::LOCALPARAM);
      setState(1189);
      parameter_type();
      setState(1190);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Parameter_declarationContext::Parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::PARAMETER() {
  return getToken(VerilogParser::PARAMETER, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_declaration;
}


std::any VerilogParser::Parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_declarationContext* VerilogParser::parameter_declaration() {
  Parameter_declarationContext *_localctx = _tracker.createInstance<Parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 66, VerilogParser::RuleParameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1206);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1194);
      match(VerilogParser::PARAMETER);
      setState(1196);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1195);
        match(VerilogParser::SIGNED);
      }
      setState(1199);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1198);
        range_();
      }
      setState(1201);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1202);
      match(VerilogParser::PARAMETER);
      setState(1203);
      parameter_type();
      setState(1204);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_declarationContext ------------------------------------------------------------------

VerilogParser::Specparam_declarationContext::Specparam_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SPECPARAM() {
  return getToken(VerilogParser::SPECPARAM, 0);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::Specparam_declarationContext::list_of_specparam_assignments() {
  return getRuleContext<VerilogParser::List_of_specparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Range_Context* VerilogParser::Specparam_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Specparam_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_declaration;
}


std::any VerilogParser::Specparam_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_declarationContext* VerilogParser::specparam_declaration() {
  Specparam_declarationContext *_localctx = _tracker.createInstance<Specparam_declarationContext>(_ctx, getState());
  enterRule(_localctx, 68, VerilogParser::RuleSpecparam_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1208);
    match(VerilogParser::SPECPARAM);
    setState(1210);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1209);
      range_();
    }
    setState(1212);
    list_of_specparam_assignments();
    setState(1213);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_typeContext ------------------------------------------------------------------

VerilogParser::Parameter_typeContext::Parameter_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Parameter_typeContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_type;
}


std::any VerilogParser::Parameter_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_typeContext* VerilogParser::parameter_type() {
  Parameter_typeContext *_localctx = _tracker.createInstance<Parameter_typeContext>(_ctx, getState());
  enterRule(_localctx, 70, VerilogParser::RuleParameter_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1215);
    _la = _input->LA(1);
    if (!(((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 18014411394383873) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_declarationContext ------------------------------------------------------------------

VerilogParser::Inout_declarationContext::Inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Inout_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInout_declaration;
}


std::any VerilogParser::Inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_declarationContext* VerilogParser::inout_declaration() {
  Inout_declarationContext *_localctx = _tracker.createInstance<Inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 72, VerilogParser::RuleInout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1217);
    match(VerilogParser::INOUT);
    setState(1219);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0)) {
      setState(1218);
      net_type();
    }
    setState(1222);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1221);
      match(VerilogParser::SIGNED);
    }
    setState(1225);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1224);
      range_();
    }
    setState(1227);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_declarationContext ------------------------------------------------------------------

VerilogParser::Input_declarationContext::Input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Input_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInput_declaration;
}


std::any VerilogParser::Input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_declarationContext* VerilogParser::input_declaration() {
  Input_declarationContext *_localctx = _tracker.createInstance<Input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 74, VerilogParser::RuleInput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1229);
    match(VerilogParser::INPUT);
    setState(1231);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0)) {
      setState(1230);
      net_type();
    }
    setState(1234);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1233);
      match(VerilogParser::SIGNED);
    }
    setState(1237);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1236);
      range_();
    }
    setState(1239);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_declarationContext ------------------------------------------------------------------

VerilogParser::Output_declarationContext::Output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Output_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_variable_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_port_identifiersContext>(0);
}

VerilogParser::Output_variable_typeContext* VerilogParser::Output_declarationContext::output_variable_type() {
  return getRuleContext<VerilogParser::Output_variable_typeContext>(0);
}


size_t VerilogParser::Output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_declaration;
}


std::any VerilogParser::Output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_declarationContext* VerilogParser::output_declaration() {
  Output_declarationContext *_localctx = _tracker.createInstance<Output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 76, VerilogParser::RuleOutput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1265);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1241);
      match(VerilogParser::OUTPUT);
      setState(1243);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 111) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 111)) & 12889859) != 0)) {
        setState(1242);
        net_type();
      }
      setState(1246);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1245);
        match(VerilogParser::SIGNED);
      }
      setState(1249);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1248);
        range_();
      }
      setState(1251);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1252);
      match(VerilogParser::OUTPUT);
      setState(1253);
      match(VerilogParser::REG);
      setState(1255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1254);
        match(VerilogParser::SIGNED);
      }
      setState(1258);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1257);
        range_();
      }
      setState(1260);
      list_of_variable_port_identifiers();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1261);
      match(VerilogParser::OUTPUT);
      setState(1262);
      output_variable_type();
      setState(1263);
      list_of_variable_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_declarationContext ------------------------------------------------------------------

VerilogParser::Event_declarationContext::Event_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_declarationContext::EVENT() {
  return getToken(VerilogParser::EVENT, 0);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::Event_declarationContext::list_of_event_identifiers() {
  return getRuleContext<VerilogParser::List_of_event_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Event_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Event_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_declaration;
}


std::any VerilogParser::Event_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_declarationContext* VerilogParser::event_declaration() {
  Event_declarationContext *_localctx = _tracker.createInstance<Event_declarationContext>(_ctx, getState());
  enterRule(_localctx, 78, VerilogParser::RuleEvent_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1267);
    match(VerilogParser::EVENT);
    setState(1268);
    list_of_event_identifiers();
    setState(1269);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_declarationContext ------------------------------------------------------------------

VerilogParser::Integer_declarationContext::Integer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Integer_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Integer_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInteger_declaration;
}


std::any VerilogParser::Integer_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInteger_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Integer_declarationContext* VerilogParser::integer_declaration() {
  Integer_declarationContext *_localctx = _tracker.createInstance<Integer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 80, VerilogParser::RuleInteger_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1271);
    match(VerilogParser::INTEGER);
    setState(1272);
    list_of_variable_identifiers();
    setState(1273);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_declarationContext ------------------------------------------------------------------

VerilogParser::Net_declarationContext::Net_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_typeContext* VerilogParser::Net_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::Net_declarationContext::list_of_net_identifiers() {
  return getRuleContext<VerilogParser::List_of_net_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Delay3Context* VerilogParser::Net_declarationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::Net_declarationContext::list_of_net_decl_assignments() {
  return getRuleContext<VerilogParser::List_of_net_decl_assignmentsContext>(0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Net_declarationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Net_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::VECTORED() {
  return getToken(VerilogParser::VECTORED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SCALARED() {
  return getToken(VerilogParser::SCALARED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::TRIREG() {
  return getToken(VerilogParser::TRIREG, 0);
}

VerilogParser::Charge_strengthContext* VerilogParser::Net_declarationContext::charge_strength() {
  return getRuleContext<VerilogParser::Charge_strengthContext>(0);
}


size_t VerilogParser::Net_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleNet_declaration;
}


std::any VerilogParser::Net_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_declarationContext* VerilogParser::net_declaration() {
  Net_declarationContext *_localctx = _tracker.createInstance<Net_declarationContext>(_ctx, getState());
  enterRule(_localctx, 82, VerilogParser::RuleNet_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1389);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1275);
      net_type();
      setState(1277);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1276);
        match(VerilogParser::SIGNED);
      }
      setState(1280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1279);
        delay3();
      }
      setState(1282);
      list_of_net_identifiers();
      setState(1283);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1285);
      net_type();
      setState(1287);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1286);
        drive_strength();
      }
      setState(1290);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1289);
        match(VerilogParser::SIGNED);
      }
      setState(1293);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1292);
        delay3();
      }
      setState(1295);
      list_of_net_decl_assignments();
      setState(1296);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1298);
      net_type();
      setState(1300);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1299);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1302);
        match(VerilogParser::SIGNED);
      }
      setState(1305);
      range_();
      setState(1307);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1306);
        delay3();
      }
      setState(1309);
      list_of_net_identifiers();
      setState(1310);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1312);
      net_type();
      setState(1314);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1313);
        drive_strength();
      }
      setState(1317);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1316);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1320);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1319);
        match(VerilogParser::SIGNED);
      }
      setState(1322);
      range_();
      setState(1324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1323);
        delay3();
      }
      setState(1326);
      list_of_net_decl_assignments();
      setState(1327);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1329);
      match(VerilogParser::TRIREG);
      setState(1331);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1330);
        charge_strength();
      }
      setState(1334);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1333);
        match(VerilogParser::SIGNED);
      }
      setState(1337);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1336);
        delay3();
      }
      setState(1339);
      list_of_net_identifiers();
      setState(1340);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1342);
      match(VerilogParser::TRIREG);
      setState(1344);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1343);
        drive_strength();
      }
      setState(1347);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1346);
        match(VerilogParser::SIGNED);
      }
      setState(1350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1349);
        delay3();
      }
      setState(1352);
      list_of_net_decl_assignments();
      setState(1353);
      match(VerilogParser::SC);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1355);
      match(VerilogParser::TRIREG);
      setState(1357);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1356);
        charge_strength();
      }
      setState(1360);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1359);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1363);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1362);
        match(VerilogParser::SIGNED);
      }
      setState(1365);
      range_();
      setState(1367);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1366);
        delay3();
      }
      setState(1369);
      list_of_net_identifiers();
      setState(1370);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1372);
      match(VerilogParser::TRIREG);
      setState(1374);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1373);
        drive_strength();
      }
      setState(1377);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1376);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1380);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1379);
        match(VerilogParser::SIGNED);
      }
      setState(1382);
      range_();
      setState(1384);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1383);
        delay3();
      }
      setState(1386);
      list_of_net_decl_assignments();
      setState(1387);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_declarationContext ------------------------------------------------------------------

VerilogParser::Real_declarationContext::Real_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Real_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Real_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Real_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Real_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReal_declaration;
}


std::any VerilogParser::Real_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_declarationContext* VerilogParser::real_declaration() {
  Real_declarationContext *_localctx = _tracker.createInstance<Real_declarationContext>(_ctx, getState());
  enterRule(_localctx, 84, VerilogParser::RuleReal_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1391);
    match(VerilogParser::REAL);
    setState(1392);
    list_of_real_identifiers();
    setState(1393);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Realtime_declarationContext ------------------------------------------------------------------

VerilogParser::Realtime_declarationContext::Realtime_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Realtime_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Realtime_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleRealtime_declaration;
}


std::any VerilogParser::Realtime_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRealtime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Realtime_declarationContext* VerilogParser::realtime_declaration() {
  Realtime_declarationContext *_localctx = _tracker.createInstance<Realtime_declarationContext>(_ctx, getState());
  enterRule(_localctx, 86, VerilogParser::RuleRealtime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1395);
    match(VerilogParser::REALTIME);
    setState(1396);
    list_of_real_identifiers();
    setState(1397);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reg_declarationContext ------------------------------------------------------------------

VerilogParser::Reg_declarationContext::Reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Reg_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Reg_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReg_declaration;
}


std::any VerilogParser::Reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reg_declarationContext* VerilogParser::reg_declaration() {
  Reg_declarationContext *_localctx = _tracker.createInstance<Reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 88, VerilogParser::RuleReg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1399);
    match(VerilogParser::REG);
    setState(1401);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1400);
      match(VerilogParser::SIGNED);
    }
    setState(1404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1403);
      range_();
    }
    setState(1406);
    list_of_variable_identifiers();
    setState(1407);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_declarationContext ------------------------------------------------------------------

VerilogParser::Time_declarationContext::Time_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Time_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Time_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Time_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Time_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTime_declaration;
}


std::any VerilogParser::Time_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Time_declarationContext* VerilogParser::time_declaration() {
  Time_declarationContext *_localctx = _tracker.createInstance<Time_declarationContext>(_ctx, getState());
  enterRule(_localctx, 90, VerilogParser::RuleTime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1409);
    match(VerilogParser::TIME);
    setState(1410);
    list_of_variable_identifiers();
    setState(1411);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_typeContext ------------------------------------------------------------------

VerilogParser::Net_typeContext::Net_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRI() {
  return getToken(VerilogParser::TRI, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIAND() {
  return getToken(VerilogParser::TRIAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIOR() {
  return getToken(VerilogParser::TRIOR, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIZERO() {
  return getToken(VerilogParser::TRIZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIONE() {
  return getToken(VerilogParser::TRIONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::UWIRE() {
  return getToken(VerilogParser::UWIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WIRE() {
  return getToken(VerilogParser::WIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WAND() {
  return getToken(VerilogParser::WAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WOR() {
  return getToken(VerilogParser::WOR, 0);
}


size_t VerilogParser::Net_typeContext::getRuleIndex() const {
  return VerilogParser::RuleNet_type;
}


std::any VerilogParser::Net_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_typeContext* VerilogParser::net_type() {
  Net_typeContext *_localctx = _tracker.createInstance<Net_typeContext>(_ctx, getState());
  enterRule(_localctx, 92, VerilogParser::RuleNet_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1413);
    _la = _input->LA(1);
    if (!(((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Discipline_declarationContext ------------------------------------------------------------------

VerilogParser::Discipline_declarationContext::Discipline_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Discipline_declarationContext::DISCIPLINE() {
  return getToken(VerilogParser::DISCIPLINE, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Discipline_declarationContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Discipline_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Discipline_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleDiscipline_declaration;
}


std::any VerilogParser::Discipline_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDiscipline_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Discipline_declarationContext* VerilogParser::discipline_declaration() {
  Discipline_declarationContext *_localctx = _tracker.createInstance<Discipline_declarationContext>(_ctx, getState());
  enterRule(_localctx, 94, VerilogParser::RuleDiscipline_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1415);
    match(VerilogParser::DISCIPLINE);
    setState(1416);
    identifier();
    setState(1417);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nature_declarationContext ------------------------------------------------------------------

VerilogParser::Nature_declarationContext::Nature_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nature_declarationContext::NATURE() {
  return getToken(VerilogParser::NATURE, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Nature_declarationContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Nature_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Nature_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleNature_declaration;
}


std::any VerilogParser::Nature_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNature_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nature_declarationContext* VerilogParser::nature_declaration() {
  Nature_declarationContext *_localctx = _tracker.createInstance<Nature_declarationContext>(_ctx, getState());
  enterRule(_localctx, 96, VerilogParser::RuleNature_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1419);
    match(VerilogParser::NATURE);
    setState(1420);
    identifier();
    setState(1421);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Electrical_declarationContext ------------------------------------------------------------------

VerilogParser::Electrical_declarationContext::Electrical_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Electrical_declarationContext::ELECTRICAL() {
  return getToken(VerilogParser::ELECTRICAL, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Electrical_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Electrical_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Electrical_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleElectrical_declaration;
}


std::any VerilogParser::Electrical_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitElectrical_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Electrical_declarationContext* VerilogParser::electrical_declaration() {
  Electrical_declarationContext *_localctx = _tracker.createInstance<Electrical_declarationContext>(_ctx, getState());
  enterRule(_localctx, 98, VerilogParser::RuleElectrical_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1423);
    match(VerilogParser::ELECTRICAL);
    setState(1424);
    list_of_port_identifiers();
    setState(1425);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_variable_typeContext ------------------------------------------------------------------

VerilogParser::Output_variable_typeContext::Output_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Output_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_variable_type;
}


std::any VerilogParser::Output_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_variable_typeContext* VerilogParser::output_variable_type() {
  Output_variable_typeContext *_localctx = _tracker.createInstance<Output_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 100, VerilogParser::RuleOutput_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1427);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::INTEGER

    || _la == VerilogParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_typeContext ------------------------------------------------------------------

VerilogParser::Real_typeContext::Real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Real_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Real_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleReal_type;
}


std::any VerilogParser::Real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_typeContext* VerilogParser::real_type() {
  Real_typeContext *_localctx = _tracker.createInstance<Real_typeContext>(_ctx, getState());
  enterRule(_localctx, 102, VerilogParser::RuleReal_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1440);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1429);
      real_identifier();
      setState(1433);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1430);
        dimension();
        setState(1435);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1436);
      real_identifier();
      setState(1437);
      match(VerilogParser::EQ);
      setState(1438);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_typeContext ------------------------------------------------------------------

VerilogParser::Variable_typeContext::Variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Variable_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_type;
}


std::any VerilogParser::Variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_typeContext* VerilogParser::variable_type() {
  Variable_typeContext *_localctx = _tracker.createInstance<Variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 104, VerilogParser::RuleVariable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1453);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1442);
      variable_identifier();
      setState(1446);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1443);
        dimension();
        setState(1448);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1449);
      variable_identifier();
      setState(1450);
      match(VerilogParser::EQ);
      setState(1451);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drive_strengthContext ------------------------------------------------------------------

VerilogParser::Drive_strengthContext::Drive_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Drive_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Drive_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZONE() {
  return getToken(VerilogParser::HIGHZONE, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZZERO() {
  return getToken(VerilogParser::HIGHZZERO, 0);
}


size_t VerilogParser::Drive_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleDrive_strength;
}


std::any VerilogParser::Drive_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDrive_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Drive_strengthContext* VerilogParser::drive_strength() {
  Drive_strengthContext *_localctx = _tracker.createInstance<Drive_strengthContext>(_ctx, getState());
  enterRule(_localctx, 106, VerilogParser::RuleDrive_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1491);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1455);
      match(VerilogParser::LP);
      setState(1456);
      strength0();
      setState(1457);
      match(VerilogParser::CO);
      setState(1458);
      strength1();
      setState(1459);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1461);
      match(VerilogParser::LP);
      setState(1462);
      strength1();
      setState(1463);
      match(VerilogParser::CO);
      setState(1464);
      strength0();
      setState(1465);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1467);
      match(VerilogParser::LP);
      setState(1468);
      strength0();
      setState(1469);
      match(VerilogParser::CO);
      setState(1470);
      match(VerilogParser::HIGHZONE);
      setState(1471);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1473);
      match(VerilogParser::LP);
      setState(1474);
      strength1();
      setState(1475);
      match(VerilogParser::CO);
      setState(1476);
      match(VerilogParser::HIGHZZERO);
      setState(1477);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1479);
      match(VerilogParser::LP);
      setState(1480);
      match(VerilogParser::HIGHZZERO);
      setState(1481);
      match(VerilogParser::CO);
      setState(1482);
      strength1();
      setState(1483);
      match(VerilogParser::RP);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1485);
      match(VerilogParser::LP);
      setState(1486);
      match(VerilogParser::HIGHZONE);
      setState(1487);
      match(VerilogParser::CO);
      setState(1488);
      strength0();
      setState(1489);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength0Context ------------------------------------------------------------------

VerilogParser::Strength0Context::Strength0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength0Context::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::STRONGZERO() {
  return getToken(VerilogParser::STRONGZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::PULLZERO() {
  return getToken(VerilogParser::PULLZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::WEAKZERO() {
  return getToken(VerilogParser::WEAKZERO, 0);
}


size_t VerilogParser::Strength0Context::getRuleIndex() const {
  return VerilogParser::RuleStrength0;
}


std::any VerilogParser::Strength0Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength0(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength0Context* VerilogParser::strength0() {
  Strength0Context *_localctx = _tracker.createInstance<Strength0Context>(_ctx, getState());
  enterRule(_localctx, 108, VerilogParser::RuleStrength0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1493);
    _la = _input->LA(1);
    if (!(((((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4398056996865) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength1Context ------------------------------------------------------------------

VerilogParser::Strength1Context::Strength1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength1Context::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::STRONGONE() {
  return getToken(VerilogParser::STRONGONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::PULLONE() {
  return getToken(VerilogParser::PULLONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::WEAKONE() {
  return getToken(VerilogParser::WEAKONE, 0);
}


size_t VerilogParser::Strength1Context::getRuleIndex() const {
  return VerilogParser::RuleStrength1;
}


std::any VerilogParser::Strength1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength1(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength1Context* VerilogParser::strength1() {
  Strength1Context *_localctx = _tracker.createInstance<Strength1Context>(_ctx, getState());
  enterRule(_localctx, 110, VerilogParser::RuleStrength1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1495);
    _la = _input->LA(1);
    if (!(((((_la - 87) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 87)) & 8796113993729) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Charge_strengthContext ------------------------------------------------------------------

VerilogParser::Charge_strengthContext::Charge_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::SMALL() {
  return getToken(VerilogParser::SMALL, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::MEDIUM() {
  return getToken(VerilogParser::MEDIUM, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LARGE() {
  return getToken(VerilogParser::LARGE, 0);
}


size_t VerilogParser::Charge_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleCharge_strength;
}


std::any VerilogParser::Charge_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCharge_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Charge_strengthContext* VerilogParser::charge_strength() {
  Charge_strengthContext *_localctx = _tracker.createInstance<Charge_strengthContext>(_ctx, getState());
  enterRule(_localctx, 112, VerilogParser::RuleCharge_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1506);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1497);
      match(VerilogParser::LP);
      setState(1498);
      match(VerilogParser::SMALL);
      setState(1499);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1500);
      match(VerilogParser::LP);
      setState(1501);
      match(VerilogParser::MEDIUM);
      setState(1502);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1503);
      match(VerilogParser::LP);
      setState(1504);
      match(VerilogParser::LARGE);
      setState(1505);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay3Context ------------------------------------------------------------------

VerilogParser::Delay3Context::Delay3Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay3Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay3Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay3Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay3Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay3Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay3Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Delay3Context::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Delay3Context::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Delay3Context::getRuleIndex() const {
  return VerilogParser::RuleDelay3;
}


std::any VerilogParser::Delay3Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay3(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay3Context* VerilogParser::delay3() {
  Delay3Context *_localctx = _tracker.createInstance<Delay3Context>(_ctx, getState());
  enterRule(_localctx, 114, VerilogParser::RuleDelay3);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1523);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1508);
      match(VerilogParser::HA);
      setState(1509);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1510);
      match(VerilogParser::HA);
      setState(1511);
      match(VerilogParser::LP);
      setState(1512);
      mintypmax_expression();
      setState(1519);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1513);
        match(VerilogParser::CO);
        setState(1514);
        mintypmax_expression();
        setState(1517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CO) {
          setState(1515);
          match(VerilogParser::CO);
          setState(1516);
          mintypmax_expression();
        }
      }
      setState(1521);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay2Context ------------------------------------------------------------------

VerilogParser::Delay2Context::Delay2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay2Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay2Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay2Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay2Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay2Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay2Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Delay2Context::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Delay2Context::getRuleIndex() const {
  return VerilogParser::RuleDelay2;
}


std::any VerilogParser::Delay2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay2(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay2Context* VerilogParser::delay2() {
  Delay2Context *_localctx = _tracker.createInstance<Delay2Context>(_ctx, getState());
  enterRule(_localctx, 116, VerilogParser::RuleDelay2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1536);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1525);
      match(VerilogParser::HA);
      setState(1526);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1527);
      match(VerilogParser::HA);
      setState(1528);
      match(VerilogParser::LP);
      setState(1529);
      mintypmax_expression();
      setState(1532);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1530);
        match(VerilogParser::CO);
        setState(1531);
        mintypmax_expression();
      }
      setState(1534);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_valueContext ------------------------------------------------------------------

VerilogParser::Delay_valueContext::Delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Delay_valueContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::Delay_valueContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Delay_valueContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Delay_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_value;
}


std::any VerilogParser::Delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_valueContext* VerilogParser::delay_value() {
  Delay_valueContext *_localctx = _tracker.createInstance<Delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 118, VerilogParser::RuleDelay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1541);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(1538);
        unsigned_number();
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(1539);
        real_number();
        break;
      }

      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 3);
        setState(1540);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_defparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_defparam_assignmentsContext::List_of_defparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Defparam_assignmentContext *> VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment() {
  return getRuleContexts<VerilogParser::Defparam_assignmentContext>();
}

VerilogParser::Defparam_assignmentContext* VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Defparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_defparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_defparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_defparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_defparam_assignments;
}


std::any VerilogParser::List_of_defparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_defparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::list_of_defparam_assignments() {
  List_of_defparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_defparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 120, VerilogParser::RuleList_of_defparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1543);
    defparam_assignment();
    setState(1548);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1544);
      match(VerilogParser::CO);
      setState(1545);
      defparam_assignment();
      setState(1550);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_event_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_event_identifiersContext::List_of_event_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Event_idContext *> VerilogParser::List_of_event_identifiersContext::event_id() {
  return getRuleContexts<VerilogParser::Event_idContext>();
}

VerilogParser::Event_idContext* VerilogParser::List_of_event_identifiersContext::event_id(size_t i) {
  return getRuleContext<VerilogParser::Event_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_event_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_event_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_event_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_event_identifiers;
}


std::any VerilogParser::List_of_event_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_event_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::list_of_event_identifiers() {
  List_of_event_identifiersContext *_localctx = _tracker.createInstance<List_of_event_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 122, VerilogParser::RuleList_of_event_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1551);
    event_id();
    setState(1556);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1552);
      match(VerilogParser::CO);
      setState(1553);
      event_id();
      setState(1558);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_idContext ------------------------------------------------------------------

VerilogParser::Event_idContext::Event_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Event_identifierContext* VerilogParser::Event_idContext::event_identifier() {
  return getRuleContext<VerilogParser::Event_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Event_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Event_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Event_idContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_id;
}


std::any VerilogParser::Event_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_idContext* VerilogParser::event_id() {
  Event_idContext *_localctx = _tracker.createInstance<Event_idContext>(_ctx, getState());
  enterRule(_localctx, 124, VerilogParser::RuleEvent_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1559);
    event_identifier();
    setState(1563);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1560);
      dimension();
      setState(1565);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_decl_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_decl_assignmentsContext::List_of_net_decl_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_decl_assignmentContext *> VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment() {
  return getRuleContexts<VerilogParser::Net_decl_assignmentContext>();
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_decl_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_decl_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_decl_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_decl_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_decl_assignments;
}


std::any VerilogParser::List_of_net_decl_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_decl_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::list_of_net_decl_assignments() {
  List_of_net_decl_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_decl_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 126, VerilogParser::RuleList_of_net_decl_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1566);
    net_decl_assignment();
    setState(1571);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1567);
      match(VerilogParser::CO);
      setState(1568);
      net_decl_assignment();
      setState(1573);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_net_identifiersContext::List_of_net_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_idContext *> VerilogParser::List_of_net_identifiersContext::net_id() {
  return getRuleContexts<VerilogParser::Net_idContext>();
}

VerilogParser::Net_idContext* VerilogParser::List_of_net_identifiersContext::net_id(size_t i) {
  return getRuleContext<VerilogParser::Net_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_identifiers;
}


std::any VerilogParser::List_of_net_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::list_of_net_identifiers() {
  List_of_net_identifiersContext *_localctx = _tracker.createInstance<List_of_net_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 128, VerilogParser::RuleList_of_net_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1574);
    net_id();
    setState(1579);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1575);
      match(VerilogParser::CO);
      setState(1576);
      net_id();
      setState(1581);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_idContext ------------------------------------------------------------------

VerilogParser::Net_idContext::Net_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_idContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Net_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Net_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Net_idContext::getRuleIndex() const {
  return VerilogParser::RuleNet_id;
}


std::any VerilogParser::Net_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_idContext* VerilogParser::net_id() {
  Net_idContext *_localctx = _tracker.createInstance<Net_idContext>(_ctx, getState());
  enterRule(_localctx, 130, VerilogParser::RuleNet_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1582);
    net_identifier();
    setState(1586);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1583);
      dimension();
      setState(1588);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_param_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_param_assignmentsContext::List_of_param_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Param_assignmentContext *> VerilogParser::List_of_param_assignmentsContext::param_assignment() {
  return getRuleContexts<VerilogParser::Param_assignmentContext>();
}

VerilogParser::Param_assignmentContext* VerilogParser::List_of_param_assignmentsContext::param_assignment(size_t i) {
  return getRuleContext<VerilogParser::Param_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_param_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_param_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_param_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_param_assignments;
}


std::any VerilogParser::List_of_param_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_param_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::list_of_param_assignments() {
  List_of_param_assignmentsContext *_localctx = _tracker.createInstance<List_of_param_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 132, VerilogParser::RuleList_of_param_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1589);
    param_assignment();
    setState(1594);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1590);
        match(VerilogParser::CO);
        setState(1591);
        param_assignment(); 
      }
      setState(1596);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_port_identifiersContext::List_of_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_identifierContext *> VerilogParser::List_of_port_identifiersContext::port_identifier() {
  return getRuleContexts<VerilogParser::Port_identifierContext>();
}

VerilogParser::Port_identifierContext* VerilogParser::List_of_port_identifiersContext::port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Port_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_identifiers;
}


std::any VerilogParser::List_of_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::list_of_port_identifiers() {
  List_of_port_identifiersContext *_localctx = _tracker.createInstance<List_of_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 134, VerilogParser::RuleList_of_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1597);
    port_identifier();
    setState(1602);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1598);
        match(VerilogParser::CO);
        setState(1599);
        port_identifier(); 
      }
      setState(1604);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_real_identifiersContext::List_of_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Real_typeContext *> VerilogParser::List_of_real_identifiersContext::real_type() {
  return getRuleContexts<VerilogParser::Real_typeContext>();
}

VerilogParser::Real_typeContext* VerilogParser::List_of_real_identifiersContext::real_type(size_t i) {
  return getRuleContext<VerilogParser::Real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_real_identifiers;
}


std::any VerilogParser::List_of_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::list_of_real_identifiers() {
  List_of_real_identifiersContext *_localctx = _tracker.createInstance<List_of_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 136, VerilogParser::RuleList_of_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1605);
    real_type();
    setState(1610);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1606);
      match(VerilogParser::CO);
      setState(1607);
      real_type();
      setState(1612);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_specparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_specparam_assignmentsContext::List_of_specparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specparam_assignmentContext *> VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment() {
  return getRuleContexts<VerilogParser::Specparam_assignmentContext>();
}

VerilogParser::Specparam_assignmentContext* VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Specparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_specparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_specparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_specparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_specparam_assignments;
}


std::any VerilogParser::List_of_specparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_specparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::list_of_specparam_assignments() {
  List_of_specparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_specparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 138, VerilogParser::RuleList_of_specparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1613);
    specparam_assignment();
    setState(1618);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1614);
      match(VerilogParser::CO);
      setState(1615);
      specparam_assignment();
      setState(1620);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_identifiersContext::List_of_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Variable_typeContext *> VerilogParser::List_of_variable_identifiersContext::variable_type() {
  return getRuleContexts<VerilogParser::Variable_typeContext>();
}

VerilogParser::Variable_typeContext* VerilogParser::List_of_variable_identifiersContext::variable_type(size_t i) {
  return getRuleContext<VerilogParser::Variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_identifiers;
}


std::any VerilogParser::List_of_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::list_of_variable_identifiers() {
  List_of_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 140, VerilogParser::RuleList_of_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1621);
    variable_type();
    setState(1626);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1622);
      match(VerilogParser::CO);
      setState(1623);
      variable_type();
      setState(1628);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_port_identifiersContext::List_of_variable_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Var_port_idContext *> VerilogParser::List_of_variable_port_identifiersContext::var_port_id() {
  return getRuleContexts<VerilogParser::Var_port_idContext>();
}

VerilogParser::Var_port_idContext* VerilogParser::List_of_variable_port_identifiersContext::var_port_id(size_t i) {
  return getRuleContext<VerilogParser::Var_port_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_port_identifiers;
}


std::any VerilogParser::List_of_variable_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::list_of_variable_port_identifiers() {
  List_of_variable_port_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 142, VerilogParser::RuleList_of_variable_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1629);
    var_port_id();
    setState(1634);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1630);
        match(VerilogParser::CO);
        setState(1631);
        var_port_id(); 
      }
      setState(1636);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_port_idContext ------------------------------------------------------------------

VerilogParser::Var_port_idContext::Var_port_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Var_port_idContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Var_port_idContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Var_port_idContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Var_port_idContext::getRuleIndex() const {
  return VerilogParser::RuleVar_port_id;
}


std::any VerilogParser::Var_port_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVar_port_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Var_port_idContext* VerilogParser::var_port_id() {
  Var_port_idContext *_localctx = _tracker.createInstance<Var_port_idContext>(_ctx, getState());
  enterRule(_localctx, 144, VerilogParser::RuleVar_port_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1637);
    port_identifier();
    setState(1640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(1638);
      match(VerilogParser::EQ);
      setState(1639);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Defparam_assignmentContext::Defparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Defparam_assignmentContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Defparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Defparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Defparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleDefparam_assignment;
}


std::any VerilogParser::Defparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Defparam_assignmentContext* VerilogParser::defparam_assignment() {
  Defparam_assignmentContext *_localctx = _tracker.createInstance<Defparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 146, VerilogParser::RuleDefparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1642);
    hierarchical_identifier();
    setState(1643);
    match(VerilogParser::EQ);
    setState(1644);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_decl_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_decl_assignmentContext::Net_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_decl_assignmentContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Net_decl_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_decl_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_decl_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_decl_assignment;
}


std::any VerilogParser::Net_decl_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_decl_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::net_decl_assignment() {
  Net_decl_assignmentContext *_localctx = _tracker.createInstance<Net_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 148, VerilogParser::RuleNet_decl_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1646);
    net_identifier();
    setState(1647);
    match(VerilogParser::EQ);
    setState(1648);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_assignmentContext ------------------------------------------------------------------

VerilogParser::Param_assignmentContext::Param_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parameter_identifierContext* VerilogParser::Param_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Param_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Param_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Param_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParam_assignment;
}


std::any VerilogParser::Param_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Param_assignmentContext* VerilogParser::param_assignment() {
  Param_assignmentContext *_localctx = _tracker.createInstance<Param_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 150, VerilogParser::RuleParam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    parameter_identifier();
    setState(1651);
    match(VerilogParser::EQ);
    setState(1652);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Specparam_assignmentContext::Specparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_identifierContext* VerilogParser::Specparam_assignmentContext::specparam_identifier() {
  return getRuleContext<VerilogParser::Specparam_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Specparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::Specparam_assignmentContext::pulse_control_specparam() {
  return getRuleContext<VerilogParser::Pulse_control_specparamContext>(0);
}


size_t VerilogParser::Specparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_assignment;
}


std::any VerilogParser::Specparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_assignmentContext* VerilogParser::specparam_assignment() {
  Specparam_assignmentContext *_localctx = _tracker.createInstance<Specparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 152, VerilogParser::RuleSpecparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1659);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1654);
        specparam_identifier();
        setState(1655);
        match(VerilogParser::EQ);
        setState(1656);
        constant_mintypmax_expression();
        break;
      }

      case VerilogParser::PATHPULSEDL: {
        enterOuterAlt(_localctx, 2);
        setState(1658);
        pulse_control_specparam();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulse_control_specparamContext ------------------------------------------------------------------

VerilogParser::Pulse_control_specparamContext::Pulse_control_specparamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::PATHPULSEDL() {
  return getToken(VerilogParser::PATHPULSEDL, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::Pulse_control_specparamContext::reject_limit_value() {
  return getRuleContext<VerilogParser::Reject_limit_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Error_limit_valueContext* VerilogParser::Pulse_control_specparamContext::error_limit_value() {
  return getRuleContext<VerilogParser::Error_limit_valueContext>(0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::DL() {
  return getToken(VerilogParser::DL, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Pulse_control_specparamContext::getRuleIndex() const {
  return VerilogParser::RulePulse_control_specparam;
}


std::any VerilogParser::Pulse_control_specparamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulse_control_specparam(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::pulse_control_specparam() {
  Pulse_control_specparamContext *_localctx = _tracker.createInstance<Pulse_control_specparamContext>(_ctx, getState());
  enterRule(_localctx, 154, VerilogParser::RulePulse_control_specparam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1684);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1661);
      match(VerilogParser::PATHPULSEDL);
      setState(1662);
      match(VerilogParser::EQ);
      setState(1663);
      match(VerilogParser::LP);
      setState(1664);
      reject_limit_value();
      setState(1667);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1665);
        match(VerilogParser::CO);
        setState(1666);
        error_limit_value();
      }
      setState(1669);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1671);
      match(VerilogParser::PATHPULSEDL);
      setState(1672);
      specify_input_terminal_descriptor();
      setState(1673);
      match(VerilogParser::DL);
      setState(1674);
      specify_output_terminal_descriptor();
      setState(1675);
      match(VerilogParser::EQ);
      setState(1676);
      match(VerilogParser::LP);
      setState(1677);
      reject_limit_value();
      setState(1680);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1678);
        match(VerilogParser::CO);
        setState(1679);
        error_limit_value();
      }
      setState(1682);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_limit_valueContext ------------------------------------------------------------------

VerilogParser::Error_limit_valueContext::Error_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Error_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Error_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleError_limit_value;
}


std::any VerilogParser::Error_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitError_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Error_limit_valueContext* VerilogParser::error_limit_value() {
  Error_limit_valueContext *_localctx = _tracker.createInstance<Error_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 156, VerilogParser::RuleError_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1686);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reject_limit_valueContext ------------------------------------------------------------------

VerilogParser::Reject_limit_valueContext::Reject_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Reject_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Reject_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleReject_limit_value;
}


std::any VerilogParser::Reject_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReject_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::reject_limit_value() {
  Reject_limit_valueContext *_localctx = _tracker.createInstance<Reject_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 158, VerilogParser::RuleReject_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1688);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_valueContext ------------------------------------------------------------------

VerilogParser::Limit_valueContext::Limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Limit_valueContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleLimit_value;
}


std::any VerilogParser::Limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLimit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Limit_valueContext* VerilogParser::limit_value() {
  Limit_valueContext *_localctx = _tracker.createInstance<Limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 160, VerilogParser::RuleLimit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1690);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DimensionContext ------------------------------------------------------------------

VerilogParser::DimensionContext::DimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::DimensionContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Dimension_constant_expressionContext *> VerilogParser::DimensionContext::dimension_constant_expression() {
  return getRuleContexts<VerilogParser::Dimension_constant_expressionContext>();
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::DimensionContext::dimension_constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Dimension_constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::DimensionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::DimensionContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::DimensionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension;
}


std::any VerilogParser::DimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DimensionContext* VerilogParser::dimension() {
  DimensionContext *_localctx = _tracker.createInstance<DimensionContext>(_ctx, getState());
  enterRule(_localctx, 162, VerilogParser::RuleDimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1692);
    match(VerilogParser::LB);
    setState(1693);
    dimension_constant_expression();
    setState(1694);
    match(VerilogParser::CL);
    setState(1695);
    dimension_constant_expression();
    setState(1696);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_Context ------------------------------------------------------------------

VerilogParser::Range_Context::Range_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Range_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_Context::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_Context::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Range_Context::getRuleIndex() const {
  return VerilogParser::RuleRange_;
}


std::any VerilogParser::Range_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_Context* VerilogParser::range_() {
  Range_Context *_localctx = _tracker.createInstance<Range_Context>(_ctx, getState());
  enterRule(_localctx, 164, VerilogParser::RuleRange_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1698);
    match(VerilogParser::LB);
    setState(1699);
    msb_constant_expression();
    setState(1700);
    match(VerilogParser::CL);
    setState(1701);
    lsb_constant_expression();
    setState(1702);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_declarationContext ------------------------------------------------------------------

VerilogParser::Function_declarationContext::Function_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Function_declarationContext::FUNCTION() {
  return getToken(VerilogParser::FUNCTION, 0);
}

VerilogParser::Function_identifierContext* VerilogParser::Function_declarationContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Function_statementContext* VerilogParser::Function_declarationContext::function_statement() {
  return getRuleContext<VerilogParser::Function_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::ENDFUNCTION() {
  return getToken(VerilogParser::ENDFUNCTION, 0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::Function_declarationContext::function_range_or_type() {
  return getRuleContext<VerilogParser::Function_range_or_typeContext>(0);
}

std::vector<VerilogParser::Function_item_declarationContext *> VerilogParser::Function_declarationContext::function_item_declaration() {
  return getRuleContexts<VerilogParser::Function_item_declarationContext>();
}

VerilogParser::Function_item_declarationContext* VerilogParser::Function_declarationContext::function_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Function_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Function_port_listContext* VerilogParser::Function_declarationContext::function_port_list() {
  return getRuleContext<VerilogParser::Function_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Function_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Function_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_declaration;
}


std::any VerilogParser::Function_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_declarationContext* VerilogParser::function_declaration() {
  Function_declarationContext *_localctx = _tracker.createInstance<Function_declarationContext>(_ctx, getState());
  enterRule(_localctx, 166, VerilogParser::RuleFunction_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1742);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1704);
      match(VerilogParser::FUNCTION);
      setState(1706);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1705);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1709);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 61) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 61)) & 18032003580428289) != 0) || _la == VerilogParser::LB) {
        setState(1708);
        function_range_or_type();
      }
      setState(1711);
      function_identifier();
      setState(1712);
      match(VerilogParser::SC);
      setState(1714); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1713);
                function_item_declaration();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1716); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1718);
      function_statement();
      setState(1719);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1721);
      match(VerilogParser::FUNCTION);
      setState(1723);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1722);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1726);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 61) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 61)) & 18032003580428289) != 0) || _la == VerilogParser::LB) {
        setState(1725);
        function_range_or_type();
      }
      setState(1728);
      function_identifier();
      setState(1729);
      match(VerilogParser::LP);
      setState(1730);
      function_port_list();
      setState(1731);
      match(VerilogParser::RP);
      setState(1732);
      match(VerilogParser::SC);
      setState(1736);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1733);
          block_item_declaration(); 
        }
        setState(1738);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx);
      }
      setState(1739);
      function_statement();
      setState(1740);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_item_declarationContext ------------------------------------------------------------------

VerilogParser::Function_item_declarationContext::Function_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Function_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Function_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Function_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_item_declaration;
}


std::any VerilogParser::Function_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_item_declarationContext* VerilogParser::function_item_declaration() {
  Function_item_declarationContext *_localctx = _tracker.createInstance<Function_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 168, VerilogParser::RuleFunction_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1754);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1744);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1748);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1745);
        attribute_instance();
        setState(1750);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1751);
      tf_input_declaration();
      setState(1752);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_port_listContext ------------------------------------------------------------------

VerilogParser::Function_port_listContext::Function_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Func_port_itemContext *> VerilogParser::Function_port_listContext::func_port_item() {
  return getRuleContexts<VerilogParser::Func_port_itemContext>();
}

VerilogParser::Func_port_itemContext* VerilogParser::Function_port_listContext::func_port_item(size_t i) {
  return getRuleContext<VerilogParser::Func_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_port_list;
}


std::any VerilogParser::Function_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_port_listContext* VerilogParser::function_port_list() {
  Function_port_listContext *_localctx = _tracker.createInstance<Function_port_listContext>(_ctx, getState());
  enterRule(_localctx, 170, VerilogParser::RuleFunction_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1756);
    func_port_item();
    setState(1761);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1757);
      match(VerilogParser::CO);
      setState(1758);
      func_port_item();
      setState(1763);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_port_itemContext ------------------------------------------------------------------

VerilogParser::Func_port_itemContext::Func_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Func_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Func_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Func_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Func_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleFunc_port_item;
}


std::any VerilogParser::Func_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunc_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Func_port_itemContext* VerilogParser::func_port_item() {
  Func_port_itemContext *_localctx = _tracker.createInstance<Func_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 172, VerilogParser::RuleFunc_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1767);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(1764);
      attribute_instance();
      setState(1769);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1770);
    tf_input_declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_range_or_typeContext ------------------------------------------------------------------

VerilogParser::Function_range_or_typeContext::Function_range_or_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Range_Context* VerilogParser::Function_range_or_typeContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Function_range_or_typeContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_range_or_type;
}


std::any VerilogParser::Function_range_or_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_range_or_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::function_range_or_type() {
  Function_range_or_typeContext *_localctx = _tracker.createInstance<Function_range_or_typeContext>(_ctx, getState());
  enterRule(_localctx, 174, VerilogParser::RuleFunction_range_or_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1781);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LB: {
        enterOuterAlt(_localctx, 1);
        setState(1772);
        range_();
        break;
      }

      case VerilogParser::SIGNED: {
        enterOuterAlt(_localctx, 2);
        setState(1773);
        match(VerilogParser::SIGNED);
        setState(1775);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(1774);
          range_();
        }
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1777);
        match(VerilogParser::INTEGER);
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1778);
        match(VerilogParser::REAL);
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 5);
        setState(1779);
        match(VerilogParser::REALTIME);
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 6);
        setState(1780);
        match(VerilogParser::TIME);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_declarationContext ------------------------------------------------------------------

VerilogParser::Task_declarationContext::Task_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_declarationContext::TASK() {
  return getToken(VerilogParser::TASK, 0);
}

VerilogParser::Task_identifierContext* VerilogParser::Task_declarationContext::task_identifier() {
  return getRuleContext<VerilogParser::Task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Task_declarationContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::ENDTASK() {
  return getToken(VerilogParser::ENDTASK, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

std::vector<VerilogParser::Task_item_declarationContext *> VerilogParser::Task_declarationContext::task_item_declaration() {
  return getRuleContexts<VerilogParser::Task_item_declarationContext>();
}

VerilogParser::Task_item_declarationContext* VerilogParser::Task_declarationContext::task_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Task_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Task_port_listContext* VerilogParser::Task_declarationContext::task_port_list() {
  return getRuleContext<VerilogParser::Task_port_listContext>(0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Task_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Task_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_declaration;
}


std::any VerilogParser::Task_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_declarationContext* VerilogParser::task_declaration() {
  Task_declarationContext *_localctx = _tracker.createInstance<Task_declarationContext>(_ctx, getState());
  enterRule(_localctx, 176, VerilogParser::RuleTask_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1818);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1783);
      match(VerilogParser::TASK);
      setState(1785);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1784);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1787);
      task_identifier();
      setState(1788);
      match(VerilogParser::SC);
      setState(1792);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1789);
          task_item_declaration(); 
        }
        setState(1794);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx);
      }
      setState(1795);
      statement_or_null();
      setState(1796);
      match(VerilogParser::ENDTASK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1798);
      match(VerilogParser::TASK);
      setState(1800);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1799);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1802);
      task_identifier();
      setState(1803);
      match(VerilogParser::LP);
      setState(1805);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 58) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 58)) & 4194307) != 0) || _la == VerilogParser::LP) {
        setState(1804);
        task_port_list();
      }
      setState(1807);
      match(VerilogParser::RP);
      setState(1808);
      match(VerilogParser::SC);
      setState(1812);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1809);
          block_item_declaration(); 
        }
        setState(1814);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
      }
      setState(1815);
      statement_or_null();
      setState(1816);
      match(VerilogParser::ENDTASK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_item_declarationContext ------------------------------------------------------------------

VerilogParser::Task_item_declarationContext::Task_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Task_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_item_declarationContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_item_declarationContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_item_declaration;
}


std::any VerilogParser::Task_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_item_declarationContext* VerilogParser::task_item_declaration() {
  Task_item_declarationContext *_localctx = _tracker.createInstance<Task_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 178, VerilogParser::RuleTask_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1848);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1820);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1824);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1821);
        attribute_instance();
        setState(1826);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1827);
      tf_input_declaration();
      setState(1828);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1833);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1830);
        attribute_instance();
        setState(1835);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1836);
      tf_output_declaration();
      setState(1837);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1842);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1839);
        attribute_instance();
        setState(1844);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1845);
      tf_inout_declaration();
      setState(1846);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_listContext ------------------------------------------------------------------

VerilogParser::Task_port_listContext::Task_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Task_port_itemContext *> VerilogParser::Task_port_listContext::task_port_item() {
  return getRuleContexts<VerilogParser::Task_port_itemContext>();
}

VerilogParser::Task_port_itemContext* VerilogParser::Task_port_listContext::task_port_item(size_t i) {
  return getRuleContext<VerilogParser::Task_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_list;
}


std::any VerilogParser::Task_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_listContext* VerilogParser::task_port_list() {
  Task_port_listContext *_localctx = _tracker.createInstance<Task_port_listContext>(_ctx, getState());
  enterRule(_localctx, 180, VerilogParser::RuleTask_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1850);
    task_port_item();
    setState(1855);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1851);
      match(VerilogParser::CO);
      setState(1852);
      task_port_item();
      setState(1857);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_itemContext ------------------------------------------------------------------

VerilogParser::Task_port_itemContext::Task_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_port_itemContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_port_itemContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_item;
}


std::any VerilogParser::Task_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_itemContext* VerilogParser::task_port_item() {
  Task_port_itemContext *_localctx = _tracker.createInstance<Task_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 182, VerilogParser::RuleTask_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1879);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1861);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1858);
        attribute_instance();
        setState(1863);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1864);
      tf_input_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1868);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1865);
        attribute_instance();
        setState(1870);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1871);
      tf_output_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1875);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1872);
        attribute_instance();
        setState(1877);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1878);
      tf_inout_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_input_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_input_declarationContext::Tf_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_input_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_input_declaration;
}


std::any VerilogParser::Tf_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::tf_input_declaration() {
  Tf_input_declarationContext *_localctx = _tracker.createInstance<Tf_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 184, VerilogParser::RuleTf_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1896);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1881);
      match(VerilogParser::INPUT);
      setState(1883);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1882);
        match(VerilogParser::REG);
      }
      setState(1886);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1885);
        match(VerilogParser::SIGNED);
      }
      setState(1889);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1888);
        range_();
      }
      setState(1891);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1892);
      match(VerilogParser::INPUT);
      setState(1893);
      task_port_type();
      setState(1894);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_output_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_output_declarationContext::Tf_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_output_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_output_declaration;
}


std::any VerilogParser::Tf_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::tf_output_declaration() {
  Tf_output_declarationContext *_localctx = _tracker.createInstance<Tf_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 186, VerilogParser::RuleTf_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1913);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1898);
      match(VerilogParser::OUTPUT);
      setState(1900);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1899);
        match(VerilogParser::REG);
      }
      setState(1903);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1902);
        match(VerilogParser::SIGNED);
      }
      setState(1906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1905);
        range_();
      }
      setState(1908);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1909);
      match(VerilogParser::OUTPUT);
      setState(1910);
      task_port_type();
      setState(1911);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_inout_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_inout_declarationContext::Tf_inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_inout_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_inout_declaration;
}


std::any VerilogParser::Tf_inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_inout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::tf_inout_declaration() {
  Tf_inout_declarationContext *_localctx = _tracker.createInstance<Tf_inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 188, VerilogParser::RuleTf_inout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1930);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1915);
      match(VerilogParser::INOUT);
      setState(1917);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1916);
        match(VerilogParser::REG);
      }
      setState(1920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1919);
        match(VerilogParser::SIGNED);
      }
      setState(1923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1922);
        range_();
      }
      setState(1925);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1926);
      match(VerilogParser::INOUT);
      setState(1927);
      task_port_type();
      setState(1928);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_typeContext ------------------------------------------------------------------

VerilogParser::Task_port_typeContext::Task_port_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Task_port_typeContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_type;
}


std::any VerilogParser::Task_port_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_typeContext* VerilogParser::task_port_type() {
  Task_port_typeContext *_localctx = _tracker.createInstance<Task_port_typeContext>(_ctx, getState());
  enterRule(_localctx, 190, VerilogParser::RuleTask_port_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1932);
    _la = _input->LA(1);
    if (!(((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 18014411394383873) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_item_declarationContext ------------------------------------------------------------------

VerilogParser::Block_item_declarationContext::Block_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Block_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Block_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Block_item_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::Event_declarationContext* VerilogParser::Block_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Block_item_declarationContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Block_item_declarationContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}


size_t VerilogParser::Block_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_item_declaration;
}


std::any VerilogParser::Block_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_item_declarationContext* VerilogParser::block_item_declaration() {
  Block_item_declarationContext *_localctx = _tracker.createInstance<Block_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 192, VerilogParser::RuleBlock_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2015);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1937);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1934);
        attribute_instance();
        setState(1939);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1940);
      match(VerilogParser::REG);
      setState(1942);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1941);
        match(VerilogParser::SIGNED);
      }
      setState(1945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1944);
        range_();
      }
      setState(1947);
      list_of_block_variable_identifiers();
      setState(1948);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1953);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1950);
        attribute_instance();
        setState(1955);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1956);
      match(VerilogParser::INTEGER);
      setState(1957);
      list_of_block_variable_identifiers();
      setState(1958);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1963);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1960);
        attribute_instance();
        setState(1965);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1966);
      match(VerilogParser::TIME);
      setState(1967);
      list_of_block_variable_identifiers();
      setState(1968);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1973);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1970);
        attribute_instance();
        setState(1975);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1976);
      match(VerilogParser::REAL);
      setState(1977);
      list_of_block_real_identifiers();
      setState(1978);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1983);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1980);
        attribute_instance();
        setState(1985);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1986);
      match(VerilogParser::REALTIME);
      setState(1987);
      list_of_block_real_identifiers();
      setState(1988);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1993);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1990);
        attribute_instance();
        setState(1995);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1996);
      event_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2000);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1997);
        attribute_instance();
        setState(2002);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2003);
      local_parameter_declaration();
      setState(2004);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2009);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2006);
        attribute_instance();
        setState(2011);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2012);
      parameter_declaration();
      setState(2013);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_variable_identifiersContext::List_of_block_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_variable_typeContext *> VerilogParser::List_of_block_variable_identifiersContext::block_variable_type() {
  return getRuleContexts<VerilogParser::Block_variable_typeContext>();
}

VerilogParser::Block_variable_typeContext* VerilogParser::List_of_block_variable_identifiersContext::block_variable_type(size_t i) {
  return getRuleContext<VerilogParser::Block_variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_variable_identifiers;
}


std::any VerilogParser::List_of_block_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::list_of_block_variable_identifiers() {
  List_of_block_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_block_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 194, VerilogParser::RuleList_of_block_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2017);
    block_variable_type();
    setState(2022);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2018);
      match(VerilogParser::CO);
      setState(2019);
      block_variable_type();
      setState(2024);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_real_identifiersContext::List_of_block_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_real_typeContext *> VerilogParser::List_of_block_real_identifiersContext::block_real_type() {
  return getRuleContexts<VerilogParser::Block_real_typeContext>();
}

VerilogParser::Block_real_typeContext* VerilogParser::List_of_block_real_identifiersContext::block_real_type(size_t i) {
  return getRuleContext<VerilogParser::Block_real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_real_identifiers;
}


std::any VerilogParser::List_of_block_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::list_of_block_real_identifiers() {
  List_of_block_real_identifiersContext *_localctx = _tracker.createInstance<List_of_block_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 196, VerilogParser::RuleList_of_block_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2025);
    block_real_type();
    setState(2030);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2026);
      match(VerilogParser::CO);
      setState(2027);
      block_real_type();
      setState(2032);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_variable_typeContext ------------------------------------------------------------------

VerilogParser::Block_variable_typeContext::Block_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Block_variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_variable_type;
}


std::any VerilogParser::Block_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_variable_typeContext* VerilogParser::block_variable_type() {
  Block_variable_typeContext *_localctx = _tracker.createInstance<Block_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 198, VerilogParser::RuleBlock_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2033);
    variable_identifier();
    setState(2037);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2034);
      dimension();
      setState(2039);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_real_typeContext ------------------------------------------------------------------

VerilogParser::Block_real_typeContext::Block_real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Block_real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_real_type;
}


std::any VerilogParser::Block_real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_real_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_real_typeContext* VerilogParser::block_real_type() {
  Block_real_typeContext *_localctx = _tracker.createInstance<Block_real_typeContext>(_ctx, getState());
  enterRule(_localctx, 200, VerilogParser::RuleBlock_real_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2040);
    real_identifier();
    setState(2044);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2041);
      dimension();
      setState(2046);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instantiationContext ------------------------------------------------------------------

VerilogParser::Gate_instantiationContext::Gate_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::Gate_instantiationContext::cmos_switchtype() {
  return getRuleContext<VerilogParser::Cmos_switchtypeContext>(0);
}

std::vector<VerilogParser::Cmos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::cmos_switch_instance() {
  return getRuleContexts<VerilogParser::Cmos_switch_instanceContext>();
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::Gate_instantiationContext::cmos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Cmos_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Delay3Context* VerilogParser::Gate_instantiationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Gate_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::Gate_instantiationContext::enable_gatetype() {
  return getRuleContext<VerilogParser::Enable_gatetypeContext>(0);
}

std::vector<VerilogParser::Enable_gate_instanceContext *> VerilogParser::Gate_instantiationContext::enable_gate_instance() {
  return getRuleContexts<VerilogParser::Enable_gate_instanceContext>();
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::Gate_instantiationContext::enable_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Enable_gate_instanceContext>(i);
}

VerilogParser::Drive_strengthContext* VerilogParser::Gate_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::Gate_instantiationContext::mos_switchtype() {
  return getRuleContext<VerilogParser::Mos_switchtypeContext>(0);
}

std::vector<VerilogParser::Mos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::mos_switch_instance() {
  return getRuleContexts<VerilogParser::Mos_switch_instanceContext>();
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::Gate_instantiationContext::mos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Mos_switch_instanceContext>(i);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::Gate_instantiationContext::n_input_gatetype() {
  return getRuleContext<VerilogParser::N_input_gatetypeContext>(0);
}

std::vector<VerilogParser::N_input_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_input_gate_instance() {
  return getRuleContexts<VerilogParser::N_input_gate_instanceContext>();
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_input_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_input_gate_instanceContext>(i);
}

VerilogParser::Delay2Context* VerilogParser::Gate_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::Gate_instantiationContext::n_output_gatetype() {
  return getRuleContext<VerilogParser::N_output_gatetypeContext>(0);
}

std::vector<VerilogParser::N_output_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_output_gate_instance() {
  return getRuleContexts<VerilogParser::N_output_gate_instanceContext>();
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_output_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_output_gate_instanceContext>(i);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_en_switchtype() {
  return getRuleContext<VerilogParser::Pass_en_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_enable_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_enable_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_enable_switch_instanceContext>();
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_enable_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_enable_switch_instanceContext>(i);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_switchtype() {
  return getRuleContext<VerilogParser::Pass_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_switch_instanceContext>();
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLDOWN() {
  return getToken(VerilogParser::PULLDOWN, 0);
}

std::vector<VerilogParser::Pull_gate_instanceContext *> VerilogParser::Gate_instantiationContext::pull_gate_instance() {
  return getRuleContexts<VerilogParser::Pull_gate_instanceContext>();
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::Gate_instantiationContext::pull_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Pull_gate_instanceContext>(i);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::Gate_instantiationContext::pulldown_strength() {
  return getRuleContext<VerilogParser::Pulldown_strengthContext>(0);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLUP() {
  return getToken(VerilogParser::PULLUP, 0);
}

VerilogParser::Pullup_strengthContext* VerilogParser::Gate_instantiationContext::pullup_strength() {
  return getRuleContext<VerilogParser::Pullup_strengthContext>(0);
}


size_t VerilogParser::Gate_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instantiation;
}


std::any VerilogParser::Gate_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instantiationContext* VerilogParser::gate_instantiation() {
  Gate_instantiationContext *_localctx = _tracker.createInstance<Gate_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 202, VerilogParser::RuleGate_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2179);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CMOS:
      case VerilogParser::RCMOS: {
        enterOuterAlt(_localctx, 1);
        setState(2047);
        cmos_switchtype();
        setState(2049);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2048);
          delay3();
        }
        setState(2051);
        cmos_switch_instance();
        setState(2056);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2052);
          match(VerilogParser::CO);
          setState(2053);
          cmos_switch_instance();
          setState(2058);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2059);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO: {
        enterOuterAlt(_localctx, 2);
        setState(2061);
        enable_gatetype();
        setState(2063);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {
        case 1: {
          setState(2062);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2066);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2065);
          delay3();
        }
        setState(2068);
        enable_gate_instance();
        setState(2073);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2069);
          match(VerilogParser::CO);
          setState(2070);
          enable_gate_instance();
          setState(2075);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2076);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NMOS:
      case VerilogParser::PMOS:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS: {
        enterOuterAlt(_localctx, 3);
        setState(2078);
        mos_switchtype();
        setState(2080);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2079);
          delay3();
        }
        setState(2082);
        mos_switch_instance();
        setState(2087);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2083);
          match(VerilogParser::CO);
          setState(2084);
          mos_switch_instance();
          setState(2089);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2090);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::AND:
      case VerilogParser::NAND:
      case VerilogParser::NOR:
      case VerilogParser::OR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR: {
        enterOuterAlt(_localctx, 4);
        setState(2092);
        n_input_gatetype();
        setState(2094);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
        case 1: {
          setState(2093);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2097);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2096);
          delay2();
        }
        setState(2099);
        n_input_gate_instance();
        setState(2104);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2100);
          match(VerilogParser::CO);
          setState(2101);
          n_input_gate_instance();
          setState(2106);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2107);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUF:
      case VerilogParser::NOT: {
        enterOuterAlt(_localctx, 5);
        setState(2109);
        n_output_gatetype();
        setState(2111);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
        case 1: {
          setState(2110);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2114);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2113);
          delay2();
        }
        setState(2116);
        n_output_gate_instance();
        setState(2121);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2117);
          match(VerilogParser::CO);
          setState(2118);
          n_output_gate_instance();
          setState(2123);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2124);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO: {
        enterOuterAlt(_localctx, 6);
        setState(2126);
        pass_en_switchtype();
        setState(2128);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2127);
          delay2();
        }
        setState(2130);
        pass_enable_switch_instance();
        setState(2135);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2131);
          match(VerilogParser::CO);
          setState(2132);
          pass_enable_switch_instance();
          setState(2137);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2138);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRAN:
      case VerilogParser::TRAN: {
        enterOuterAlt(_localctx, 7);
        setState(2140);
        pass_switchtype();
        setState(2141);
        pass_switch_instance();
        setState(2146);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2142);
          match(VerilogParser::CO);
          setState(2143);
          pass_switch_instance();
          setState(2148);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2149);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLDOWN: {
        enterOuterAlt(_localctx, 8);
        setState(2151);
        match(VerilogParser::PULLDOWN);
        setState(2153);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
        case 1: {
          setState(2152);
          pulldown_strength();
          break;
        }

        default:
          break;
        }
        setState(2155);
        pull_gate_instance();
        setState(2160);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2156);
          match(VerilogParser::CO);
          setState(2157);
          pull_gate_instance();
          setState(2162);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2163);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLUP: {
        enterOuterAlt(_localctx, 9);
        setState(2165);
        match(VerilogParser::PULLUP);
        setState(2167);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
        case 1: {
          setState(2166);
          pullup_strength();
          break;
        }

        default:
          break;
        }
        setState(2169);
        pull_gate_instance();
        setState(2174);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2170);
          match(VerilogParser::CO);
          setState(2171);
          pull_gate_instance();
          setState(2176);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2177);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Cmos_switch_instanceContext::Cmos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Cmos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Cmos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Cmos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::ncontrol_terminal() {
  return getRuleContext<VerilogParser::Ncontrol_terminalContext>(0);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::pcontrol_terminal() {
  return getRuleContext<VerilogParser::Pcontrol_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Cmos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Cmos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switch_instance;
}


std::any VerilogParser::Cmos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::cmos_switch_instance() {
  Cmos_switch_instanceContext *_localctx = _tracker.createInstance<Cmos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 204, VerilogParser::RuleCmos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2182);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2181);
      name_of_gate_instance();
    }
    setState(2184);
    match(VerilogParser::LP);
    setState(2185);
    output_terminal();
    setState(2186);
    match(VerilogParser::CO);
    setState(2187);
    input_terminal();
    setState(2188);
    match(VerilogParser::CO);
    setState(2189);
    ncontrol_terminal();
    setState(2190);
    match(VerilogParser::CO);
    setState(2191);
    pcontrol_terminal();
    setState(2192);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Enable_gate_instanceContext::Enable_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Enable_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Enable_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Enable_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Enable_gate_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Enable_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Enable_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gate_instance;
}


std::any VerilogParser::Enable_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::enable_gate_instance() {
  Enable_gate_instanceContext *_localctx = _tracker.createInstance<Enable_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 206, VerilogParser::RuleEnable_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2195);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2194);
      name_of_gate_instance();
    }
    setState(2197);
    match(VerilogParser::LP);
    setState(2198);
    output_terminal();
    setState(2199);
    match(VerilogParser::CO);
    setState(2200);
    input_terminal();
    setState(2201);
    match(VerilogParser::CO);
    setState(2202);
    enable_terminal();
    setState(2203);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Mos_switch_instanceContext::Mos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Mos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Mos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Mos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Mos_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Mos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Mos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switch_instance;
}


std::any VerilogParser::Mos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::mos_switch_instance() {
  Mos_switch_instanceContext *_localctx = _tracker.createInstance<Mos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 208, VerilogParser::RuleMos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2206);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2205);
      name_of_gate_instance();
    }
    setState(2208);
    match(VerilogParser::LP);
    setState(2209);
    output_terminal();
    setState(2210);
    match(VerilogParser::CO);
    setState(2211);
    input_terminal();
    setState(2212);
    match(VerilogParser::CO);
    setState(2213);
    enable_terminal();
    setState(2214);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_input_gate_instanceContext::N_input_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::N_input_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::N_input_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::N_input_gate_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::N_input_gate_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_input_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_input_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gate_instance;
}


std::any VerilogParser::N_input_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::n_input_gate_instance() {
  N_input_gate_instanceContext *_localctx = _tracker.createInstance<N_input_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 210, VerilogParser::RuleN_input_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2217);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2216);
      name_of_gate_instance();
    }
    setState(2219);
    match(VerilogParser::LP);
    setState(2220);
    output_terminal();
    setState(2221);
    match(VerilogParser::CO);
    setState(2222);
    input_terminal();
    setState(2227);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2223);
      match(VerilogParser::CO);
      setState(2224);
      input_terminal();
      setState(2229);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2230);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_output_gate_instanceContext::N_output_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Output_terminalContext *> VerilogParser::N_output_gate_instanceContext::output_terminal() {
  return getRuleContexts<VerilogParser::Output_terminalContext>();
}

VerilogParser::Output_terminalContext* VerilogParser::N_output_gate_instanceContext::output_terminal(size_t i) {
  return getRuleContext<VerilogParser::Output_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::N_output_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::N_output_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_output_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_output_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gate_instance;
}


std::any VerilogParser::N_output_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::n_output_gate_instance() {
  N_output_gate_instanceContext *_localctx = _tracker.createInstance<N_output_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 212, VerilogParser::RuleN_output_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2233);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2232);
      name_of_gate_instance();
    }
    setState(2235);
    match(VerilogParser::LP);
    setState(2236);
    output_terminal();
    setState(2241);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2237);
        match(VerilogParser::CO);
        setState(2238);
        output_terminal(); 
      }
      setState(2243);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
    }
    setState(2244);
    match(VerilogParser::CO);
    setState(2245);
    input_terminal();
    setState(2246);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_switch_instanceContext::Pass_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_switch_instance;
}


std::any VerilogParser::Pass_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::pass_switch_instance() {
  Pass_switch_instanceContext *_localctx = _tracker.createInstance<Pass_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 214, VerilogParser::RulePass_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2249);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2248);
      name_of_gate_instance();
    }
    setState(2251);
    match(VerilogParser::LP);
    setState(2252);
    inout_terminal();
    setState(2253);
    match(VerilogParser::CO);
    setState(2254);
    inout_terminal();
    setState(2255);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_enable_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_enable_switch_instanceContext::Pass_enable_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_enable_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Pass_enable_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_enable_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_enable_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_enable_switch_instance;
}


std::any VerilogParser::Pass_enable_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_enable_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::pass_enable_switch_instance() {
  Pass_enable_switch_instanceContext *_localctx = _tracker.createInstance<Pass_enable_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 216, VerilogParser::RulePass_enable_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2258);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2257);
      name_of_gate_instance();
    }
    setState(2260);
    match(VerilogParser::LP);
    setState(2261);
    inout_terminal();
    setState(2262);
    match(VerilogParser::CO);
    setState(2263);
    inout_terminal();
    setState(2264);
    match(VerilogParser::CO);
    setState(2265);
    enable_terminal();
    setState(2266);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pull_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Pull_gate_instanceContext::Pull_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Pull_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pull_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pull_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePull_gate_instance;
}


std::any VerilogParser::Pull_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPull_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::pull_gate_instance() {
  Pull_gate_instanceContext *_localctx = _tracker.createInstance<Pull_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 218, VerilogParser::RulePull_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2268);
      name_of_gate_instance();
    }
    setState(2271);
    match(VerilogParser::LP);
    setState(2272);
    output_terminal();
    setState(2273);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_gate_instanceContext::Name_of_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::Name_of_gate_instanceContext::gate_instance_identifier() {
  return getRuleContext<VerilogParser::Gate_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_gate_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_gate_instance;
}


std::any VerilogParser::Name_of_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::name_of_gate_instance() {
  Name_of_gate_instanceContext *_localctx = _tracker.createInstance<Name_of_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 220, VerilogParser::RuleName_of_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2275);
    gate_instance_identifier();
    setState(2277);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2276);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulldown_strengthContext ------------------------------------------------------------------

VerilogParser::Pulldown_strengthContext::Pulldown_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pulldown_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pulldown_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pulldown_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePulldown_strength;
}


std::any VerilogParser::Pulldown_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulldown_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::pulldown_strength() {
  Pulldown_strengthContext *_localctx = _tracker.createInstance<Pulldown_strengthContext>(_ctx, getState());
  enterRule(_localctx, 222, VerilogParser::RulePulldown_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2295);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2279);
      match(VerilogParser::LP);
      setState(2280);
      strength0();
      setState(2281);
      match(VerilogParser::CO);
      setState(2282);
      strength1();
      setState(2283);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2285);
      match(VerilogParser::LP);
      setState(2286);
      strength1();
      setState(2287);
      match(VerilogParser::CO);
      setState(2288);
      strength0();
      setState(2289);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2291);
      match(VerilogParser::LP);
      setState(2292);
      strength0();
      setState(2293);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pullup_strengthContext ------------------------------------------------------------------

VerilogParser::Pullup_strengthContext::Pullup_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pullup_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pullup_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pullup_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePullup_strength;
}


std::any VerilogParser::Pullup_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPullup_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pullup_strengthContext* VerilogParser::pullup_strength() {
  Pullup_strengthContext *_localctx = _tracker.createInstance<Pullup_strengthContext>(_ctx, getState());
  enterRule(_localctx, 224, VerilogParser::RulePullup_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2313);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2297);
      match(VerilogParser::LP);
      setState(2298);
      strength0();
      setState(2299);
      match(VerilogParser::CO);
      setState(2300);
      strength1();
      setState(2301);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2303);
      match(VerilogParser::LP);
      setState(2304);
      strength1();
      setState(2305);
      match(VerilogParser::CO);
      setState(2306);
      strength0();
      setState(2307);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2309);
      match(VerilogParser::LP);
      setState(2310);
      strength1();
      setState(2311);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_terminalContext ------------------------------------------------------------------

VerilogParser::Enable_terminalContext::Enable_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Enable_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Enable_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_terminal;
}


std::any VerilogParser::Enable_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_terminalContext* VerilogParser::enable_terminal() {
  Enable_terminalContext *_localctx = _tracker.createInstance<Enable_terminalContext>(_ctx, getState());
  enterRule(_localctx, 226, VerilogParser::RuleEnable_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2315);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_terminalContext ------------------------------------------------------------------

VerilogParser::Inout_terminalContext::Inout_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Inout_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Inout_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInout_terminal;
}


std::any VerilogParser::Inout_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_terminalContext* VerilogParser::inout_terminal() {
  Inout_terminalContext *_localctx = _tracker.createInstance<Inout_terminalContext>(_ctx, getState());
  enterRule(_localctx, 228, VerilogParser::RuleInout_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2317);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_terminalContext ------------------------------------------------------------------

VerilogParser::Input_terminalContext::Input_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Input_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Input_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInput_terminal;
}


std::any VerilogParser::Input_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_terminalContext* VerilogParser::input_terminal() {
  Input_terminalContext *_localctx = _tracker.createInstance<Input_terminalContext>(_ctx, getState());
  enterRule(_localctx, 230, VerilogParser::RuleInput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2319);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ncontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Ncontrol_terminalContext::Ncontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ncontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ncontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleNcontrol_terminal;
}


std::any VerilogParser::Ncontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::ncontrol_terminal() {
  Ncontrol_terminalContext *_localctx = _tracker.createInstance<Ncontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 232, VerilogParser::RuleNcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2321);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_terminalContext ------------------------------------------------------------------

VerilogParser::Output_terminalContext::Output_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Output_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Output_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_terminal;
}


std::any VerilogParser::Output_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_terminalContext* VerilogParser::output_terminal() {
  Output_terminalContext *_localctx = _tracker.createInstance<Output_terminalContext>(_ctx, getState());
  enterRule(_localctx, 234, VerilogParser::RuleOutput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2323);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pcontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Pcontrol_terminalContext::Pcontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Pcontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Pcontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RulePcontrol_terminal;
}


std::any VerilogParser::Pcontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::pcontrol_terminal() {
  Pcontrol_terminalContext *_localctx = _tracker.createInstance<Pcontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 236, VerilogParser::RulePcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2325);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Cmos_switchtypeContext::Cmos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::CMOS() {
  return getToken(VerilogParser::CMOS, 0);
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::RCMOS() {
  return getToken(VerilogParser::RCMOS, 0);
}


size_t VerilogParser::Cmos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switchtype;
}


std::any VerilogParser::Cmos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::cmos_switchtype() {
  Cmos_switchtypeContext *_localctx = _tracker.createInstance<Cmos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 238, VerilogParser::RuleCmos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2327);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::CMOS || _la == VerilogParser::RCMOS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gatetypeContext ------------------------------------------------------------------

VerilogParser::Enable_gatetypeContext::Enable_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFZERO() {
  return getToken(VerilogParser::BUFIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFONE() {
  return getToken(VerilogParser::BUFIFONE, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFZERO() {
  return getToken(VerilogParser::NOTIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFONE() {
  return getToken(VerilogParser::NOTIFONE, 0);
}


size_t VerilogParser::Enable_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gatetype;
}


std::any VerilogParser::Enable_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::enable_gatetype() {
  Enable_gatetypeContext *_localctx = _tracker.createInstance<Enable_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 240, VerilogParser::RuleEnable_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2329);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUFIFONE

    || _la == VerilogParser::BUFIFZERO || _la == VerilogParser::NOTIFONE

    || _la == VerilogParser::NOTIFZERO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Mos_switchtypeContext::Mos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::NMOS() {
  return getToken(VerilogParser::NMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::PMOS() {
  return getToken(VerilogParser::PMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RNMOS() {
  return getToken(VerilogParser::RNMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RPMOS() {
  return getToken(VerilogParser::RPMOS, 0);
}


size_t VerilogParser::Mos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switchtype;
}


std::any VerilogParser::Mos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::mos_switchtype() {
  Mos_switchtypeContext *_localctx = _tracker.createInstance<Mos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 242, VerilogParser::RuleMos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2331);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 100664321) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_input_gatetypeContext::N_input_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::AND() {
  return getToken(VerilogParser::AND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NAND() {
  return getToken(VerilogParser::NAND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NOR() {
  return getToken(VerilogParser::NOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XOR() {
  return getToken(VerilogParser::XOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XNOR() {
  return getToken(VerilogParser::XNOR, 0);
}


size_t VerilogParser::N_input_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gatetype;
}


std::any VerilogParser::N_input_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::n_input_gatetype() {
  N_input_gatetypeContext *_localctx = _tracker.createInstance<N_input_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 244, VerilogParser::RuleN_input_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2333);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::AND || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & 265) != 0) || _la == VerilogParser::XNOR

    || _la == VerilogParser::XOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_output_gatetypeContext::N_output_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::BUF() {
  return getToken(VerilogParser::BUF, 0);
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::NOT() {
  return getToken(VerilogParser::NOT, 0);
}


size_t VerilogParser::N_output_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gatetype;
}


std::any VerilogParser::N_output_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::n_output_gatetype() {
  N_output_gatetypeContext *_localctx = _tracker.createInstance<N_output_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 246, VerilogParser::RuleN_output_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2335);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUF || _la == VerilogParser::NOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_en_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_en_switchtypeContext::Pass_en_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFZERO() {
  return getToken(VerilogParser::TRANIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFONE() {
  return getToken(VerilogParser::TRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFONE() {
  return getToken(VerilogParser::RTRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFZERO() {
  return getToken(VerilogParser::RTRANIFZERO, 0);
}


size_t VerilogParser::Pass_en_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_en_switchtype;
}


std::any VerilogParser::Pass_en_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_en_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::pass_en_switchtype() {
  Pass_en_switchtypeContext *_localctx = _tracker.createInstance<Pass_en_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 248, VerilogParser::RulePass_en_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2337);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 196611) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_switchtypeContext::Pass_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::TRAN() {
  return getToken(VerilogParser::TRAN, 0);
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::RTRAN() {
  return getToken(VerilogParser::RTRAN, 0);
}


size_t VerilogParser::Pass_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_switchtype;
}


std::any VerilogParser::Pass_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::pass_switchtype() {
  Pass_switchtypeContext *_localctx = _tracker.createInstance<Pass_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 250, VerilogParser::RulePass_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2339);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::RTRAN

    || _la == VerilogParser::TRAN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instantiationContext ------------------------------------------------------------------

VerilogParser::Module_instantiationContext::Module_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_identifierContext* VerilogParser::Module_instantiationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

std::vector<VerilogParser::Module_instanceContext *> VerilogParser::Module_instantiationContext::module_instance() {
  return getRuleContexts<VerilogParser::Module_instanceContext>();
}

VerilogParser::Module_instanceContext* VerilogParser::Module_instantiationContext::module_instance(size_t i) {
  return getRuleContext<VerilogParser::Module_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::Module_instantiationContext::parameter_value_assignment() {
  return getRuleContext<VerilogParser::Parameter_value_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instantiation;
}


std::any VerilogParser::Module_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instantiationContext* VerilogParser::module_instantiation() {
  Module_instantiationContext *_localctx = _tracker.createInstance<Module_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 252, VerilogParser::RuleModule_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2341);
    module_identifier();
    setState(2343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2342);
      parameter_value_assignment();
    }
    setState(2345);
    module_instance();
    setState(2350);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2346);
      match(VerilogParser::CO);
      setState(2347);
      module_instance();
      setState(2352);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2353);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_value_assignmentContext ------------------------------------------------------------------

VerilogParser::Parameter_value_assignmentContext::Parameter_value_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::Parameter_value_assignmentContext::list_of_parameter_assignments() {
  return getRuleContext<VerilogParser::List_of_parameter_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Parameter_value_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_value_assignment;
}


std::any VerilogParser::Parameter_value_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_value_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::parameter_value_assignment() {
  Parameter_value_assignmentContext *_localctx = _tracker.createInstance<Parameter_value_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 254, VerilogParser::RuleParameter_value_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2355);
    match(VerilogParser::HA);
    setState(2356);
    match(VerilogParser::LP);
    setState(2357);
    list_of_parameter_assignments();
    setState(2358);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_parameter_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_parameter_assignmentsContext::List_of_parameter_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment() {
  return getRuleContexts<VerilogParser::Ordered_parameter_assignmentContext>();
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Ordered_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_parameter_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_parameter_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment() {
  return getRuleContexts<VerilogParser::Named_parameter_assignmentContext>();
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Named_parameter_assignmentContext>(i);
}


size_t VerilogParser::List_of_parameter_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_parameter_assignments;
}


std::any VerilogParser::List_of_parameter_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_parameter_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::list_of_parameter_assignments() {
  List_of_parameter_assignmentsContext *_localctx = _tracker.createInstance<List_of_parameter_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 256, VerilogParser::RuleList_of_parameter_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2376);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(2360);
        ordered_parameter_assignment();
        setState(2365);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2361);
          match(VerilogParser::CO);
          setState(2362);
          ordered_parameter_assignment();
          setState(2367);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(2368);
        named_parameter_assignment();
        setState(2373);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2369);
          match(VerilogParser::CO);
          setState(2370);
          named_parameter_assignment();
          setState(2375);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Ordered_parameter_assignmentContext::Ordered_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_parameter_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_parameter_assignment;
}


std::any VerilogParser::Ordered_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::ordered_parameter_assignment() {
  Ordered_parameter_assignmentContext *_localctx = _tracker.createInstance<Ordered_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 258, VerilogParser::RuleOrdered_parameter_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2378);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Named_parameter_assignmentContext::Named_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Parameter_identifierContext* VerilogParser::Named_parameter_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Named_parameter_assignmentContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Named_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_parameter_assignment;
}


std::any VerilogParser::Named_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::named_parameter_assignment() {
  Named_parameter_assignmentContext *_localctx = _tracker.createInstance<Named_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 260, VerilogParser::RuleNamed_parameter_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2380);
    match(VerilogParser::DT);
    setState(2381);
    parameter_identifier();
    setState(2382);
    match(VerilogParser::LP);
    setState(2384);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(2383);
      mintypmax_expression();
    }
    setState(2386);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instanceContext ------------------------------------------------------------------

VerilogParser::Module_instanceContext::Module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::Module_instanceContext::name_of_module_instance() {
  return getRuleContext<VerilogParser::Name_of_module_instanceContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::Module_instanceContext::list_of_port_connections() {
  return getRuleContext<VerilogParser::List_of_port_connectionsContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance;
}


std::any VerilogParser::Module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instanceContext* VerilogParser::module_instance() {
  Module_instanceContext *_localctx = _tracker.createInstance<Module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 262, VerilogParser::RuleModule_instance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2388);
    name_of_module_instance();
    setState(2389);
    match(VerilogParser::LP);
    setState(2390);
    list_of_port_connections();
    setState(2391);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_module_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_module_instanceContext::Name_of_module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_instance_identifierContext* VerilogParser::Name_of_module_instanceContext::module_instance_identifier() {
  return getRuleContext<VerilogParser::Module_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_module_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_module_instance;
}


std::any VerilogParser::Name_of_module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_module_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::name_of_module_instance() {
  Name_of_module_instanceContext *_localctx = _tracker.createInstance<Name_of_module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 264, VerilogParser::RuleName_of_module_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2393);
    module_instance_identifier();
    setState(2395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2394);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_connectionsContext ------------------------------------------------------------------

VerilogParser::List_of_port_connectionsContext::List_of_port_connectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::ordered_port_connection() {
  return getRuleContexts<VerilogParser::Ordered_port_connectionContext>();
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::List_of_port_connectionsContext::ordered_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Ordered_port_connectionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_connectionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_connectionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::named_port_connection() {
  return getRuleContexts<VerilogParser::Named_port_connectionContext>();
}

VerilogParser::Named_port_connectionContext* VerilogParser::List_of_port_connectionsContext::named_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Named_port_connectionContext>(i);
}


size_t VerilogParser::List_of_port_connectionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_connections;
}


std::any VerilogParser::List_of_port_connectionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_connections(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::list_of_port_connections() {
  List_of_port_connectionsContext *_localctx = _tracker.createInstance<List_of_port_connectionsContext>(_ctx, getState());
  enterRule(_localctx, 266, VerilogParser::RuleList_of_port_connections);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2413);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2397);
      ordered_port_connection();
      setState(2402);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2398);
        match(VerilogParser::CO);
        setState(2399);
        ordered_port_connection();
        setState(2404);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2405);
      named_port_connection();
      setState(2410);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2406);
        match(VerilogParser::CO);
        setState(2407);
        named_port_connection();
        setState(2412);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_port_connectionContext ------------------------------------------------------------------

VerilogParser::Ordered_port_connectionContext::Ordered_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Ordered_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Ordered_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_port_connection;
}


std::any VerilogParser::Ordered_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::ordered_port_connection() {
  Ordered_port_connectionContext *_localctx = _tracker.createInstance<Ordered_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 268, VerilogParser::RuleOrdered_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2418);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2415);
        attribute_instance(); 
      }
      setState(2420);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
    }
    setState(2422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(2421);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_port_connectionContext ------------------------------------------------------------------

VerilogParser::Named_port_connectionContext::Named_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Named_port_connectionContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Named_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Named_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Named_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Named_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_port_connection;
}


std::any VerilogParser::Named_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_port_connectionContext* VerilogParser::named_port_connection() {
  Named_port_connectionContext *_localctx = _tracker.createInstance<Named_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 270, VerilogParser::RuleNamed_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2424);
      attribute_instance();
      setState(2429);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2430);
    match(VerilogParser::DT);
    setState(2431);
    port_identifier();
    setState(2432);
    match(VerilogParser::LP);
    setState(2434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(2433);
      expression(0);
    }
    setState(2436);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_regionContext ------------------------------------------------------------------

VerilogParser::Generate_regionContext::Generate_regionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_regionContext::GENERATE() {
  return getToken(VerilogParser::GENERATE, 0);
}

tree::TerminalNode* VerilogParser::Generate_regionContext::ENDGENERATE() {
  return getToken(VerilogParser::ENDGENERATE, 0);
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_regionContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_regionContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}


size_t VerilogParser::Generate_regionContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_region;
}


std::any VerilogParser::Generate_regionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_region(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_regionContext* VerilogParser::generate_region() {
  Generate_regionContext *_localctx = _tracker.createInstance<Generate_regionContext>(_ctx, getState());
  enterRule(_localctx, 272, VerilogParser::RuleGenerate_region);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2438);
    match(VerilogParser::GENERATE);
    setState(2442);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2470840122124411854) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7494165567648940639) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 562949953421343) != 0) || _la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2439);
      module_or_generate_item();
      setState(2444);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2445);
    match(VerilogParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_declarationContext ------------------------------------------------------------------

VerilogParser::Genvar_declarationContext::Genvar_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::GENVAR() {
  return getToken(VerilogParser::GENVAR, 0);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::Genvar_declarationContext::list_of_genvar_identifiers() {
  return getRuleContext<VerilogParser::List_of_genvar_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Genvar_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_declaration;
}


std::any VerilogParser::Genvar_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_declarationContext* VerilogParser::genvar_declaration() {
  Genvar_declarationContext *_localctx = _tracker.createInstance<Genvar_declarationContext>(_ctx, getState());
  enterRule(_localctx, 274, VerilogParser::RuleGenvar_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2447);
    match(VerilogParser::GENVAR);
    setState(2448);
    list_of_genvar_identifiers();
    setState(2449);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_genvar_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_genvar_identifiersContext::List_of_genvar_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Genvar_identifierContext *> VerilogParser::List_of_genvar_identifiersContext::genvar_identifier() {
  return getRuleContexts<VerilogParser::Genvar_identifierContext>();
}

VerilogParser::Genvar_identifierContext* VerilogParser::List_of_genvar_identifiersContext::genvar_identifier(size_t i) {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_genvar_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_genvar_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_genvar_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_genvar_identifiers;
}


std::any VerilogParser::List_of_genvar_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_genvar_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::list_of_genvar_identifiers() {
  List_of_genvar_identifiersContext *_localctx = _tracker.createInstance<List_of_genvar_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 276, VerilogParser::RuleList_of_genvar_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2451);
    genvar_identifier();
    setState(2456);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2452);
      match(VerilogParser::CO);
      setState(2453);
      genvar_identifier();
      setState(2458);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_generate_constructContext ------------------------------------------------------------------

VerilogParser::Loop_generate_constructContext::Loop_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Genvar_initializationContext* VerilogParser::Loop_generate_constructContext::genvar_initialization() {
  return getRuleContext<VerilogParser::Genvar_initializationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_generate_constructContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Loop_generate_constructContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}

VerilogParser::Genvar_iterationContext* VerilogParser::Loop_generate_constructContext::genvar_iteration() {
  return getRuleContext<VerilogParser::Genvar_iterationContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Generate_blockContext* VerilogParser::Loop_generate_constructContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}


size_t VerilogParser::Loop_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_generate_construct;
}


std::any VerilogParser::Loop_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::loop_generate_construct() {
  Loop_generate_constructContext *_localctx = _tracker.createInstance<Loop_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 278, VerilogParser::RuleLoop_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2459);
    match(VerilogParser::FOR);
    setState(2460);
    match(VerilogParser::LP);
    setState(2461);
    genvar_initialization();
    setState(2462);
    match(VerilogParser::SC);
    setState(2463);
    genvar_expression();
    setState(2464);
    match(VerilogParser::SC);
    setState(2465);
    genvar_iteration();
    setState(2466);
    match(VerilogParser::RP);
    setState(2467);
    generate_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_initializationContext ------------------------------------------------------------------

VerilogParser::Genvar_initializationContext::Genvar_initializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_initializationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_initializationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_initializationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_initializationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_initialization;
}


std::any VerilogParser::Genvar_initializationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_initialization(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_initializationContext* VerilogParser::genvar_initialization() {
  Genvar_initializationContext *_localctx = _tracker.createInstance<Genvar_initializationContext>(_ctx, getState());
  enterRule(_localctx, 280, VerilogParser::RuleGenvar_initialization);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2469);
    genvar_identifier();
    setState(2470);
    match(VerilogParser::EQ);
    setState(2471);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_expressionContext ------------------------------------------------------------------

VerilogParser::Genvar_expressionContext::Genvar_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_expression;
}


std::any VerilogParser::Genvar_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_expressionContext* VerilogParser::genvar_expression() {
  Genvar_expressionContext *_localctx = _tracker.createInstance<Genvar_expressionContext>(_ctx, getState());
  enterRule(_localctx, 282, VerilogParser::RuleGenvar_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2473);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_iterationContext ------------------------------------------------------------------

VerilogParser::Genvar_iterationContext::Genvar_iterationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_iterationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_iterationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Genvar_iterationContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}


size_t VerilogParser::Genvar_iterationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_iteration;
}


std::any VerilogParser::Genvar_iterationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_iteration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_iterationContext* VerilogParser::genvar_iteration() {
  Genvar_iterationContext *_localctx = _tracker.createInstance<Genvar_iterationContext>(_ctx, getState());
  enterRule(_localctx, 284, VerilogParser::RuleGenvar_iteration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2475);
    genvar_identifier();
    setState(2476);
    match(VerilogParser::EQ);
    setState(2477);
    genvar_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_generate_constructContext ------------------------------------------------------------------

VerilogParser::Conditional_generate_constructContext::Conditional_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::If_generate_constructContext* VerilogParser::Conditional_generate_constructContext::if_generate_construct() {
  return getRuleContext<VerilogParser::If_generate_constructContext>(0);
}

VerilogParser::Case_generate_constructContext* VerilogParser::Conditional_generate_constructContext::case_generate_construct() {
  return getRuleContext<VerilogParser::Case_generate_constructContext>(0);
}


size_t VerilogParser::Conditional_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_generate_construct;
}


std::any VerilogParser::Conditional_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::conditional_generate_construct() {
  Conditional_generate_constructContext *_localctx = _tracker.createInstance<Conditional_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 286, VerilogParser::RuleConditional_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2481);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(2479);
        if_generate_construct();
        break;
      }

      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(2480);
        case_generate_construct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_generate_constructContext ------------------------------------------------------------------

VerilogParser::If_generate_constructContext::If_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::If_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Generate_block_or_nullContext *> VerilogParser::If_generate_constructContext::generate_block_or_null() {
  return getRuleContexts<VerilogParser::Generate_block_or_nullContext>();
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::If_generate_constructContext::generate_block_or_null(size_t i) {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::If_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleIf_generate_construct;
}


std::any VerilogParser::If_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIf_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::If_generate_constructContext* VerilogParser::if_generate_construct() {
  If_generate_constructContext *_localctx = _tracker.createInstance<If_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 288, VerilogParser::RuleIf_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2483);
    match(VerilogParser::IF);
    setState(2484);
    match(VerilogParser::LP);
    setState(2485);
    constant_expression(0);
    setState(2486);
    match(VerilogParser::RP);
    setState(2487);
    generate_block_or_null();
    setState(2490);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      setState(2488);
      match(VerilogParser::ELSE);
      setState(2489);
      generate_block_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_constructContext ------------------------------------------------------------------

VerilogParser::Case_generate_constructContext::Case_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_generate_itemContext *> VerilogParser::Case_generate_constructContext::case_generate_item() {
  return getRuleContexts<VerilogParser::Case_generate_itemContext>();
}

VerilogParser::Case_generate_itemContext* VerilogParser::Case_generate_constructContext::case_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Case_generate_itemContext>(i);
}


size_t VerilogParser::Case_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_construct;
}


std::any VerilogParser::Case_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_constructContext* VerilogParser::case_generate_construct() {
  Case_generate_constructContext *_localctx = _tracker.createInstance<Case_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 290, VerilogParser::RuleCase_generate_construct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2492);
    match(VerilogParser::CASE);
    setState(2493);
    match(VerilogParser::LP);
    setState(2494);
    constant_expression(0);
    setState(2495);
    match(VerilogParser::RP);
    setState(2497); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2496);
      case_generate_item();
      setState(2499); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::DEFAULT || ((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0));
    setState(2501);
    match(VerilogParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_itemContext ------------------------------------------------------------------

VerilogParser::Case_generate_itemContext::Case_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Case_generate_itemContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_itemContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::Case_generate_itemContext::generate_block_or_null() {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_generate_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_item;
}


std::any VerilogParser::Case_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_itemContext* VerilogParser::case_generate_item() {
  Case_generate_itemContext *_localctx = _tracker.createInstance<Case_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 292, VerilogParser::RuleCase_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2519);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(2503);
        constant_expression(0);
        setState(2508);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2504);
          match(VerilogParser::CO);
          setState(2505);
          constant_expression(0);
          setState(2510);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2511);
        match(VerilogParser::CL);
        setState(2512);
        generate_block_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(2514);
        match(VerilogParser::DEFAULT);
        setState(2516);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2515);
          match(VerilogParser::CL);
        }
        setState(2518);
        generate_block_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_blockContext ------------------------------------------------------------------

VerilogParser::Generate_blockContext::Generate_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_blockContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_blockContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Generate_block_nameContext* VerilogParser::Generate_blockContext::generate_block_name() {
  return getRuleContext<VerilogParser::Generate_block_nameContext>(0);
}


size_t VerilogParser::Generate_blockContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block;
}


std::any VerilogParser::Generate_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_blockContext* VerilogParser::generate_block() {
  Generate_blockContext *_localctx = _tracker.createInstance<Generate_blockContext>(_ctx, getState());
  enterRule(_localctx, 294, VerilogParser::RuleGenerate_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2533);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ANALOG:
      case VerilogParser::LP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2521);
        module_or_generate_item();
        break;
      }

      case VerilogParser::BEGIN: {
        enterOuterAlt(_localctx, 2);
        setState(2522);
        match(VerilogParser::BEGIN);
        setState(2524);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2523);
          generate_block_name();
        }
        setState(2529);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2470840122124411854) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & -7494165567648940639) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 133)) & 562949953421343) != 0) || _la == VerilogParser::ESCAPED_IDENTIFIER

        || _la == VerilogParser::SIMPLE_IDENTIFIER) {
          setState(2526);
          module_or_generate_item();
          setState(2531);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2532);
        match(VerilogParser::END);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_nameContext ------------------------------------------------------------------

VerilogParser::Generate_block_nameContext::Generate_block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::Generate_block_nameContext::generate_block_identifier() {
  return getRuleContext<VerilogParser::Generate_block_identifierContext>(0);
}


size_t VerilogParser::Generate_block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_name;
}


std::any VerilogParser::Generate_block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_nameContext* VerilogParser::generate_block_name() {
  Generate_block_nameContext *_localctx = _tracker.createInstance<Generate_block_nameContext>(_ctx, getState());
  enterRule(_localctx, 296, VerilogParser::RuleGenerate_block_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2535);
    match(VerilogParser::CL);
    setState(2536);
    generate_block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_or_nullContext ------------------------------------------------------------------

VerilogParser::Generate_block_or_nullContext::Generate_block_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Generate_blockContext* VerilogParser::Generate_block_or_nullContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}

tree::TerminalNode* VerilogParser::Generate_block_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Generate_block_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_or_null;
}


std::any VerilogParser::Generate_block_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::generate_block_or_null() {
  Generate_block_or_nullContext *_localctx = _tracker.createInstance<Generate_block_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 298, VerilogParser::RuleGenerate_block_or_null);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2540);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BEGIN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ANALOG:
      case VerilogParser::LP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2538);
        generate_block();
        break;
      }

      case VerilogParser::SC: {
        enterOuterAlt(_localctx, 2);
        setState(2539);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_declarationContext::Udp_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::PRIMITIVE() {
  return getToken(VerilogParser::PRIMITIVE, 0);
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_declarationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Udp_port_listContext* VerilogParser::Udp_declarationContext::udp_port_list() {
  return getRuleContext<VerilogParser::Udp_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_bodyContext* VerilogParser::Udp_declarationContext::udp_body() {
  return getRuleContext<VerilogParser::Udp_bodyContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::ENDPRIMITIVE() {
  return getToken(VerilogParser::ENDPRIMITIVE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Udp_port_declarationContext *> VerilogParser::Udp_declarationContext::udp_port_declaration() {
  return getRuleContexts<VerilogParser::Udp_port_declarationContext>();
}

VerilogParser::Udp_port_declarationContext* VerilogParser::Udp_declarationContext::udp_port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_port_declarationContext>(i);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::Udp_declarationContext::udp_declaration_port_list() {
  return getRuleContext<VerilogParser::Udp_declaration_port_listContext>(0);
}


size_t VerilogParser::Udp_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration;
}


std::any VerilogParser::Udp_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declarationContext* VerilogParser::udp_declaration() {
  Udp_declarationContext *_localctx = _tracker.createInstance<Udp_declarationContext>(_ctx, getState());
  enterRule(_localctx, 300, VerilogParser::RuleUdp_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2577);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2545);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2542);
        attribute_instance();
        setState(2547);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2548);
      match(VerilogParser::PRIMITIVE);
      setState(2549);
      udp_identifier();
      setState(2550);
      match(VerilogParser::LP);
      setState(2551);
      udp_port_list();
      setState(2552);
      match(VerilogParser::RP);
      setState(2553);
      match(VerilogParser::SC);
      setState(2555); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2554);
        udp_port_declaration();
        setState(2557); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 59) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 59)) & 68721573889) != 0) || _la == VerilogParser::LP);
      setState(2559);
      udp_body();
      setState(2560);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2565);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2562);
        attribute_instance();
        setState(2567);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2568);
      match(VerilogParser::PRIMITIVE);
      setState(2569);
      udp_identifier();
      setState(2570);
      match(VerilogParser::LP);
      setState(2571);
      udp_declaration_port_list();
      setState(2572);
      match(VerilogParser::RP);
      setState(2573);
      match(VerilogParser::SC);
      setState(2574);
      udp_body();
      setState(2575);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_port_listContext::Udp_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_port_listContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_port_identifierContext *> VerilogParser::Udp_port_listContext::input_port_identifier() {
  return getRuleContexts<VerilogParser::Input_port_identifierContext>();
}

VerilogParser::Input_port_identifierContext* VerilogParser::Udp_port_listContext::input_port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Input_port_identifierContext>(i);
}


size_t VerilogParser::Udp_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_list;
}


std::any VerilogParser::Udp_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_listContext* VerilogParser::udp_port_list() {
  Udp_port_listContext *_localctx = _tracker.createInstance<Udp_port_listContext>(_ctx, getState());
  enterRule(_localctx, 302, VerilogParser::RuleUdp_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2579);
    output_port_identifier();
    setState(2580);
    match(VerilogParser::CO);
    setState(2581);
    input_port_identifier();
    setState(2586);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2582);
      match(VerilogParser::CO);
      setState(2583);
      input_port_identifier();
      setState(2588);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declaration_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_declaration_port_listContext::Udp_declaration_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_declaration_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_declaration_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Udp_input_declarationContext *> VerilogParser::Udp_declaration_port_listContext::udp_input_declaration() {
  return getRuleContexts<VerilogParser::Udp_input_declarationContext>();
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_input_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(i);
}


size_t VerilogParser::Udp_declaration_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration_port_list;
}


std::any VerilogParser::Udp_declaration_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::udp_declaration_port_list() {
  Udp_declaration_port_listContext *_localctx = _tracker.createInstance<Udp_declaration_port_listContext>(_ctx, getState());
  enterRule(_localctx, 304, VerilogParser::RuleUdp_declaration_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2589);
    udp_output_declaration();
    setState(2590);
    match(VerilogParser::CO);
    setState(2591);
    udp_input_declaration();
    setState(2596);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2592);
      match(VerilogParser::CO);
      setState(2593);
      udp_input_declaration();
      setState(2598);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_port_declarationContext::Udp_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_port_declarationContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_port_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_port_declarationContext::udp_input_declaration() {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(0);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::Udp_port_declarationContext::udp_reg_declaration() {
  return getRuleContext<VerilogParser::Udp_reg_declarationContext>(0);
}


size_t VerilogParser::Udp_port_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_declaration;
}


std::any VerilogParser::Udp_port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_declarationContext* VerilogParser::udp_port_declaration() {
  Udp_port_declarationContext *_localctx = _tracker.createInstance<Udp_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 306, VerilogParser::RuleUdp_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2608);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2599);
      udp_output_declaration();
      setState(2600);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2602);
      udp_input_declaration();
      setState(2603);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2605);
      udp_reg_declaration();
      setState(2606);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_output_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_output_declarationContext::Udp_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Udp_output_declarationContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_output_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_output_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Udp_output_declarationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Udp_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_output_declaration;
}


std::any VerilogParser::Udp_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_output_declarationContext* VerilogParser::udp_output_declaration() {
  Udp_output_declarationContext *_localctx = _tracker.createInstance<Udp_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 308, VerilogParser::RuleUdp_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2631);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2613);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2610);
        attribute_instance();
        setState(2615);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2616);
      match(VerilogParser::OUTPUT);
      setState(2617);
      port_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2621);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2618);
        attribute_instance();
        setState(2623);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2624);
      match(VerilogParser::OUTPUT);
      setState(2625);
      match(VerilogParser::REG);
      setState(2626);
      port_identifier();
      setState(2629);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::EQ) {
        setState(2627);
        match(VerilogParser::EQ);
        setState(2628);
        constant_expression(0);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_input_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_input_declarationContext::Udp_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Udp_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_input_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_input_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_input_declaration;
}


std::any VerilogParser::Udp_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::udp_input_declaration() {
  Udp_input_declarationContext *_localctx = _tracker.createInstance<Udp_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 310, VerilogParser::RuleUdp_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2636);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2633);
      attribute_instance();
      setState(2638);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2639);
    match(VerilogParser::INPUT);
    setState(2640);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_reg_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_reg_declarationContext::Udp_reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::Variable_identifierContext* VerilogParser::Udp_reg_declarationContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_reg_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_reg_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_reg_declaration;
}


std::any VerilogParser::Udp_reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_reg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::udp_reg_declaration() {
  Udp_reg_declarationContext *_localctx = _tracker.createInstance<Udp_reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 312, VerilogParser::RuleUdp_reg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2645);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2642);
      attribute_instance();
      setState(2647);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2648);
    match(VerilogParser::REG);
    setState(2649);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_bodyContext ------------------------------------------------------------------

VerilogParser::Udp_bodyContext::Udp_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Combinational_bodyContext* VerilogParser::Udp_bodyContext::combinational_body() {
  return getRuleContext<VerilogParser::Combinational_bodyContext>(0);
}

VerilogParser::Sequential_bodyContext* VerilogParser::Udp_bodyContext::sequential_body() {
  return getRuleContext<VerilogParser::Sequential_bodyContext>(0);
}


size_t VerilogParser::Udp_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_body;
}


std::any VerilogParser::Udp_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_bodyContext* VerilogParser::udp_body() {
  Udp_bodyContext *_localctx = _tracker.createInstance<Udp_bodyContext>(_ctx, getState());
  enterRule(_localctx, 314, VerilogParser::RuleUdp_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2653);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2651);
      combinational_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2652);
      sequential_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_bodyContext ------------------------------------------------------------------

VerilogParser::Combinational_bodyContext::Combinational_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

std::vector<VerilogParser::Combinational_entryContext *> VerilogParser::Combinational_bodyContext::combinational_entry() {
  return getRuleContexts<VerilogParser::Combinational_entryContext>();
}

VerilogParser::Combinational_entryContext* VerilogParser::Combinational_bodyContext::combinational_entry(size_t i) {
  return getRuleContext<VerilogParser::Combinational_entryContext>(i);
}


size_t VerilogParser::Combinational_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_body;
}


std::any VerilogParser::Combinational_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_bodyContext* VerilogParser::combinational_body() {
  Combinational_bodyContext *_localctx = _tracker.createInstance<Combinational_bodyContext>(_ctx, getState());
  enterRule(_localctx, 316, VerilogParser::RuleCombinational_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2655);
    match(VerilogParser::TABLE);
    setState(2657); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2656);
      combinational_entry();
      setState(2659); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
    setState(2661);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_entryContext ------------------------------------------------------------------

VerilogParser::Combinational_entryContext::Combinational_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Combinational_entryContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Output_symbolContext* VerilogParser::Combinational_entryContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Combinational_entryContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_entry;
}


std::any VerilogParser::Combinational_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_entryContext* VerilogParser::combinational_entry() {
  Combinational_entryContext *_localctx = _tracker.createInstance<Combinational_entryContext>(_ctx, getState());
  enterRule(_localctx, 318, VerilogParser::RuleCombinational_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2663);
    level_input_list();
    setState(2664);
    match(VerilogParser::CL);
    setState(2665);
    output_symbol();
    setState(2666);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_bodyContext ------------------------------------------------------------------

VerilogParser::Sequential_bodyContext::Sequential_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::Sequential_bodyContext::udp_initial_statement() {
  return getRuleContext<VerilogParser::Udp_initial_statementContext>(0);
}

std::vector<VerilogParser::Sequential_entryContext *> VerilogParser::Sequential_bodyContext::sequential_entry() {
  return getRuleContexts<VerilogParser::Sequential_entryContext>();
}

VerilogParser::Sequential_entryContext* VerilogParser::Sequential_bodyContext::sequential_entry(size_t i) {
  return getRuleContext<VerilogParser::Sequential_entryContext>(i);
}


size_t VerilogParser::Sequential_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_body;
}


std::any VerilogParser::Sequential_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_bodyContext* VerilogParser::sequential_body() {
  Sequential_bodyContext *_localctx = _tracker.createInstance<Sequential_bodyContext>(_ctx, getState());
  enterRule(_localctx, 320, VerilogParser::RuleSequential_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2669);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::INITIAL) {
      setState(2668);
      udp_initial_statement();
    }
    setState(2671);
    match(VerilogParser::TABLE);
    setState(2673); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2672);
      sequential_entry();
      setState(2675); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 182) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 182)) & 120259084289) != 0));
    setState(2677);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_initial_statementContext ------------------------------------------------------------------

VerilogParser::Udp_initial_statementContext::Udp_initial_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_initial_statementContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Init_valContext* VerilogParser::Udp_initial_statementContext::init_val() {
  return getRuleContext<VerilogParser::Init_valContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Udp_initial_statementContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_initial_statement;
}


std::any VerilogParser::Udp_initial_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_initial_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::udp_initial_statement() {
  Udp_initial_statementContext *_localctx = _tracker.createInstance<Udp_initial_statementContext>(_ctx, getState());
  enterRule(_localctx, 322, VerilogParser::RuleUdp_initial_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2679);
    match(VerilogParser::INITIAL);
    setState(2680);
    output_port_identifier();
    setState(2681);
    match(VerilogParser::EQ);
    setState(2682);
    init_val();
    setState(2683);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Init_valContext ------------------------------------------------------------------

VerilogParser::Init_valContext::Init_valContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Init_valContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Init_valContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Init_valContext::getRuleIndex() const {
  return VerilogParser::RuleInit_val;
}


std::any VerilogParser::Init_valContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInit_val(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Init_valContext* VerilogParser::init_val() {
  Init_valContext *_localctx = _tracker.createInstance<Init_valContext>(_ctx, getState());
  enterRule(_localctx, 324, VerilogParser::RuleInit_val);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2687);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2685);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2686);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_entryContext ------------------------------------------------------------------

VerilogParser::Sequential_entryContext::Sequential_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Seq_input_listContext* VerilogParser::Sequential_entryContext::seq_input_list() {
  return getRuleContext<VerilogParser::Seq_input_listContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sequential_entryContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}

VerilogParser::Current_stateContext* VerilogParser::Sequential_entryContext::current_state() {
  return getRuleContext<VerilogParser::Current_stateContext>(0);
}

VerilogParser::Next_stateContext* VerilogParser::Sequential_entryContext::next_state() {
  return getRuleContext<VerilogParser::Next_stateContext>(0);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Sequential_entryContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_entry;
}


std::any VerilogParser::Sequential_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_entryContext* VerilogParser::sequential_entry() {
  Sequential_entryContext *_localctx = _tracker.createInstance<Sequential_entryContext>(_ctx, getState());
  enterRule(_localctx, 326, VerilogParser::RuleSequential_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2689);
    seq_input_list();
    setState(2690);
    match(VerilogParser::CL);
    setState(2691);
    current_state();
    setState(2692);
    match(VerilogParser::CL);
    setState(2693);
    next_state();
    setState(2694);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_input_listContext ------------------------------------------------------------------

VerilogParser::Seq_input_listContext::Seq_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Seq_input_listContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

VerilogParser::Edge_input_listContext* VerilogParser::Seq_input_listContext::edge_input_list() {
  return getRuleContext<VerilogParser::Edge_input_listContext>(0);
}


size_t VerilogParser::Seq_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_input_list;
}


std::any VerilogParser::Seq_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_input_listContext* VerilogParser::seq_input_list() {
  Seq_input_listContext *_localctx = _tracker.createInstance<Seq_input_listContext>(_ctx, getState());
  enterRule(_localctx, 328, VerilogParser::RuleSeq_input_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2698);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2696);
      level_input_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2697);
      edge_input_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_input_listContext ------------------------------------------------------------------

VerilogParser::Level_input_listContext::Level_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Level_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Level_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Level_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_input_list;
}


std::any VerilogParser::Level_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_input_listContext* VerilogParser::level_input_list() {
  Level_input_listContext *_localctx = _tracker.createInstance<Level_input_listContext>(_ctx, getState());
  enterRule(_localctx, 330, VerilogParser::RuleLevel_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2701); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2700);
      level_symbol();
      setState(2703); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_input_listContext ------------------------------------------------------------------

VerilogParser::Edge_input_listContext::Edge_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Edge_indicatorContext* VerilogParser::Edge_input_listContext::edge_indicator() {
  return getRuleContext<VerilogParser::Edge_indicatorContext>(0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Edge_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_input_list;
}


std::any VerilogParser::Edge_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_input_listContext* VerilogParser::edge_input_list() {
  Edge_input_listContext *_localctx = _tracker.createInstance<Edge_input_listContext>(_ctx, getState());
  enterRule(_localctx, 332, VerilogParser::RuleEdge_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2708);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2705);
      level_symbol();
      setState(2710);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2711);
    edge_indicator();
    setState(2715);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2712);
      level_symbol();
      setState(2717);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_indicatorContext ------------------------------------------------------------------

VerilogParser::Edge_indicatorContext::Edge_indicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_indicatorContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_indicatorContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Edge_symbolContext* VerilogParser::Edge_indicatorContext::edge_symbol() {
  return getRuleContext<VerilogParser::Edge_symbolContext>(0);
}


size_t VerilogParser::Edge_indicatorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_indicator;
}


std::any VerilogParser::Edge_indicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_indicator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_indicatorContext* VerilogParser::edge_indicator() {
  Edge_indicatorContext *_localctx = _tracker.createInstance<Edge_indicatorContext>(_ctx, getState());
  enterRule(_localctx, 334, VerilogParser::RuleEdge_indicator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2724);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 1);
        setState(2718);
        match(VerilogParser::LP);
        setState(2719);
        level_symbol();
        setState(2720);
        level_symbol();
        setState(2721);
        match(VerilogParser::RP);
        break;
      }

      case VerilogParser::EDGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2723);
        edge_symbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Current_stateContext ------------------------------------------------------------------

VerilogParser::Current_stateContext::Current_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_symbolContext* VerilogParser::Current_stateContext::level_symbol() {
  return getRuleContext<VerilogParser::Level_symbolContext>(0);
}


size_t VerilogParser::Current_stateContext::getRuleIndex() const {
  return VerilogParser::RuleCurrent_state;
}


std::any VerilogParser::Current_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCurrent_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Current_stateContext* VerilogParser::current_state() {
  Current_stateContext *_localctx = _tracker.createInstance<Current_stateContext>(_ctx, getState());
  enterRule(_localctx, 336, VerilogParser::RuleCurrent_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2726);
    level_symbol();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_stateContext ------------------------------------------------------------------

VerilogParser::Next_stateContext::Next_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_symbolContext* VerilogParser::Next_stateContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Next_stateContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Next_stateContext::getRuleIndex() const {
  return VerilogParser::RuleNext_state;
}


std::any VerilogParser::Next_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNext_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Next_stateContext* VerilogParser::next_state() {
  Next_stateContext *_localctx = _tracker.createInstance<Next_stateContext>(_ctx, getState());
  enterRule(_localctx, 338, VerilogParser::RuleNext_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2730);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::OUTPUT_OR_LEVEL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2728);
        output_symbol();
        break;
      }

      case VerilogParser::MI: {
        enterOuterAlt(_localctx, 2);
        setState(2729);
        match(VerilogParser::MI);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_symbolContext ------------------------------------------------------------------

VerilogParser::Output_symbolContext::Output_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Output_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_symbol;
}


std::any VerilogParser::Output_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_symbolContext* VerilogParser::output_symbol() {
  Output_symbolContext *_localctx = _tracker.createInstance<Output_symbolContext>(_ctx, getState());
  enterRule(_localctx, 340, VerilogParser::RuleOutput_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2732);
    match(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_symbolContext ------------------------------------------------------------------

VerilogParser::Level_symbolContext::Level_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Level_symbolContext::LEVEL_ONLY_SYMBOL() {
  return getToken(VerilogParser::LEVEL_ONLY_SYMBOL, 0);
}

tree::TerminalNode* VerilogParser::Level_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Level_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_symbol;
}


std::any VerilogParser::Level_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_symbolContext* VerilogParser::level_symbol() {
  Level_symbolContext *_localctx = _tracker.createInstance<Level_symbolContext>(_ctx, getState());
  enterRule(_localctx, 342, VerilogParser::RuleLevel_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2734);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_symbolContext ------------------------------------------------------------------

VerilogParser::Edge_symbolContext::Edge_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_symbolContext::EDGE_SYMBOL() {
  return getToken(VerilogParser::EDGE_SYMBOL, 0);
}


size_t VerilogParser::Edge_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_symbol;
}


std::any VerilogParser::Edge_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_symbolContext* VerilogParser::edge_symbol() {
  Edge_symbolContext *_localctx = _tracker.createInstance<Edge_symbolContext>(_ctx, getState());
  enterRule(_localctx, 344, VerilogParser::RuleEdge_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2736);
    match(VerilogParser::EDGE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instantiationContext ------------------------------------------------------------------

VerilogParser::Udp_instantiationContext::Udp_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_instantiationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

std::vector<VerilogParser::Udp_instanceContext *> VerilogParser::Udp_instantiationContext::udp_instance() {
  return getRuleContexts<VerilogParser::Udp_instanceContext>();
}

VerilogParser::Udp_instanceContext* VerilogParser::Udp_instantiationContext::udp_instance(size_t i) {
  return getRuleContext<VerilogParser::Udp_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Udp_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay2Context* VerilogParser::Udp_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Udp_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instantiation;
}


std::any VerilogParser::Udp_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instantiationContext* VerilogParser::udp_instantiation() {
  Udp_instantiationContext *_localctx = _tracker.createInstance<Udp_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 346, VerilogParser::RuleUdp_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2738);
    udp_identifier();
    setState(2740);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
    case 1: {
      setState(2739);
      drive_strength();
      break;
    }

    default:
      break;
    }
    setState(2743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2742);
      delay2();
    }
    setState(2745);
    udp_instance();
    setState(2750);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2746);
      match(VerilogParser::CO);
      setState(2747);
      udp_instance();
      setState(2752);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2753);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instanceContext ------------------------------------------------------------------

VerilogParser::Udp_instanceContext::Udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Udp_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::Udp_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::Udp_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::Udp_instanceContext::name_of_udp_instance() {
  return getRuleContext<VerilogParser::Name_of_udp_instanceContext>(0);
}


size_t VerilogParser::Udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance;
}


std::any VerilogParser::Udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instanceContext* VerilogParser::udp_instance() {
  Udp_instanceContext *_localctx = _tracker.createInstance<Udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 348, VerilogParser::RuleUdp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2756);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2755);
      name_of_udp_instance();
    }
    setState(2758);
    match(VerilogParser::LP);
    setState(2759);
    output_terminal();
    setState(2760);
    match(VerilogParser::CO);
    setState(2761);
    input_terminal();
    setState(2766);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2762);
      match(VerilogParser::CO);
      setState(2763);
      input_terminal();
      setState(2768);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2769);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_udp_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_udp_instanceContext::Name_of_udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::Name_of_udp_instanceContext::udp_instance_identifier() {
  return getRuleContext<VerilogParser::Udp_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_udp_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_udp_instance;
}


std::any VerilogParser::Name_of_udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_udp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::name_of_udp_instance() {
  Name_of_udp_instanceContext *_localctx = _tracker.createInstance<Name_of_udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 350, VerilogParser::RuleName_of_udp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2771);
    udp_instance_identifier();
    setState(2773);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2772);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continuous_assignContext ------------------------------------------------------------------

VerilogParser::Continuous_assignContext::Continuous_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::Continuous_assignContext::list_of_net_assignments() {
  return getRuleContext<VerilogParser::List_of_net_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Continuous_assignContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay3Context* VerilogParser::Continuous_assignContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}


size_t VerilogParser::Continuous_assignContext::getRuleIndex() const {
  return VerilogParser::RuleContinuous_assign;
}


std::any VerilogParser::Continuous_assignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitContinuous_assign(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Continuous_assignContext* VerilogParser::continuous_assign() {
  Continuous_assignContext *_localctx = _tracker.createInstance<Continuous_assignContext>(_ctx, getState());
  enterRule(_localctx, 352, VerilogParser::RuleContinuous_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2775);
    match(VerilogParser::ASSIGN);
    setState(2777);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(2776);
      drive_strength();
    }
    setState(2780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2779);
      delay3();
    }
    setState(2782);
    list_of_net_assignments();
    setState(2783);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_assignmentsContext::List_of_net_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_assignmentContext *> VerilogParser::List_of_net_assignmentsContext::net_assignment() {
  return getRuleContexts<VerilogParser::Net_assignmentContext>();
}

VerilogParser::Net_assignmentContext* VerilogParser::List_of_net_assignmentsContext::net_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_assignments;
}


std::any VerilogParser::List_of_net_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::list_of_net_assignments() {
  List_of_net_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 354, VerilogParser::RuleList_of_net_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2785);
    net_assignment();
    setState(2790);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2786);
      match(VerilogParser::CO);
      setState(2787);
      net_assignment();
      setState(2792);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_assignmentContext::Net_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_assignmentContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Net_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_assignment;
}


std::any VerilogParser::Net_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_assignmentContext* VerilogParser::net_assignment() {
  Net_assignmentContext *_localctx = _tracker.createInstance<Net_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 356, VerilogParser::RuleNet_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2793);
    net_lvalue();
    setState(2794);
    match(VerilogParser::EQ);
    setState(2795);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_constructContext ------------------------------------------------------------------

VerilogParser::Initial_constructContext::Initial_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Initial_constructContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::StatementContext* VerilogParser::Initial_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Initial_constructContext::getRuleIndex() const {
  return VerilogParser::RuleInitial_construct;
}


std::any VerilogParser::Initial_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInitial_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Initial_constructContext* VerilogParser::initial_construct() {
  Initial_constructContext *_localctx = _tracker.createInstance<Initial_constructContext>(_ctx, getState());
  enterRule(_localctx, 358, VerilogParser::RuleInitial_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2797);
    match(VerilogParser::INITIAL);
    setState(2798);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Always_constructContext ------------------------------------------------------------------

VerilogParser::Always_constructContext::Always_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Always_constructContext::ALWAYS() {
  return getToken(VerilogParser::ALWAYS, 0);
}

VerilogParser::StatementContext* VerilogParser::Always_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Always_constructContext::getRuleIndex() const {
  return VerilogParser::RuleAlways_construct;
}


std::any VerilogParser::Always_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAlways_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Always_constructContext* VerilogParser::always_construct() {
  Always_constructContext *_localctx = _tracker.createInstance<Always_constructContext>(_ctx, getState());
  enterRule(_localctx, 360, VerilogParser::RuleAlways_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2800);
    match(VerilogParser::ALWAYS);
    setState(2801);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analog_constructContext ------------------------------------------------------------------

VerilogParser::Analog_constructContext::Analog_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Analog_constructContext::ANALOG() {
  return getToken(VerilogParser::ANALOG, 0);
}

VerilogParser::StatementContext* VerilogParser::Analog_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Analog_constructContext::getRuleIndex() const {
  return VerilogParser::RuleAnalog_construct;
}


std::any VerilogParser::Analog_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAnalog_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Analog_constructContext* VerilogParser::analog_construct() {
  Analog_constructContext *_localctx = _tracker.createInstance<Analog_constructContext>(_ctx, getState());
  enterRule(_localctx, 362, VerilogParser::RuleAnalog_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2803);
    match(VerilogParser::ANALOG);
    setState(2804);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Blocking_assignmentContext::Blocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Blocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Blocking_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Blocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Blocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Blocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleBlocking_assignment;
}


std::any VerilogParser::Blocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Blocking_assignmentContext* VerilogParser::blocking_assignment() {
  Blocking_assignmentContext *_localctx = _tracker.createInstance<Blocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 364, VerilogParser::RuleBlocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2806);
    variable_lvalue();
    setState(2807);
    match(VerilogParser::EQ);
    setState(2809);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2808);
      delay_or_event_control();
    }
    setState(2811);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonblocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Nonblocking_assignmentContext::Nonblocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Nonblocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Nonblocking_assignmentContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Nonblocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Nonblocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Nonblocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNonblocking_assignment;
}


std::any VerilogParser::Nonblocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNonblocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::nonblocking_assignment() {
  Nonblocking_assignmentContext *_localctx = _tracker.createInstance<Nonblocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 366, VerilogParser::RuleNonblocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2813);
    variable_lvalue();
    setState(2814);
    match(VerilogParser::LTEQ);
    setState(2816);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2815);
      delay_or_event_control();
    }
    setState(2818);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analog_assignmentContext ------------------------------------------------------------------

VerilogParser::Analog_assignmentContext::Analog_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Function_callContext* VerilogParser::Analog_assignmentContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Analog_assignmentContext::LTPL() {
  return getToken(VerilogParser::LTPL, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Analog_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Analog_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Analog_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleAnalog_assignment;
}


std::any VerilogParser::Analog_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAnalog_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Analog_assignmentContext* VerilogParser::analog_assignment() {
  Analog_assignmentContext *_localctx = _tracker.createInstance<Analog_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 368, VerilogParser::RuleAnalog_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2820);
    function_call();
    setState(2821);
    match(VerilogParser::LTPL);
    setState(2823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2822);
      delay_or_event_control();
    }
    setState(2825);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_continuous_assignmentsContext ------------------------------------------------------------------

VerilogParser::Procedural_continuous_assignmentsContext::Procedural_continuous_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::Variable_assignmentContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_assignment() {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::DEASSIGN() {
  return getToken(VerilogParser::DEASSIGN, 0);
}

VerilogParser::Variable_lvalueContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::FORCE() {
  return getToken(VerilogParser::FORCE, 0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::RELEASE() {
  return getToken(VerilogParser::RELEASE, 0);
}


size_t VerilogParser::Procedural_continuous_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_continuous_assignments;
}


std::any VerilogParser::Procedural_continuous_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_continuous_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::procedural_continuous_assignments() {
  Procedural_continuous_assignmentsContext *_localctx = _tracker.createInstance<Procedural_continuous_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 370, VerilogParser::RuleProcedural_continuous_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2835);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ASSIGN: {
        enterOuterAlt(_localctx, 1);
        setState(2827);
        match(VerilogParser::ASSIGN);
        setState(2828);
        variable_assignment();
        break;
      }

      case VerilogParser::DEASSIGN: {
        enterOuterAlt(_localctx, 2);
        setState(2829);
        match(VerilogParser::DEASSIGN);
        setState(2830);
        variable_lvalue();
        break;
      }

      case VerilogParser::FORCE: {
        enterOuterAlt(_localctx, 3);
        setState(2831);
        match(VerilogParser::FORCE);
        setState(2832);
        variable_assignment();
        break;
      }

      case VerilogParser::RELEASE: {
        enterOuterAlt(_localctx, 4);
        setState(2833);
        match(VerilogParser::RELEASE);
        setState(2834);
        variable_lvalue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_assignmentContext ------------------------------------------------------------------

VerilogParser::Variable_assignmentContext::Variable_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Variable_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Variable_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Variable_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_assignment;
}


std::any VerilogParser::Variable_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_assignmentContext* VerilogParser::variable_assignment() {
  Variable_assignmentContext *_localctx = _tracker.createInstance<Variable_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 372, VerilogParser::RuleVariable_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2837);
    variable_lvalue();
    setState(2838);
    match(VerilogParser::EQ);
    setState(2839);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Par_blockContext ------------------------------------------------------------------

VerilogParser::Par_blockContext::Par_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Par_blockContext::FORK() {
  return getToken(VerilogParser::FORK, 0);
}

tree::TerminalNode* VerilogParser::Par_blockContext::JOIN() {
  return getToken(VerilogParser::JOIN, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Par_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Par_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Par_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Par_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Par_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Par_blockContext::getRuleIndex() const {
  return VerilogParser::RulePar_block;
}


std::any VerilogParser::Par_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPar_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Par_blockContext* VerilogParser::par_block() {
  Par_blockContext *_localctx = _tracker.createInstance<Par_blockContext>(_ctx, getState());
  enterRule(_localctx, 374, VerilogParser::RulePar_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2841);
    match(VerilogParser::FORK);
    setState(2849);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2842);
      block_name();
      setState(2846);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2843);
          block_item_declaration(); 
        }
        setState(2848);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
      }
    }
    setState(2854);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18542164091375144) != 0) || ((((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 9007272269185027) != 0) || ((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 688268535809) != 0)) {
      setState(2851);
      statement();
      setState(2856);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2857);
    match(VerilogParser::JOIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_nameContext ------------------------------------------------------------------

VerilogParser::Block_nameContext::Block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Block_identifierContext* VerilogParser::Block_nameContext::block_identifier() {
  return getRuleContext<VerilogParser::Block_identifierContext>(0);
}


size_t VerilogParser::Block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_name;
}


std::any VerilogParser::Block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_nameContext* VerilogParser::block_name() {
  Block_nameContext *_localctx = _tracker.createInstance<Block_nameContext>(_ctx, getState());
  enterRule(_localctx, 376, VerilogParser::RuleBlock_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2859);
    match(VerilogParser::CL);
    setState(2860);
    block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_blockContext ------------------------------------------------------------------

VerilogParser::Seq_blockContext::Seq_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Seq_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Seq_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Seq_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Seq_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Seq_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Seq_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Seq_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Seq_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_block;
}


std::any VerilogParser::Seq_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_blockContext* VerilogParser::seq_block() {
  Seq_blockContext *_localctx = _tracker.createInstance<Seq_blockContext>(_ctx, getState());
  enterRule(_localctx, 378, VerilogParser::RuleSeq_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2862);
    match(VerilogParser::BEGIN);
    setState(2870);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2863);
      block_name();
      setState(2867);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2864);
          block_item_declaration(); 
        }
        setState(2869);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx);
      }
    }
    setState(2875);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18542164091375144) != 0) || ((((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 9007272269185027) != 0) || ((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 688268535809) != 0)) {
      setState(2872);
      statement();
      setState(2877);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2878);
    match(VerilogParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

VerilogParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Blocking_assignmentContext* VerilogParser::StatementContext::blocking_assignment() {
  return getRuleContext<VerilogParser::Blocking_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::StatementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::StatementContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::StatementContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Case_statementContext* VerilogParser::StatementContext::case_statement() {
  return getRuleContext<VerilogParser::Case_statementContext>(0);
}

VerilogParser::Conditional_statementContext* VerilogParser::StatementContext::conditional_statement() {
  return getRuleContext<VerilogParser::Conditional_statementContext>(0);
}

VerilogParser::Disable_statementContext* VerilogParser::StatementContext::disable_statement() {
  return getRuleContext<VerilogParser::Disable_statementContext>(0);
}

VerilogParser::Event_triggerContext* VerilogParser::StatementContext::event_trigger() {
  return getRuleContext<VerilogParser::Event_triggerContext>(0);
}

VerilogParser::Loop_statementContext* VerilogParser::StatementContext::loop_statement() {
  return getRuleContext<VerilogParser::Loop_statementContext>(0);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::StatementContext::nonblocking_assignment() {
  return getRuleContext<VerilogParser::Nonblocking_assignmentContext>(0);
}

VerilogParser::Analog_assignmentContext* VerilogParser::StatementContext::analog_assignment() {
  return getRuleContext<VerilogParser::Analog_assignmentContext>(0);
}

VerilogParser::Par_blockContext* VerilogParser::StatementContext::par_block() {
  return getRuleContext<VerilogParser::Par_blockContext>(0);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::StatementContext::procedural_continuous_assignments() {
  return getRuleContext<VerilogParser::Procedural_continuous_assignmentsContext>(0);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::StatementContext::procedural_timing_control_statement() {
  return getRuleContext<VerilogParser::Procedural_timing_control_statementContext>(0);
}

VerilogParser::Seq_blockContext* VerilogParser::StatementContext::seq_block() {
  return getRuleContext<VerilogParser::Seq_blockContext>(0);
}

VerilogParser::System_task_enableContext* VerilogParser::StatementContext::system_task_enable() {
  return getRuleContext<VerilogParser::System_task_enableContext>(0);
}

VerilogParser::Task_enableContext* VerilogParser::StatementContext::task_enable() {
  return getRuleContext<VerilogParser::Task_enableContext>(0);
}

VerilogParser::Wait_statementContext* VerilogParser::StatementContext::wait_statement() {
  return getRuleContext<VerilogParser::Wait_statementContext>(0);
}


size_t VerilogParser::StatementContext::getRuleIndex() const {
  return VerilogParser::RuleStatement;
}


std::any VerilogParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::StatementContext* VerilogParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 380, VerilogParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2993);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2883);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2880);
        attribute_instance();
        setState(2885);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2886);
      blocking_assignment();
      setState(2887);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2892);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2889);
        attribute_instance();
        setState(2894);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2895);
      case_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2899);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2896);
        attribute_instance();
        setState(2901);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2902);
      conditional_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2906);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2903);
        attribute_instance();
        setState(2908);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2909);
      disable_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2913);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2910);
        attribute_instance();
        setState(2915);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2916);
      event_trigger();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2920);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2917);
        attribute_instance();
        setState(2922);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2923);
      loop_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2927);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2924);
        attribute_instance();
        setState(2929);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2930);
      nonblocking_assignment();
      setState(2931);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2936);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2933);
        attribute_instance();
        setState(2938);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2939);
      analog_assignment();
      setState(2940);
      match(VerilogParser::SC);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2945);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2942);
        attribute_instance();
        setState(2947);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2948);
      par_block();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2952);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2949);
        attribute_instance();
        setState(2954);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2955);
      procedural_continuous_assignments();
      setState(2956);
      match(VerilogParser::SC);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2961);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2958);
        attribute_instance();
        setState(2963);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2964);
      procedural_timing_control_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2968);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2965);
        attribute_instance();
        setState(2970);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2971);
      seq_block();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2975);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2972);
        attribute_instance();
        setState(2977);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2978);
      system_task_enable();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2982);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2979);
        attribute_instance();
        setState(2984);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2985);
      task_enable();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2989);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2986);
        attribute_instance();
        setState(2991);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2992);
      wait_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_or_nullContext ------------------------------------------------------------------

VerilogParser::Statement_or_nullContext::Statement_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Statement_or_nullContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Statement_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Statement_or_nullContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Statement_or_nullContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Statement_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleStatement_or_null;
}


std::any VerilogParser::Statement_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Statement_or_nullContext* VerilogParser::statement_or_null() {
  Statement_or_nullContext *_localctx = _tracker.createInstance<Statement_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 382, VerilogParser::RuleStatement_or_null);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3003);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2995);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2999);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2996);
        attribute_instance();
        setState(3001);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3002);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_statementContext ------------------------------------------------------------------

VerilogParser::Function_statementContext::Function_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Function_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Function_statementContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_statement;
}


std::any VerilogParser::Function_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_statementContext* VerilogParser::function_statement() {
  Function_statementContext *_localctx = _tracker.createInstance<Function_statementContext>(_ctx, getState());
  enterRule(_localctx, 384, VerilogParser::RuleFunction_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3005);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_controlContext ------------------------------------------------------------------

VerilogParser::Delay_controlContext::Delay_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay_controlContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay_controlContext::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay_controlContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_control;
}


std::any VerilogParser::Delay_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_controlContext* VerilogParser::delay_control() {
  Delay_controlContext *_localctx = _tracker.createInstance<Delay_controlContext>(_ctx, getState());
  enterRule(_localctx, 386, VerilogParser::RuleDelay_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3014);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3007);
      match(VerilogParser::HA);
      setState(3008);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3009);
      match(VerilogParser::HA);
      setState(3010);
      match(VerilogParser::LP);
      setState(3011);
      mintypmax_expression();
      setState(3012);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_or_event_controlContext ------------------------------------------------------------------

VerilogParser::Delay_or_event_controlContext::Delay_or_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Delay_or_event_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Delay_or_event_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Delay_or_event_controlContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_or_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_or_event_control;
}


std::any VerilogParser::Delay_or_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_or_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::delay_or_event_control() {
  Delay_or_event_controlContext *_localctx = _tracker.createInstance<Delay_or_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 388, VerilogParser::RuleDelay_or_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3024);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(3016);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(3017);
        event_control();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 3);
        setState(3018);
        match(VerilogParser::REPEAT);
        setState(3019);
        match(VerilogParser::LP);
        setState(3020);
        expression(0);
        setState(3021);
        match(VerilogParser::RP);
        setState(3022);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Disable_statementContext ------------------------------------------------------------------

VerilogParser::Disable_statementContext::Disable_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Disable_statementContext::DISABLE() {
  return getToken(VerilogParser::DISABLE, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Disable_statementContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Disable_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Disable_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDisable_statement;
}


std::any VerilogParser::Disable_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDisable_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Disable_statementContext* VerilogParser::disable_statement() {
  Disable_statementContext *_localctx = _tracker.createInstance<Disable_statementContext>(_ctx, getState());
  enterRule(_localctx, 390, VerilogParser::RuleDisable_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3026);
    match(VerilogParser::DISABLE);
    setState(3027);
    hierarchical_identifier();
    setState(3028);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_controlContext ------------------------------------------------------------------

VerilogParser::Event_controlContext::Event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_controlContext::AT() {
  return getToken(VerilogParser::AT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_controlContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Event_expressionContext* VerilogParser::Event_controlContext::event_expression() {
  return getRuleContext<VerilogParser::Event_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::AS() {
  return getToken(VerilogParser::AS, 0);
}


size_t VerilogParser::Event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_control;
}


std::any VerilogParser::Event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_controlContext* VerilogParser::event_control() {
  Event_controlContext *_localctx = _tracker.createInstance<Event_controlContext>(_ctx, getState());
  enterRule(_localctx, 392, VerilogParser::RuleEvent_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3043);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3030);
      match(VerilogParser::AT);
      setState(3031);
      hierarchical_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3032);
      match(VerilogParser::AT);
      setState(3033);
      match(VerilogParser::LP);
      setState(3034);
      event_expression(0);
      setState(3035);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3037);
      match(VerilogParser::AT);
      setState(3038);
      match(VerilogParser::AS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3039);
      match(VerilogParser::AT);
      setState(3040);
      match(VerilogParser::LP);
      setState(3041);
      match(VerilogParser::AS);
      setState(3042);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_triggerContext ------------------------------------------------------------------

VerilogParser::Event_triggerContext::Event_triggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_triggerContext::MIGT() {
  return getToken(VerilogParser::MIGT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_triggerContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_triggerContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Event_triggerContext::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Event_triggerContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_trigger;
}


std::any VerilogParser::Event_triggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_triggerContext* VerilogParser::event_trigger() {
  Event_triggerContext *_localctx = _tracker.createInstance<Event_triggerContext>(_ctx, getState());
  enterRule(_localctx, 394, VerilogParser::RuleEvent_trigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3045);
    match(VerilogParser::MIGT);
    setState(3046);
    hierarchical_identifier();
    setState(3048);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3047);
      bit_select();
    }
    setState(3050);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_expressionContext ------------------------------------------------------------------

VerilogParser::Event_expressionContext::Event_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Event_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

std::vector<VerilogParser::Event_expressionContext *> VerilogParser::Event_expressionContext::event_expression() {
  return getRuleContexts<VerilogParser::Event_expressionContext>();
}

VerilogParser::Event_expressionContext* VerilogParser::Event_expressionContext::event_expression(size_t i) {
  return getRuleContext<VerilogParser::Event_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Event_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_expression;
}


std::any VerilogParser::Event_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Event_expressionContext* VerilogParser::event_expression() {
   return event_expression(0);
}

VerilogParser::Event_expressionContext* VerilogParser::event_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Event_expressionContext *_localctx = _tracker.createInstance<Event_expressionContext>(_ctx, parentState);
  VerilogParser::Event_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 396;
  enterRecursionRule(_localctx, 396, VerilogParser::RuleEvent_expression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3058);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(3053);
        expression(0);
        break;
      }

      case VerilogParser::POSEDGE: {
        setState(3054);
        match(VerilogParser::POSEDGE);
        setState(3055);
        expression(0);
        break;
      }

      case VerilogParser::NEGEDGE: {
        setState(3056);
        match(VerilogParser::NEGEDGE);
        setState(3057);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(3068);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(3066);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3060);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(3061);
          match(VerilogParser::OR);
          setState(3062);
          event_expression(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3063);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(3064);
          match(VerilogParser::CO);
          setState(3065);
          event_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(3070);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Procedural_timing_controlContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_controlContext::Procedural_timing_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Procedural_timing_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Procedural_timing_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}


size_t VerilogParser::Procedural_timing_controlContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control;
}


std::any VerilogParser::Procedural_timing_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::procedural_timing_control() {
  Procedural_timing_controlContext *_localctx = _tracker.createInstance<Procedural_timing_controlContext>(_ctx, getState());
  enterRule(_localctx, 398, VerilogParser::RuleProcedural_timing_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3073);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(3071);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(3072);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_timing_control_statementContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_control_statementContext::Procedural_timing_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::Procedural_timing_control_statementContext::procedural_timing_control() {
  return getRuleContext<VerilogParser::Procedural_timing_controlContext>(0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Procedural_timing_control_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Procedural_timing_control_statementContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control_statement;
}


std::any VerilogParser::Procedural_timing_control_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::procedural_timing_control_statement() {
  Procedural_timing_control_statementContext *_localctx = _tracker.createInstance<Procedural_timing_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 400, VerilogParser::RuleProcedural_timing_control_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3075);
    procedural_timing_control();
    setState(3076);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wait_statementContext ------------------------------------------------------------------

VerilogParser::Wait_statementContext::Wait_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Wait_statementContext::WAIT() {
  return getToken(VerilogParser::WAIT, 0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Wait_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Wait_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Wait_statementContext::getRuleIndex() const {
  return VerilogParser::RuleWait_statement;
}


std::any VerilogParser::Wait_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWait_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Wait_statementContext* VerilogParser::wait_statement() {
  Wait_statementContext *_localctx = _tracker.createInstance<Wait_statementContext>(_ctx, getState());
  enterRule(_localctx, 402, VerilogParser::RuleWait_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3078);
    match(VerilogParser::WAIT);
    setState(3079);
    match(VerilogParser::LP);
    setState(3080);
    expression(0);
    setState(3081);
    match(VerilogParser::RP);
    setState(3082);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_statementContext ------------------------------------------------------------------

VerilogParser::Conditional_statementContext::Conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Conditional_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Statement_or_nullContext *> VerilogParser::Conditional_statementContext::statement_or_null() {
  return getRuleContexts<VerilogParser::Statement_or_nullContext>();
}

VerilogParser::Statement_or_nullContext* VerilogParser::Conditional_statementContext::statement_or_null(size_t i) {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::Conditional_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_statement;
}


std::any VerilogParser::Conditional_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_statementContext* VerilogParser::conditional_statement() {
  Conditional_statementContext *_localctx = _tracker.createInstance<Conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 404, VerilogParser::RuleConditional_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3084);
    match(VerilogParser::IF);
    setState(3085);
    match(VerilogParser::LP);
    setState(3086);
    expression(0);
    setState(3087);
    match(VerilogParser::RP);
    setState(3088);
    statement_or_null();
    setState(3091);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      setState(3089);
      match(VerilogParser::ELSE);
      setState(3090);
      statement_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_statementContext ------------------------------------------------------------------

VerilogParser::Case_statementContext::Case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Case_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_itemContext *> VerilogParser::Case_statementContext::case_item() {
  return getRuleContexts<VerilogParser::Case_itemContext>();
}

VerilogParser::Case_itemContext* VerilogParser::Case_statementContext::case_item(size_t i) {
  return getRuleContext<VerilogParser::Case_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEZ() {
  return getToken(VerilogParser::CASEZ, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEX() {
  return getToken(VerilogParser::CASEX, 0);
}


size_t VerilogParser::Case_statementContext::getRuleIndex() const {
  return VerilogParser::RuleCase_statement;
}


std::any VerilogParser::Case_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_statementContext* VerilogParser::case_statement() {
  Case_statementContext *_localctx = _tracker.createInstance<Case_statementContext>(_ctx, getState());
  enterRule(_localctx, 406, VerilogParser::RuleCase_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3126);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(3093);
        match(VerilogParser::CASE);
        setState(3094);
        match(VerilogParser::LP);
        setState(3095);
        expression(0);
        setState(3096);
        match(VerilogParser::RP);
        setState(3098); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3097);
          case_item();
          setState(3100); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 156) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 156)) & 8847496634181345) != 0));
        setState(3102);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEZ: {
        enterOuterAlt(_localctx, 2);
        setState(3104);
        match(VerilogParser::CASEZ);
        setState(3105);
        match(VerilogParser::LP);
        setState(3106);
        expression(0);
        setState(3107);
        match(VerilogParser::RP);
        setState(3109); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3108);
          case_item();
          setState(3111); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 156) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 156)) & 8847496634181345) != 0));
        setState(3113);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEX: {
        enterOuterAlt(_localctx, 3);
        setState(3115);
        match(VerilogParser::CASEX);
        setState(3116);
        match(VerilogParser::LP);
        setState(3117);
        expression(0);
        setState(3118);
        match(VerilogParser::RP);
        setState(3120); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3119);
          case_item();
          setState(3122); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 156) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 156)) & 8847496634181345) != 0));
        setState(3124);
        match(VerilogParser::ENDCASE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_itemContext ------------------------------------------------------------------

VerilogParser::Case_itemContext::Case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Case_itemContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Case_itemContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Case_itemContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_item;
}


std::any VerilogParser::Case_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_itemContext* VerilogParser::case_item() {
  Case_itemContext *_localctx = _tracker.createInstance<Case_itemContext>(_ctx, getState());
  enterRule(_localctx, 408, VerilogParser::RuleCase_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3144);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3128);
        expression(0);
        setState(3133);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(3129);
          match(VerilogParser::CO);
          setState(3130);
          expression(0);
          setState(3135);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3136);
        match(VerilogParser::CL);
        setState(3137);
        statement_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(3139);
        match(VerilogParser::DEFAULT);
        setState(3141);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(3140);
          match(VerilogParser::CL);
        }
        setState(3143);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statementContext ------------------------------------------------------------------

VerilogParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOREVER() {
  return getToken(VerilogParser::FOREVER, 0);
}

VerilogParser::StatementContext* VerilogParser::Loop_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Loop_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::WHILE() {
  return getToken(VerilogParser::WHILE, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

std::vector<VerilogParser::Variable_assignmentContext *> VerilogParser::Loop_statementContext::variable_assignment() {
  return getRuleContexts<VerilogParser::Variable_assignmentContext>();
}

VerilogParser::Variable_assignmentContext* VerilogParser::Loop_statementContext::variable_assignment(size_t i) {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_statementContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}


size_t VerilogParser::Loop_statementContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_statement;
}


std::any VerilogParser::Loop_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_statementContext* VerilogParser::loop_statement() {
  Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 410, VerilogParser::RuleLoop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3170);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FOREVER: {
        enterOuterAlt(_localctx, 1);
        setState(3146);
        match(VerilogParser::FOREVER);
        setState(3147);
        statement();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 2);
        setState(3148);
        match(VerilogParser::REPEAT);
        setState(3149);
        match(VerilogParser::LP);
        setState(3150);
        expression(0);
        setState(3151);
        match(VerilogParser::RP);
        setState(3152);
        statement();
        break;
      }

      case VerilogParser::WHILE: {
        enterOuterAlt(_localctx, 3);
        setState(3154);
        match(VerilogParser::WHILE);
        setState(3155);
        match(VerilogParser::LP);
        setState(3156);
        expression(0);
        setState(3157);
        match(VerilogParser::RP);
        setState(3158);
        statement();
        break;
      }

      case VerilogParser::FOR: {
        enterOuterAlt(_localctx, 4);
        setState(3160);
        match(VerilogParser::FOR);
        setState(3161);
        match(VerilogParser::LP);
        setState(3162);
        variable_assignment();
        setState(3163);
        match(VerilogParser::SC);
        setState(3164);
        expression(0);
        setState(3165);
        match(VerilogParser::SC);
        setState(3166);
        variable_assignment();
        setState(3167);
        match(VerilogParser::RP);
        setState(3168);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_enableContext ------------------------------------------------------------------

VerilogParser::System_task_enableContext::System_task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_task_identifierContext* VerilogParser::System_task_enableContext::system_task_identifier() {
  return getRuleContext<VerilogParser::System_task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::System_task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::System_task_enableContext::sys_task_en_port_list() {
  return getRuleContext<VerilogParser::Sys_task_en_port_listContext>(0);
}


size_t VerilogParser::System_task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_enable;
}


std::any VerilogParser::System_task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_enableContext* VerilogParser::system_task_enable() {
  System_task_enableContext *_localctx = _tracker.createInstance<System_task_enableContext>(_ctx, getState());
  enterRule(_localctx, 412, VerilogParser::RuleSystem_task_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3172);
    system_task_identifier();
    setState(3174);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3173);
      sys_task_en_port_list();
    }
    setState(3176);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_listContext::Sys_task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Sys_task_en_port_itemContext *> VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item() {
  return getRuleContexts<VerilogParser::Sys_task_en_port_itemContext>();
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item(size_t i) {
  return getRuleContext<VerilogParser::Sys_task_en_port_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_list;
}


std::any VerilogParser::Sys_task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::sys_task_en_port_list() {
  Sys_task_en_port_listContext *_localctx = _tracker.createInstance<Sys_task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 414, VerilogParser::RuleSys_task_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3178);
    match(VerilogParser::LP);
    setState(3179);
    sys_task_en_port_item();
    setState(3184);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3180);
      match(VerilogParser::CO);
      setState(3181);
      sys_task_en_port_item();
      setState(3186);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3187);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_itemContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_itemContext::Sys_task_en_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Sys_task_en_port_itemContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Sys_task_en_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_item;
}


std::any VerilogParser::Sys_task_en_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::sys_task_en_port_item() {
  Sys_task_en_port_itemContext *_localctx = _tracker.createInstance<Sys_task_en_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 416, VerilogParser::RuleSys_task_en_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(3189);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_enableContext ------------------------------------------------------------------

VerilogParser::Task_enableContext::Task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Task_enableContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Task_en_port_listContext* VerilogParser::Task_enableContext::task_en_port_list() {
  return getRuleContext<VerilogParser::Task_en_port_listContext>(0);
}


size_t VerilogParser::Task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleTask_enable;
}


std::any VerilogParser::Task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_enableContext* VerilogParser::task_enable() {
  Task_enableContext *_localctx = _tracker.createInstance<Task_enableContext>(_ctx, getState());
  enterRule(_localctx, 418, VerilogParser::RuleTask_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3192);
    hierarchical_identifier();
    setState(3194);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3193);
      task_en_port_list();
    }
    setState(3196);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Task_en_port_listContext::Task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Task_en_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Task_en_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_en_port_list;
}


std::any VerilogParser::Task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_en_port_listContext* VerilogParser::task_en_port_list() {
  Task_en_port_listContext *_localctx = _tracker.createInstance<Task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 420, VerilogParser::RuleTask_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3198);
    match(VerilogParser::LP);
    setState(3199);
    expression(0);
    setState(3204);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3200);
      match(VerilogParser::CO);
      setState(3201);
      expression(0);
      setState(3206);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3207);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_blockContext ------------------------------------------------------------------

VerilogParser::Specify_blockContext::Specify_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specify_blockContext::SPECIFY() {
  return getToken(VerilogParser::SPECIFY, 0);
}

tree::TerminalNode* VerilogParser::Specify_blockContext::ENDSPECIFY() {
  return getToken(VerilogParser::ENDSPECIFY, 0);
}

std::vector<VerilogParser::Specify_itemContext *> VerilogParser::Specify_blockContext::specify_item() {
  return getRuleContexts<VerilogParser::Specify_itemContext>();
}

VerilogParser::Specify_itemContext* VerilogParser::Specify_blockContext::specify_item(size_t i) {
  return getRuleContext<VerilogParser::Specify_itemContext>(i);
}


size_t VerilogParser::Specify_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_block;
}


std::any VerilogParser::Specify_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_blockContext* VerilogParser::specify_block() {
  Specify_blockContext *_localctx = _tracker.createInstance<Specify_blockContext>(_ctx, getState());
  enterRule(_localctx, 422, VerilogParser::RuleSpecify_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3209);
    match(VerilogParser::SPECIFY);
    setState(3213);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 54043199822364672) != 0) || ((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 9126903809) != 0) || _la == VerilogParser::LP) {
      setState(3210);
      specify_item();
      setState(3215);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3216);
    match(VerilogParser::ENDSPECIFY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_itemContext ------------------------------------------------------------------

VerilogParser::Specify_itemContext::Specify_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_declarationContext* VerilogParser::Specify_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::Specify_itemContext::pulsestyle_declaration() {
  return getRuleContext<VerilogParser::Pulsestyle_declarationContext>(0);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::Specify_itemContext::showcancelled_declaration() {
  return getRuleContext<VerilogParser::Showcancelled_declarationContext>(0);
}

VerilogParser::Path_declarationContext* VerilogParser::Specify_itemContext::path_declaration() {
  return getRuleContext<VerilogParser::Path_declarationContext>(0);
}

VerilogParser::System_timing_checkContext* VerilogParser::Specify_itemContext::system_timing_check() {
  return getRuleContext<VerilogParser::System_timing_checkContext>(0);
}


size_t VerilogParser::Specify_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_item;
}


std::any VerilogParser::Specify_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_itemContext* VerilogParser::specify_item() {
  Specify_itemContext *_localctx = _tracker.createInstance<Specify_itemContext>(_ctx, getState());
  enterRule(_localctx, 424, VerilogParser::RuleSpecify_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3223);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SPECPARAM: {
        enterOuterAlt(_localctx, 1);
        setState(3218);
        specparam_declaration();
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT:
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 2);
        setState(3219);
        pulsestyle_declaration();
        break;
      }

      case VerilogParser::NOSHOWCANCELLED:
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 3);
        setState(3220);
        showcancelled_declaration();
        break;
      }

      case VerilogParser::IF:
      case VerilogParser::IFNONE:
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 4);
        setState(3221);
        path_declaration();
        break;
      }

      case VerilogParser::DLFULLSKEW:
      case VerilogParser::DLHOLD:
      case VerilogParser::DLNOCHANGE:
      case VerilogParser::DLPERIOD:
      case VerilogParser::DLRECOVERY:
      case VerilogParser::DLRECREM:
      case VerilogParser::DLREMOVAL:
      case VerilogParser::DLSETUP:
      case VerilogParser::DLSETUPHOLD:
      case VerilogParser::DLSKEW:
      case VerilogParser::DLTIMESKEW:
      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 5);
        setState(3222);
        system_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulsestyle_declarationContext ------------------------------------------------------------------

VerilogParser::Pulsestyle_declarationContext::Pulsestyle_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONEVENT() {
  return getToken(VerilogParser::PULSESTYLE_ONEVENT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Pulsestyle_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONDETECT() {
  return getToken(VerilogParser::PULSESTYLE_ONDETECT, 0);
}


size_t VerilogParser::Pulsestyle_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePulsestyle_declaration;
}


std::any VerilogParser::Pulsestyle_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulsestyle_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::pulsestyle_declaration() {
  Pulsestyle_declarationContext *_localctx = _tracker.createInstance<Pulsestyle_declarationContext>(_ctx, getState());
  enterRule(_localctx, 426, VerilogParser::RulePulsestyle_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3233);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 1);
        setState(3225);
        match(VerilogParser::PULSESTYLE_ONEVENT);
        setState(3226);
        list_of_path_outputs();
        setState(3227);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT: {
        enterOuterAlt(_localctx, 2);
        setState(3229);
        match(VerilogParser::PULSESTYLE_ONDETECT);
        setState(3230);
        list_of_path_outputs();
        setState(3231);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Showcancelled_declarationContext ------------------------------------------------------------------

VerilogParser::Showcancelled_declarationContext::Showcancelled_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SHOWCANCELLED() {
  return getToken(VerilogParser::SHOWCANCELLED, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Showcancelled_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::NOSHOWCANCELLED() {
  return getToken(VerilogParser::NOSHOWCANCELLED, 0);
}


size_t VerilogParser::Showcancelled_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleShowcancelled_declaration;
}


std::any VerilogParser::Showcancelled_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitShowcancelled_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::showcancelled_declaration() {
  Showcancelled_declarationContext *_localctx = _tracker.createInstance<Showcancelled_declarationContext>(_ctx, getState());
  enterRule(_localctx, 428, VerilogParser::RuleShowcancelled_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3243);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 1);
        setState(3235);
        match(VerilogParser::SHOWCANCELLED);
        setState(3236);
        list_of_path_outputs();
        setState(3237);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NOSHOWCANCELLED: {
        enterOuterAlt(_localctx, 2);
        setState(3239);
        match(VerilogParser::NOSHOWCANCELLED);
        setState(3240);
        list_of_path_outputs();
        setState(3241);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_declarationContext ------------------------------------------------------------------

VerilogParser::Path_declarationContext::Path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Simple_path_declarationContext* VerilogParser::Path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Path_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::Path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::Path_declarationContext::state_dependent_path_declaration() {
  return getRuleContext<VerilogParser::State_dependent_path_declarationContext>(0);
}


size_t VerilogParser::Path_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePath_declaration;
}


std::any VerilogParser::Path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_declarationContext* VerilogParser::path_declaration() {
  Path_declarationContext *_localctx = _tracker.createInstance<Path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 430, VerilogParser::RulePath_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3254);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3245);
      simple_path_declaration();
      setState(3246);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3248);
      edge_sensitive_path_declaration();
      setState(3249);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3251);
      state_dependent_path_declaration();
      setState(3252);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_path_declarationContext ------------------------------------------------------------------

VerilogParser::Simple_path_declarationContext::Simple_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::Simple_path_declarationContext::parallel_path_description() {
  return getRuleContext<VerilogParser::Parallel_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Simple_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Simple_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::Simple_path_declarationContext::full_path_description() {
  return getRuleContext<VerilogParser::Full_path_descriptionContext>(0);
}


size_t VerilogParser::Simple_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_path_declaration;
}


std::any VerilogParser::Simple_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::simple_path_declaration() {
  Simple_path_declarationContext *_localctx = _tracker.createInstance<Simple_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 432, VerilogParser::RuleSimple_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3264);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3256);
      parallel_path_description();
      setState(3257);
      match(VerilogParser::EQ);
      setState(3258);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3260);
      full_path_description();
      setState(3261);
      match(VerilogParser::EQ);
      setState(3262);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_path_descriptionContext::Parallel_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_path_description;
}


std::any VerilogParser::Parallel_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::parallel_path_description() {
  Parallel_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 434, VerilogParser::RuleParallel_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3266);
    match(VerilogParser::LP);
    setState(3267);
    specify_input_terminal_descriptor();
    setState(3269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3268);
      polarity_operator();
    }
    setState(3271);
    match(VerilogParser::EQGT);
    setState(3272);
    specify_output_terminal_descriptor();
    setState(3273);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_path_descriptionContext::Full_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_path_description;
}


std::any VerilogParser::Full_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::full_path_description() {
  Full_path_descriptionContext *_localctx = _tracker.createInstance<Full_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 436, VerilogParser::RuleFull_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3275);
    match(VerilogParser::LP);
    setState(3276);
    list_of_path_inputs();
    setState(3278);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3277);
      polarity_operator();
    }
    setState(3280);
    match(VerilogParser::ASGT);
    setState(3281);
    list_of_path_outputs();
    setState(3282);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_inputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_inputsContext::List_of_path_inputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_input_terminal_descriptorContext *> VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_input_terminal_descriptorContext>();
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_inputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_inputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_inputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_inputs;
}


std::any VerilogParser::List_of_path_inputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_inputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::list_of_path_inputs() {
  List_of_path_inputsContext *_localctx = _tracker.createInstance<List_of_path_inputsContext>(_ctx, getState());
  enterRule(_localctx, 438, VerilogParser::RuleList_of_path_inputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3284);
    specify_input_terminal_descriptor();
    setState(3289);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3285);
      match(VerilogParser::CO);
      setState(3286);
      specify_input_terminal_descriptor();
      setState(3291);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_outputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_outputsContext::List_of_path_outputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_output_terminal_descriptorContext *> VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_output_terminal_descriptorContext>();
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_outputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_outputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_outputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_outputs;
}


std::any VerilogParser::List_of_path_outputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_outputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::list_of_path_outputs() {
  List_of_path_outputsContext *_localctx = _tracker.createInstance<List_of_path_outputsContext>(_ctx, getState());
  enterRule(_localctx, 440, VerilogParser::RuleList_of_path_outputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3292);
    specify_output_terminal_descriptor();
    setState(3297);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3293);
      match(VerilogParser::CO);
      setState(3294);
      specify_output_terminal_descriptor();
      setState(3299);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_input_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_input_terminal_descriptorContext::Specify_input_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Input_identifierContext* VerilogParser::Specify_input_terminal_descriptorContext::input_identifier() {
  return getRuleContext<VerilogParser::Input_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_input_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_input_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_input_terminal_descriptor;
}


std::any VerilogParser::Specify_input_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_input_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::specify_input_terminal_descriptor() {
  Specify_input_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_input_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 442, VerilogParser::RuleSpecify_input_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3300);
    input_identifier();
    setState(3305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3301);
      match(VerilogParser::LB);
      setState(3302);
      constant_range_expression();
      setState(3303);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_output_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_output_terminal_descriptorContext::Specify_output_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_identifierContext* VerilogParser::Specify_output_terminal_descriptorContext::output_identifier() {
  return getRuleContext<VerilogParser::Output_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_output_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_output_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_output_terminal_descriptor;
}


std::any VerilogParser::Specify_output_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_output_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::specify_output_terminal_descriptor() {
  Specify_output_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_output_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 444, VerilogParser::RuleSpecify_output_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3307);
    output_identifier();
    setState(3312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3308);
      match(VerilogParser::LB);
      setState(3309);
      constant_range_expression();
      setState(3310);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_identifierContext ------------------------------------------------------------------

VerilogParser::Input_identifierContext::Input_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Input_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Input_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_identifier;
}


std::any VerilogParser::Input_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_identifierContext* VerilogParser::input_identifier() {
  Input_identifierContext *_localctx = _tracker.createInstance<Input_identifierContext>(_ctx, getState());
  enterRule(_localctx, 446, VerilogParser::RuleInput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3314);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_identifierContext ------------------------------------------------------------------

VerilogParser::Output_identifierContext::Output_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Output_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Output_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_identifier;
}


std::any VerilogParser::Output_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_identifierContext* VerilogParser::output_identifier() {
  Output_identifierContext *_localctx = _tracker.createInstance<Output_identifierContext>(_ctx, getState());
  enterRule(_localctx, 448, VerilogParser::RuleOutput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3316);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_valueContext ------------------------------------------------------------------

VerilogParser::Path_delay_valueContext::Path_delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::Path_delay_valueContext::list_of_path_delay_expressions() {
  return getRuleContext<VerilogParser::List_of_path_delay_expressionsContext>(0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Path_delay_valueContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_value;
}


std::any VerilogParser::Path_delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_valueContext* VerilogParser::path_delay_value() {
  Path_delay_valueContext *_localctx = _tracker.createInstance<Path_delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 450, VerilogParser::RulePath_delay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3318);
      list_of_path_delay_expressions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3319);
      match(VerilogParser::LP);
      setState(3320);
      list_of_path_delay_expressions();
      setState(3321);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_delay_expressionsContext ------------------------------------------------------------------

VerilogParser::List_of_path_delay_expressionsContext::List_of_path_delay_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t_path_delay_expression() {
  return getRuleContext<VerilogParser::T_path_delay_expressionContext>(0);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::trise_path_delay_expression() {
  return getRuleContext<VerilogParser::Trise_path_delay_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_delay_expressionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_delay_expressionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tfall_path_delay_expression() {
  return getRuleContext<VerilogParser::Tfall_path_delay_expressionContext>(0);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz_path_delay_expressionContext>(0);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t01_path_delay_expression() {
  return getRuleContext<VerilogParser::T01_path_delay_expressionContext>(0);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t10_path_delay_expression() {
  return getRuleContext<VerilogParser::T10_path_delay_expressionContext>(0);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0z_path_delay_expression() {
  return getRuleContext<VerilogParser::T0z_path_delay_expressionContext>(0);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz1_path_delay_expressionContext>(0);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1z_path_delay_expression() {
  return getRuleContext<VerilogParser::T1z_path_delay_expressionContext>(0);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz0_path_delay_expressionContext>(0);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0x_path_delay_expression() {
  return getRuleContext<VerilogParser::T0x_path_delay_expressionContext>(0);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx1_path_delay_expressionContext>(0);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1x_path_delay_expression() {
  return getRuleContext<VerilogParser::T1x_path_delay_expressionContext>(0);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx0_path_delay_expressionContext>(0);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::txz_path_delay_expression() {
  return getRuleContext<VerilogParser::Txz_path_delay_expressionContext>(0);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tzx_path_delay_expression() {
  return getRuleContext<VerilogParser::Tzx_path_delay_expressionContext>(0);
}


size_t VerilogParser::List_of_path_delay_expressionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_delay_expressions;
}


std::any VerilogParser::List_of_path_delay_expressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_delay_expressions(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::list_of_path_delay_expressions() {
  List_of_path_delay_expressionsContext *_localctx = _tracker.createInstance<List_of_path_delay_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 452, VerilogParser::RuleList_of_path_delay_expressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3359);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3325);
      t_path_delay_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3326);
      trise_path_delay_expression();
      setState(3327);
      match(VerilogParser::CO);
      setState(3328);
      tfall_path_delay_expression();
      setState(3331);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3329);
        match(VerilogParser::CO);
        setState(3330);
        tz_path_delay_expression();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3333);
      t01_path_delay_expression();
      setState(3334);
      match(VerilogParser::CO);
      setState(3335);
      t10_path_delay_expression();
      setState(3336);
      match(VerilogParser::CO);
      setState(3337);
      t0z_path_delay_expression();
      setState(3338);
      match(VerilogParser::CO);
      setState(3339);
      tz1_path_delay_expression();
      setState(3340);
      match(VerilogParser::CO);
      setState(3341);
      t1z_path_delay_expression();
      setState(3342);
      match(VerilogParser::CO);
      setState(3343);
      tz0_path_delay_expression();
      setState(3357);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3344);
        match(VerilogParser::CO);
        setState(3345);
        t0x_path_delay_expression();
        setState(3346);
        match(VerilogParser::CO);
        setState(3347);
        tx1_path_delay_expression();
        setState(3348);
        match(VerilogParser::CO);
        setState(3349);
        t1x_path_delay_expression();
        setState(3350);
        match(VerilogParser::CO);
        setState(3351);
        tx0_path_delay_expression();
        setState(3352);
        match(VerilogParser::CO);
        setState(3353);
        txz_path_delay_expression();
        setState(3354);
        match(VerilogParser::CO);
        setState(3355);
        tzx_path_delay_expression();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T_path_delay_expressionContext::T_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT_path_delay_expression;
}


std::any VerilogParser::T_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::t_path_delay_expression() {
  T_path_delay_expressionContext *_localctx = _tracker.createInstance<T_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 454, VerilogParser::RuleT_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3361);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trise_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Trise_path_delay_expressionContext::Trise_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Trise_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Trise_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTrise_path_delay_expression;
}


std::any VerilogParser::Trise_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTrise_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::trise_path_delay_expression() {
  Trise_path_delay_expressionContext *_localctx = _tracker.createInstance<Trise_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 456, VerilogParser::RuleTrise_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3363);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tfall_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tfall_path_delay_expressionContext::Tfall_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tfall_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tfall_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTfall_path_delay_expression;
}


std::any VerilogParser::Tfall_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTfall_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::tfall_path_delay_expression() {
  Tfall_path_delay_expressionContext *_localctx = _tracker.createInstance<Tfall_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 458, VerilogParser::RuleTfall_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3365);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz_path_delay_expressionContext::Tz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz_path_delay_expression;
}


std::any VerilogParser::Tz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::tz_path_delay_expression() {
  Tz_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 460, VerilogParser::RuleTz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3367);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T01_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T01_path_delay_expressionContext::T01_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T01_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T01_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT01_path_delay_expression;
}


std::any VerilogParser::T01_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT01_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::t01_path_delay_expression() {
  T01_path_delay_expressionContext *_localctx = _tracker.createInstance<T01_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 462, VerilogParser::RuleT01_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3369);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T10_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T10_path_delay_expressionContext::T10_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T10_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T10_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT10_path_delay_expression;
}


std::any VerilogParser::T10_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT10_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::t10_path_delay_expression() {
  T10_path_delay_expressionContext *_localctx = _tracker.createInstance<T10_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 464, VerilogParser::RuleT10_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3371);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0z_path_delay_expressionContext::T0z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0z_path_delay_expression;
}


std::any VerilogParser::T0z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::t0z_path_delay_expression() {
  T0z_path_delay_expressionContext *_localctx = _tracker.createInstance<T0z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 466, VerilogParser::RuleT0z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3373);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz1_path_delay_expressionContext::Tz1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz1_path_delay_expression;
}


std::any VerilogParser::Tz1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::tz1_path_delay_expression() {
  Tz1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 468, VerilogParser::RuleTz1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3375);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1z_path_delay_expressionContext::T1z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1z_path_delay_expression;
}


std::any VerilogParser::T1z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::t1z_path_delay_expression() {
  T1z_path_delay_expressionContext *_localctx = _tracker.createInstance<T1z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 470, VerilogParser::RuleT1z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3377);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz0_path_delay_expressionContext::Tz0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz0_path_delay_expression;
}


std::any VerilogParser::Tz0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::tz0_path_delay_expression() {
  Tz0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 472, VerilogParser::RuleTz0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3379);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0x_path_delay_expressionContext::T0x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0x_path_delay_expression;
}


std::any VerilogParser::T0x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::t0x_path_delay_expression() {
  T0x_path_delay_expressionContext *_localctx = _tracker.createInstance<T0x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 474, VerilogParser::RuleT0x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3381);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx1_path_delay_expressionContext::Tx1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx1_path_delay_expression;
}


std::any VerilogParser::Tx1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::tx1_path_delay_expression() {
  Tx1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 476, VerilogParser::RuleTx1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3383);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1x_path_delay_expressionContext::T1x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1x_path_delay_expression;
}


std::any VerilogParser::T1x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::t1x_path_delay_expression() {
  T1x_path_delay_expressionContext *_localctx = _tracker.createInstance<T1x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 478, VerilogParser::RuleT1x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3385);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx0_path_delay_expressionContext::Tx0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx0_path_delay_expression;
}


std::any VerilogParser::Tx0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::tx0_path_delay_expression() {
  Tx0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 480, VerilogParser::RuleTx0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3387);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Txz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Txz_path_delay_expressionContext::Txz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Txz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Txz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTxz_path_delay_expression;
}


std::any VerilogParser::Txz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTxz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::txz_path_delay_expression() {
  Txz_path_delay_expressionContext *_localctx = _tracker.createInstance<Txz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 482, VerilogParser::RuleTxz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3389);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tzx_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tzx_path_delay_expressionContext::Tzx_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tzx_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tzx_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTzx_path_delay_expression;
}


std::any VerilogParser::Tzx_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTzx_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::tzx_path_delay_expression() {
  Tzx_path_delay_expressionContext *_localctx = _tracker.createInstance<Tzx_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 484, VerilogParser::RuleTzx_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3391);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Path_delay_expressionContext::Path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Path_delay_expressionContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_expression;
}


std::any VerilogParser::Path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_expressionContext* VerilogParser::path_delay_expression() {
  Path_delay_expressionContext *_localctx = _tracker.createInstance<Path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 486, VerilogParser::RulePath_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3393);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_sensitive_path_declarationContext ------------------------------------------------------------------

VerilogParser::Edge_sensitive_path_declarationContext::Edge_sensitive_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::parallel_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Parallel_edge_sensitive_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Edge_sensitive_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Edge_sensitive_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::full_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Full_edge_sensitive_path_descriptionContext>(0);
}


size_t VerilogParser::Edge_sensitive_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_sensitive_path_declaration;
}


std::any VerilogParser::Edge_sensitive_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_sensitive_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::edge_sensitive_path_declaration() {
  Edge_sensitive_path_declarationContext *_localctx = _tracker.createInstance<Edge_sensitive_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 488, VerilogParser::RuleEdge_sensitive_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3403);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3395);
      parallel_edge_sensitive_path_description();
      setState(3396);
      match(VerilogParser::EQ);
      setState(3397);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3399);
      full_edge_sensitive_path_description();
      setState(3400);
      match(VerilogParser::EQ);
      setState(3401);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_edge_sensitive_path_descriptionContext::Parallel_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_edge_sensitive_path_description;
}


std::any VerilogParser::Parallel_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::parallel_edge_sensitive_path_description() {
  Parallel_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 490, VerilogParser::RuleParallel_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3405);
    match(VerilogParser::LP);
    setState(3407);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3406);
      edge_identifier();
    }
    setState(3409);
    specify_input_terminal_descriptor();
    setState(3410);
    match(VerilogParser::EQGT);
    setState(3411);
    match(VerilogParser::LP);
    setState(3412);
    specify_output_terminal_descriptor();
    setState(3414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3413);
      polarity_operator();
    }
    setState(3416);
    match(VerilogParser::CL);
    setState(3417);
    data_source_expression();
    setState(3418);
    match(VerilogParser::RP);
    setState(3419);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_edge_sensitive_path_descriptionContext::Full_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_edge_sensitive_path_description;
}


std::any VerilogParser::Full_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::full_edge_sensitive_path_description() {
  Full_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Full_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 492, VerilogParser::RuleFull_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3421);
    match(VerilogParser::LP);
    setState(3423);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3422);
      edge_identifier();
    }
    setState(3425);
    list_of_path_inputs();
    setState(3426);
    match(VerilogParser::ASGT);
    setState(3427);
    match(VerilogParser::LP);
    setState(3428);
    list_of_path_outputs();
    setState(3430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3429);
      polarity_operator();
    }
    setState(3432);
    match(VerilogParser::CL);
    setState(3433);
    data_source_expression();
    setState(3434);
    match(VerilogParser::RP);
    setState(3435);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_source_expressionContext ------------------------------------------------------------------

VerilogParser::Data_source_expressionContext::Data_source_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Data_source_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Data_source_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleData_source_expression;
}


std::any VerilogParser::Data_source_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_source_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_source_expressionContext* VerilogParser::data_source_expression() {
  Data_source_expressionContext *_localctx = _tracker.createInstance<Data_source_expressionContext>(_ctx, getState());
  enterRule(_localctx, 494, VerilogParser::RuleData_source_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3437);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_identifierContext ------------------------------------------------------------------

VerilogParser::Edge_identifierContext::Edge_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}


size_t VerilogParser::Edge_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_identifier;
}


std::any VerilogParser::Edge_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_identifierContext* VerilogParser::edge_identifier() {
  Edge_identifierContext *_localctx = _tracker.createInstance<Edge_identifierContext>(_ctx, getState());
  enterRule(_localctx, 496, VerilogParser::RuleEdge_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3439);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_dependent_path_declarationContext ------------------------------------------------------------------

VerilogParser::State_dependent_path_declarationContext::State_dependent_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::State_dependent_path_declarationContext::module_path_expression() {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IFNONE() {
  return getToken(VerilogParser::IFNONE, 0);
}


size_t VerilogParser::State_dependent_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleState_dependent_path_declaration;
}


std::any VerilogParser::State_dependent_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitState_dependent_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::state_dependent_path_declaration() {
  State_dependent_path_declarationContext *_localctx = _tracker.createInstance<State_dependent_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 498, VerilogParser::RuleState_dependent_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3455);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3441);
      match(VerilogParser::IF);
      setState(3442);
      match(VerilogParser::LP);
      setState(3443);
      module_path_expression(0);
      setState(3444);
      match(VerilogParser::RP);
      setState(3445);
      simple_path_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3447);
      match(VerilogParser::IF);
      setState(3448);
      match(VerilogParser::LP);
      setState(3449);
      module_path_expression(0);
      setState(3450);
      match(VerilogParser::RP);
      setState(3451);
      edge_sensitive_path_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3453);
      match(VerilogParser::IFNONE);
      setState(3454);
      simple_path_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Polarity_operatorContext ------------------------------------------------------------------

VerilogParser::Polarity_operatorContext::Polarity_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Polarity_operatorContext::getRuleIndex() const {
  return VerilogParser::RulePolarity_operator;
}


std::any VerilogParser::Polarity_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPolarity_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Polarity_operatorContext* VerilogParser::polarity_operator() {
  Polarity_operatorContext *_localctx = _tracker.createInstance<Polarity_operatorContext>(_ctx, getState());
  enterRule(_localctx, 500, VerilogParser::RulePolarity_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3457);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MI

    || _la == VerilogParser::PL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_timing_checkContext ------------------------------------------------------------------

VerilogParser::System_timing_checkContext::System_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Setup_timing_checkContext* VerilogParser::System_timing_checkContext::setup_timing_check() {
  return getRuleContext<VerilogParser::Setup_timing_checkContext>(0);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::System_timing_checkContext::hold_timing_check() {
  return getRuleContext<VerilogParser::Hold_timing_checkContext>(0);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::System_timing_checkContext::setuphold_timing_check() {
  return getRuleContext<VerilogParser::Setuphold_timing_checkContext>(0);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::System_timing_checkContext::recovery_timing_check() {
  return getRuleContext<VerilogParser::Recovery_timing_checkContext>(0);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::System_timing_checkContext::removal_timing_check() {
  return getRuleContext<VerilogParser::Removal_timing_checkContext>(0);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::System_timing_checkContext::recrem_timing_check() {
  return getRuleContext<VerilogParser::Recrem_timing_checkContext>(0);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::System_timing_checkContext::skew_timing_check() {
  return getRuleContext<VerilogParser::Skew_timing_checkContext>(0);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::System_timing_checkContext::timeskew_timing_check() {
  return getRuleContext<VerilogParser::Timeskew_timing_checkContext>(0);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::System_timing_checkContext::fullskew_timing_check() {
  return getRuleContext<VerilogParser::Fullskew_timing_checkContext>(0);
}

VerilogParser::Period_timing_checkContext* VerilogParser::System_timing_checkContext::period_timing_check() {
  return getRuleContext<VerilogParser::Period_timing_checkContext>(0);
}

VerilogParser::Width_timing_checkContext* VerilogParser::System_timing_checkContext::width_timing_check() {
  return getRuleContext<VerilogParser::Width_timing_checkContext>(0);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::System_timing_checkContext::nochange_timing_check() {
  return getRuleContext<VerilogParser::Nochange_timing_checkContext>(0);
}


size_t VerilogParser::System_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_timing_check;
}


std::any VerilogParser::System_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_timing_checkContext* VerilogParser::system_timing_check() {
  System_timing_checkContext *_localctx = _tracker.createInstance<System_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 502, VerilogParser::RuleSystem_timing_check);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3471);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::DLSETUP: {
        enterOuterAlt(_localctx, 1);
        setState(3459);
        setup_timing_check();
        break;
      }

      case VerilogParser::DLHOLD: {
        enterOuterAlt(_localctx, 2);
        setState(3460);
        hold_timing_check();
        break;
      }

      case VerilogParser::DLSETUPHOLD: {
        enterOuterAlt(_localctx, 3);
        setState(3461);
        setuphold_timing_check();
        break;
      }

      case VerilogParser::DLRECOVERY: {
        enterOuterAlt(_localctx, 4);
        setState(3462);
        recovery_timing_check();
        break;
      }

      case VerilogParser::DLREMOVAL: {
        enterOuterAlt(_localctx, 5);
        setState(3463);
        removal_timing_check();
        break;
      }

      case VerilogParser::DLRECREM: {
        enterOuterAlt(_localctx, 6);
        setState(3464);
        recrem_timing_check();
        break;
      }

      case VerilogParser::DLSKEW: {
        enterOuterAlt(_localctx, 7);
        setState(3465);
        skew_timing_check();
        break;
      }

      case VerilogParser::DLTIMESKEW: {
        enterOuterAlt(_localctx, 8);
        setState(3466);
        timeskew_timing_check();
        break;
      }

      case VerilogParser::DLFULLSKEW: {
        enterOuterAlt(_localctx, 9);
        setState(3467);
        fullskew_timing_check();
        break;
      }

      case VerilogParser::DLPERIOD: {
        enterOuterAlt(_localctx, 10);
        setState(3468);
        period_timing_check();
        break;
      }

      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 11);
        setState(3469);
        width_timing_check();
        break;
      }

      case VerilogParser::DLNOCHANGE: {
        enterOuterAlt(_localctx, 12);
        setState(3470);
        nochange_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setup_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setup_timing_checkContext::Setup_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::DLSETUP() {
  return getToken(VerilogParser::DLSETUP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Data_eventContext* VerilogParser::Setup_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setup_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Reference_eventContext* VerilogParser::Setup_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setup_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Setup_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Setup_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetup_timing_check;
}


std::any VerilogParser::Setup_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetup_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setup_timing_checkContext* VerilogParser::setup_timing_check() {
  Setup_timing_checkContext *_localctx = _tracker.createInstance<Setup_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 504, VerilogParser::RuleSetup_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3473);
    match(VerilogParser::DLSETUP);
    setState(3474);
    match(VerilogParser::LP);
    setState(3475);
    data_event();
    setState(3476);
    match(VerilogParser::CO);
    setState(3477);
    reference_event();
    setState(3478);
    match(VerilogParser::CO);
    setState(3479);
    timing_check_limit();
    setState(3481);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3480);
      notifier_opt();
    }
    setState(3483);
    match(VerilogParser::RP);
    setState(3484);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Notifier_optContext ------------------------------------------------------------------

VerilogParser::Notifier_optContext::Notifier_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Notifier_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Notifier_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Notifier_optContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier_opt;
}


std::any VerilogParser::Notifier_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Notifier_optContext* VerilogParser::notifier_opt() {
  Notifier_optContext *_localctx = _tracker.createInstance<Notifier_optContext>(_ctx, getState());
  enterRule(_localctx, 506, VerilogParser::RuleNotifier_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3486);
    match(VerilogParser::CO);
    setState(3488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3487);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Hold_timing_checkContext::Hold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::DLHOLD() {
  return getToken(VerilogParser::DLHOLD, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Hold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Hold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Hold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Hold_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Hold_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Hold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleHold_timing_check;
}


std::any VerilogParser::Hold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::hold_timing_check() {
  Hold_timing_checkContext *_localctx = _tracker.createInstance<Hold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 508, VerilogParser::RuleHold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3490);
    match(VerilogParser::DLHOLD);
    setState(3491);
    match(VerilogParser::LP);
    setState(3492);
    reference_event();
    setState(3493);
    match(VerilogParser::CO);
    setState(3494);
    data_event();
    setState(3495);
    match(VerilogParser::CO);
    setState(3496);
    timing_check_limit();
    setState(3498);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3497);
      notifier_opt();
    }
    setState(3500);
    match(VerilogParser::RP);
    setState(3501);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setuphold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setuphold_timing_checkContext::Setuphold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::DLSETUPHOLD() {
  return getToken(VerilogParser::DLSETUPHOLD, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Setuphold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setuphold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Setuphold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Setuphold_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setuphold_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Setuphold_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Setuphold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetuphold_timing_check;
}


std::any VerilogParser::Setuphold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetuphold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::setuphold_timing_check() {
  Setuphold_timing_checkContext *_localctx = _tracker.createInstance<Setuphold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 510, VerilogParser::RuleSetuphold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3503);
    match(VerilogParser::DLSETUPHOLD);
    setState(3504);
    match(VerilogParser::LP);
    setState(3505);
    reference_event();
    setState(3506);
    match(VerilogParser::CO);
    setState(3507);
    data_event();
    setState(3508);
    match(VerilogParser::CO);
    setState(3509);
    timing_check_limit();
    setState(3510);
    match(VerilogParser::CO);
    setState(3511);
    timing_check_limit();
    setState(3513);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3512);
      timing_check_opt();
    }
    setState(3515);
    match(VerilogParser::RP);
    setState(3516);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_optContext ------------------------------------------------------------------

VerilogParser::Timing_check_optContext::Timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::Timing_check_optContext::stamptime_cond_opt() {
  return getRuleContext<VerilogParser::Stamptime_cond_optContext>(0);
}


size_t VerilogParser::Timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_opt;
}


std::any VerilogParser::Timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_optContext* VerilogParser::timing_check_opt() {
  Timing_check_optContext *_localctx = _tracker.createInstance<Timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 512, VerilogParser::RuleTiming_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3518);
    match(VerilogParser::CO);
    setState(3520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3519);
      notifier();
    }
    setState(3523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3522);
      stamptime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_cond_optContext ------------------------------------------------------------------

VerilogParser::Stamptime_cond_optContext::Stamptime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Stamptime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::Stamptime_cond_optContext::stamptime_condition() {
  return getRuleContext<VerilogParser::Stamptime_conditionContext>(0);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::Stamptime_cond_optContext::checktime_cond_opt() {
  return getRuleContext<VerilogParser::Checktime_cond_optContext>(0);
}


size_t VerilogParser::Stamptime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_cond_opt;
}


std::any VerilogParser::Stamptime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::stamptime_cond_opt() {
  Stamptime_cond_optContext *_localctx = _tracker.createInstance<Stamptime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 514, VerilogParser::RuleStamptime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3525);
    match(VerilogParser::CO);
    setState(3527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(3526);
      stamptime_condition();
    }
    setState(3530);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3529);
      checktime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_cond_optContext ------------------------------------------------------------------

VerilogParser::Checktime_cond_optContext::Checktime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Checktime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Checktime_conditionContext* VerilogParser::Checktime_cond_optContext::checktime_condition() {
  return getRuleContext<VerilogParser::Checktime_conditionContext>(0);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::Checktime_cond_optContext::delayed_ref_opt() {
  return getRuleContext<VerilogParser::Delayed_ref_optContext>(0);
}


size_t VerilogParser::Checktime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_cond_opt;
}


std::any VerilogParser::Checktime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::checktime_cond_opt() {
  Checktime_cond_optContext *_localctx = _tracker.createInstance<Checktime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 516, VerilogParser::RuleChecktime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3532);
    match(VerilogParser::CO);
    setState(3534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(3533);
      checktime_condition();
    }
    setState(3537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3536);
      delayed_ref_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_ref_optContext ------------------------------------------------------------------

VerilogParser::Delayed_ref_optContext::Delayed_ref_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_ref_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_referenceContext* VerilogParser::Delayed_ref_optContext::delayed_reference() {
  return getRuleContext<VerilogParser::Delayed_referenceContext>(0);
}

VerilogParser::Delayed_data_optContext* VerilogParser::Delayed_ref_optContext::delayed_data_opt() {
  return getRuleContext<VerilogParser::Delayed_data_optContext>(0);
}


size_t VerilogParser::Delayed_ref_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_ref_opt;
}


std::any VerilogParser::Delayed_ref_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_ref_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::delayed_ref_opt() {
  Delayed_ref_optContext *_localctx = _tracker.createInstance<Delayed_ref_optContext>(_ctx, getState());
  enterRule(_localctx, 518, VerilogParser::RuleDelayed_ref_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3539);
    match(VerilogParser::CO);
    setState(3541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3540);
      delayed_reference();
    }
    setState(3544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3543);
      delayed_data_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_data_optContext ------------------------------------------------------------------

VerilogParser::Delayed_data_optContext::Delayed_data_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_data_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_dataContext* VerilogParser::Delayed_data_optContext::delayed_data() {
  return getRuleContext<VerilogParser::Delayed_dataContext>(0);
}


size_t VerilogParser::Delayed_data_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data_opt;
}


std::any VerilogParser::Delayed_data_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_data_optContext* VerilogParser::delayed_data_opt() {
  Delayed_data_optContext *_localctx = _tracker.createInstance<Delayed_data_optContext>(_ctx, getState());
  enterRule(_localctx, 520, VerilogParser::RuleDelayed_data_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3546);
    match(VerilogParser::CO);
    setState(3548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3547);
      delayed_data();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recovery_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recovery_timing_checkContext::Recovery_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::DLRECOVERY() {
  return getToken(VerilogParser::DLRECOVERY, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recovery_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recovery_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recovery_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recovery_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Recovery_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Recovery_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecovery_timing_check;
}


std::any VerilogParser::Recovery_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecovery_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::recovery_timing_check() {
  Recovery_timing_checkContext *_localctx = _tracker.createInstance<Recovery_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 522, VerilogParser::RuleRecovery_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3550);
    match(VerilogParser::DLRECOVERY);
    setState(3551);
    match(VerilogParser::LP);
    setState(3552);
    reference_event();
    setState(3553);
    match(VerilogParser::CO);
    setState(3554);
    data_event();
    setState(3555);
    match(VerilogParser::CO);
    setState(3556);
    timing_check_limit();
    setState(3558);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3557);
      notifier_opt();
    }
    setState(3560);
    match(VerilogParser::RP);
    setState(3561);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Removal_timing_checkContext ------------------------------------------------------------------

VerilogParser::Removal_timing_checkContext::Removal_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::DLREMOVAL() {
  return getToken(VerilogParser::DLREMOVAL, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Removal_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Removal_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Removal_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Removal_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Removal_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Removal_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRemoval_timing_check;
}


std::any VerilogParser::Removal_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemoval_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::removal_timing_check() {
  Removal_timing_checkContext *_localctx = _tracker.createInstance<Removal_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 524, VerilogParser::RuleRemoval_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3563);
    match(VerilogParser::DLREMOVAL);
    setState(3564);
    match(VerilogParser::LP);
    setState(3565);
    reference_event();
    setState(3566);
    match(VerilogParser::CO);
    setState(3567);
    data_event();
    setState(3568);
    match(VerilogParser::CO);
    setState(3569);
    timing_check_limit();
    setState(3571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3570);
      notifier_opt();
    }
    setState(3573);
    match(VerilogParser::RP);
    setState(3574);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recrem_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recrem_timing_checkContext::Recrem_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::DLRECREM() {
  return getToken(VerilogParser::DLRECREM, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recrem_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recrem_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recrem_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Recrem_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recrem_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Recrem_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Recrem_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecrem_timing_check;
}


std::any VerilogParser::Recrem_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecrem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::recrem_timing_check() {
  Recrem_timing_checkContext *_localctx = _tracker.createInstance<Recrem_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 526, VerilogParser::RuleRecrem_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3576);
    match(VerilogParser::DLRECREM);
    setState(3577);
    match(VerilogParser::LP);
    setState(3578);
    reference_event();
    setState(3579);
    match(VerilogParser::CO);
    setState(3580);
    data_event();
    setState(3581);
    match(VerilogParser::CO);
    setState(3582);
    timing_check_limit();
    setState(3583);
    match(VerilogParser::CO);
    setState(3584);
    timing_check_limit();
    setState(3586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3585);
      timing_check_opt();
    }
    setState(3588);
    match(VerilogParser::RP);
    setState(3589);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Skew_timing_checkContext::Skew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::DLSKEW() {
  return getToken(VerilogParser::DLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Skew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Skew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Skew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Skew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Skew_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Skew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check;
}


std::any VerilogParser::Skew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::skew_timing_check() {
  Skew_timing_checkContext *_localctx = _tracker.createInstance<Skew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 528, VerilogParser::RuleSkew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3591);
    match(VerilogParser::DLSKEW);
    setState(3592);
    match(VerilogParser::LP);
    setState(3593);
    reference_event();
    setState(3594);
    match(VerilogParser::CO);
    setState(3595);
    data_event();
    setState(3596);
    match(VerilogParser::CO);
    setState(3597);
    timing_check_limit();
    setState(3599);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3598);
      notifier_opt();
    }
    setState(3601);
    match(VerilogParser::RP);
    setState(3602);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timeskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Timeskew_timing_checkContext::Timeskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::DLTIMESKEW() {
  return getToken(VerilogParser::DLTIMESKEW, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Timeskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Timeskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Timeskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Timeskew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Timeskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Timeskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleTimeskew_timing_check;
}


std::any VerilogParser::Timeskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTimeskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::timeskew_timing_check() {
  Timeskew_timing_checkContext *_localctx = _tracker.createInstance<Timeskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 530, VerilogParser::RuleTimeskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3604);
    match(VerilogParser::DLTIMESKEW);
    setState(3605);
    match(VerilogParser::LP);
    setState(3606);
    reference_event();
    setState(3607);
    match(VerilogParser::CO);
    setState(3608);
    data_event();
    setState(3609);
    match(VerilogParser::CO);
    setState(3610);
    timing_check_limit();
    setState(3612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3611);
      skew_timing_check_opt();
    }
    setState(3614);
    match(VerilogParser::RP);
    setState(3615);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_check_optContext ------------------------------------------------------------------

VerilogParser::Skew_timing_check_optContext::Skew_timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Skew_timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::Skew_timing_check_optContext::event_based_flag_opt() {
  return getRuleContext<VerilogParser::Event_based_flag_optContext>(0);
}


size_t VerilogParser::Skew_timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check_opt;
}


std::any VerilogParser::Skew_timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::skew_timing_check_opt() {
  Skew_timing_check_optContext *_localctx = _tracker.createInstance<Skew_timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 532, VerilogParser::RuleSkew_timing_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3617);
    match(VerilogParser::CO);
    setState(3619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3618);
      notifier();
    }
    setState(3622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3621);
      event_based_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flag_optContext ------------------------------------------------------------------

VerilogParser::Event_based_flag_optContext::Event_based_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_based_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Event_based_flagContext* VerilogParser::Event_based_flag_optContext::event_based_flag() {
  return getRuleContext<VerilogParser::Event_based_flagContext>(0);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::Event_based_flag_optContext::remain_active_flag_opt() {
  return getRuleContext<VerilogParser::Remain_active_flag_optContext>(0);
}


size_t VerilogParser::Event_based_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag_opt;
}


std::any VerilogParser::Event_based_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::event_based_flag_opt() {
  Event_based_flag_optContext *_localctx = _tracker.createInstance<Event_based_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 534, VerilogParser::RuleEvent_based_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3624);
    match(VerilogParser::CO);
    setState(3626);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(3625);
      event_based_flag();
    }
    setState(3629);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3628);
      remain_active_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flag_optContext ------------------------------------------------------------------

VerilogParser::Remain_active_flag_optContext::Remain_active_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Remain_active_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Remain_active_flagContext* VerilogParser::Remain_active_flag_optContext::remain_active_flag() {
  return getRuleContext<VerilogParser::Remain_active_flagContext>(0);
}


size_t VerilogParser::Remain_active_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag_opt;
}


std::any VerilogParser::Remain_active_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::remain_active_flag_opt() {
  Remain_active_flag_optContext *_localctx = _tracker.createInstance<Remain_active_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 536, VerilogParser::RuleRemain_active_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3631);
    match(VerilogParser::CO);
    setState(3633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 8847496634181345) != 0)) {
      setState(3632);
      remain_active_flag();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Fullskew_timing_checkContext::Fullskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::DLFULLSKEW() {
  return getToken(VerilogParser::DLFULLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Fullskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Fullskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Fullskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Fullskew_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Fullskew_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Fullskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Fullskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleFullskew_timing_check;
}


std::any VerilogParser::Fullskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFullskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::fullskew_timing_check() {
  Fullskew_timing_checkContext *_localctx = _tracker.createInstance<Fullskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 538, VerilogParser::RuleFullskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3635);
    match(VerilogParser::DLFULLSKEW);
    setState(3636);
    match(VerilogParser::LP);
    setState(3637);
    reference_event();
    setState(3638);
    match(VerilogParser::CO);
    setState(3639);
    data_event();
    setState(3640);
    match(VerilogParser::CO);
    setState(3641);
    timing_check_limit();
    setState(3642);
    match(VerilogParser::CO);
    setState(3643);
    timing_check_limit();
    setState(3645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3644);
      skew_timing_check_opt();
    }
    setState(3647);
    match(VerilogParser::RP);
    setState(3648);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Period_timing_checkContext ------------------------------------------------------------------

VerilogParser::Period_timing_checkContext::Period_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::DLPERIOD() {
  return getToken(VerilogParser::DLPERIOD, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Period_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Period_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Period_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Period_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RulePeriod_timing_check;
}


std::any VerilogParser::Period_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPeriod_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Period_timing_checkContext* VerilogParser::period_timing_check() {
  Period_timing_checkContext *_localctx = _tracker.createInstance<Period_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 540, VerilogParser::RulePeriod_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3650);
    match(VerilogParser::DLPERIOD);
    setState(3651);
    match(VerilogParser::LP);
    setState(3652);
    controlled_reference_event();
    setState(3653);
    match(VerilogParser::CO);
    setState(3654);
    timing_check_limit();
    setState(3656);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3655);
      notifier_opt();
    }
    setState(3658);
    match(VerilogParser::RP);
    setState(3659);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_timing_checkContext ------------------------------------------------------------------

VerilogParser::Width_timing_checkContext::Width_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::DLWIDTH() {
  return getToken(VerilogParser::DLWIDTH, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Width_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Width_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Threshold_optContext* VerilogParser::Width_timing_checkContext::threshold_opt() {
  return getRuleContext<VerilogParser::Threshold_optContext>(0);
}


size_t VerilogParser::Width_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_timing_check;
}


std::any VerilogParser::Width_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_timing_checkContext* VerilogParser::width_timing_check() {
  Width_timing_checkContext *_localctx = _tracker.createInstance<Width_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 542, VerilogParser::RuleWidth_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3661);
    match(VerilogParser::DLWIDTH);
    setState(3662);
    match(VerilogParser::LP);
    setState(3663);
    controlled_reference_event();
    setState(3664);
    match(VerilogParser::CO);
    setState(3665);
    timing_check_limit();
    setState(3667);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3666);
      threshold_opt();
    }
    setState(3669);
    match(VerilogParser::RP);
    setState(3670);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Threshold_optContext ------------------------------------------------------------------

VerilogParser::Threshold_optContext::Threshold_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Threshold_optContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Threshold_optContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::ThresholdContext* VerilogParser::Threshold_optContext::threshold() {
  return getRuleContext<VerilogParser::ThresholdContext>(0);
}

VerilogParser::NotifierContext* VerilogParser::Threshold_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Threshold_optContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold_opt;
}


std::any VerilogParser::Threshold_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Threshold_optContext* VerilogParser::threshold_opt() {
  Threshold_optContext *_localctx = _tracker.createInstance<Threshold_optContext>(_ctx, getState());
  enterRule(_localctx, 544, VerilogParser::RuleThreshold_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3672);
    match(VerilogParser::CO);
    setState(3673);
    threshold();
    setState(3676);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3674);
      match(VerilogParser::CO);
      setState(3675);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nochange_timing_checkContext ------------------------------------------------------------------

VerilogParser::Nochange_timing_checkContext::Nochange_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::DLNOCHANGE() {
  return getToken(VerilogParser::DLNOCHANGE, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Nochange_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Nochange_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Nochange_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::start_edge_offset() {
  return getRuleContext<VerilogParser::Start_edge_offsetContext>(0);
}

VerilogParser::End_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::end_edge_offset() {
  return getRuleContext<VerilogParser::End_edge_offsetContext>(0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Nochange_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Nochange_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleNochange_timing_check;
}


std::any VerilogParser::Nochange_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNochange_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::nochange_timing_check() {
  Nochange_timing_checkContext *_localctx = _tracker.createInstance<Nochange_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 546, VerilogParser::RuleNochange_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3678);
    match(VerilogParser::DLNOCHANGE);
    setState(3679);
    match(VerilogParser::LP);
    setState(3680);
    reference_event();
    setState(3681);
    match(VerilogParser::CO);
    setState(3682);
    data_event();
    setState(3683);
    match(VerilogParser::CO);
    setState(3684);
    start_edge_offset();
    setState(3685);
    match(VerilogParser::CO);
    setState(3686);
    end_edge_offset();
    setState(3688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3687);
      notifier_opt();
    }
    setState(3690);
    match(VerilogParser::RP);
    setState(3691);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_conditionContext ------------------------------------------------------------------

VerilogParser::Checktime_conditionContext::Checktime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Checktime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Checktime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_condition;
}


std::any VerilogParser::Checktime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_conditionContext* VerilogParser::checktime_condition() {
  Checktime_conditionContext *_localctx = _tracker.createInstance<Checktime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 548, VerilogParser::RuleChecktime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3693);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_reference_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_reference_eventContext::Controlled_reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::Controlled_reference_eventContext::controlled_timing_check_event() {
  return getRuleContext<VerilogParser::Controlled_timing_check_eventContext>(0);
}


size_t VerilogParser::Controlled_reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_reference_event;
}


std::any VerilogParser::Controlled_reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_reference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::controlled_reference_event() {
  Controlled_reference_eventContext *_localctx = _tracker.createInstance<Controlled_reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 550, VerilogParser::RuleControlled_reference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3695);
    controlled_timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_eventContext ------------------------------------------------------------------

VerilogParser::Data_eventContext::Data_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Data_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Data_eventContext::getRuleIndex() const {
  return VerilogParser::RuleData_event;
}


std::any VerilogParser::Data_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_eventContext* VerilogParser::data_event() {
  Data_eventContext *_localctx = _tracker.createInstance<Data_eventContext>(_ctx, getState());
  enterRule(_localctx, 552, VerilogParser::RuleData_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3697);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_dataContext ------------------------------------------------------------------

VerilogParser::Delayed_dataContext::Delayed_dataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_dataContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_dataContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_dataContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data;
}


std::any VerilogParser::Delayed_dataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_dataContext* VerilogParser::delayed_data() {
  Delayed_dataContext *_localctx = _tracker.createInstance<Delayed_dataContext>(_ctx, getState());
  enterRule(_localctx, 554, VerilogParser::RuleDelayed_data);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3699);
    terminal_identifier();
    setState(3704);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3700);
      match(VerilogParser::LB);
      setState(3701);
      constant_mintypmax_expression();
      setState(3702);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_referenceContext ------------------------------------------------------------------

VerilogParser::Delayed_referenceContext::Delayed_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_referenceContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_referenceContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_referenceContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_reference;
}


std::any VerilogParser::Delayed_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_referenceContext* VerilogParser::delayed_reference() {
  Delayed_referenceContext *_localctx = _tracker.createInstance<Delayed_referenceContext>(_ctx, getState());
  enterRule(_localctx, 556, VerilogParser::RuleDelayed_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3706);
    terminal_identifier();
    setState(3711);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3707);
      match(VerilogParser::LB);
      setState(3708);
      constant_mintypmax_expression();
      setState(3709);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_edge_offsetContext ------------------------------------------------------------------

VerilogParser::End_edge_offsetContext::End_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::End_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::End_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleEnd_edge_offset;
}


std::any VerilogParser::End_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnd_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::End_edge_offsetContext* VerilogParser::end_edge_offset() {
  End_edge_offsetContext *_localctx = _tracker.createInstance<End_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 558, VerilogParser::RuleEnd_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3713);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flagContext ------------------------------------------------------------------

VerilogParser::Event_based_flagContext::Event_based_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Event_based_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Event_based_flagContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag;
}


std::any VerilogParser::Event_based_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flagContext* VerilogParser::event_based_flag() {
  Event_based_flagContext *_localctx = _tracker.createInstance<Event_based_flagContext>(_ctx, getState());
  enterRule(_localctx, 560, VerilogParser::RuleEvent_based_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3715);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotifierContext ------------------------------------------------------------------

VerilogParser::NotifierContext::NotifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::NotifierContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}


size_t VerilogParser::NotifierContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier;
}


std::any VerilogParser::NotifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NotifierContext* VerilogParser::notifier() {
  NotifierContext *_localctx = _tracker.createInstance<NotifierContext>(_ctx, getState());
  enterRule(_localctx, 562, VerilogParser::RuleNotifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3717);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reference_eventContext ------------------------------------------------------------------

VerilogParser::Reference_eventContext::Reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Reference_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleReference_event;
}


std::any VerilogParser::Reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reference_eventContext* VerilogParser::reference_event() {
  Reference_eventContext *_localctx = _tracker.createInstance<Reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 564, VerilogParser::RuleReference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3719);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flagContext ------------------------------------------------------------------

VerilogParser::Remain_active_flagContext::Remain_active_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Remain_active_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Remain_active_flagContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag;
}


std::any VerilogParser::Remain_active_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flagContext* VerilogParser::remain_active_flag() {
  Remain_active_flagContext *_localctx = _tracker.createInstance<Remain_active_flagContext>(_ctx, getState());
  enterRule(_localctx, 566, VerilogParser::RuleRemain_active_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3721);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_conditionContext ------------------------------------------------------------------

VerilogParser::Stamptime_conditionContext::Stamptime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Stamptime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Stamptime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_condition;
}


std::any VerilogParser::Stamptime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::stamptime_condition() {
  Stamptime_conditionContext *_localctx = _tracker.createInstance<Stamptime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 568, VerilogParser::RuleStamptime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3723);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_edge_offsetContext ------------------------------------------------------------------

VerilogParser::Start_edge_offsetContext::Start_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Start_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Start_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleStart_edge_offset;
}


std::any VerilogParser::Start_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStart_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::start_edge_offset() {
  Start_edge_offsetContext *_localctx = _tracker.createInstance<Start_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 570, VerilogParser::RuleStart_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3725);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThresholdContext ------------------------------------------------------------------

VerilogParser::ThresholdContext::ThresholdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::ThresholdContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::ThresholdContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold;
}


std::any VerilogParser::ThresholdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ThresholdContext* VerilogParser::threshold() {
  ThresholdContext *_localctx = _tracker.createInstance<ThresholdContext>(_ctx, getState());
  enterRule(_localctx, 572, VerilogParser::RuleThreshold);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3727);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_limitContext ------------------------------------------------------------------

VerilogParser::Timing_check_limitContext::Timing_check_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Timing_check_limitContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Timing_check_limitContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_limit;
}


std::any VerilogParser::Timing_check_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_limit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_limitContext* VerilogParser::timing_check_limit() {
  Timing_check_limitContext *_localctx = _tracker.createInstance<Timing_check_limitContext>(_ctx, getState());
  enterRule(_localctx, 574, VerilogParser::RuleTiming_check_limit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3729);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Timing_check_eventContext::Timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event;
}


std::any VerilogParser::Timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_eventContext* VerilogParser::timing_check_event() {
  Timing_check_eventContext *_localctx = _tracker.createInstance<Timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 576, VerilogParser::RuleTiming_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3732);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 4504699138998273) != 0)) {
      setState(3731);
      timing_check_event_control();
    }
    setState(3734);
    specify_terminal_descriptor();
    setState(3737);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3735);
      match(VerilogParser::AMAMAM);
      setState(3736);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_timing_check_eventContext::Controlled_timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Controlled_timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Controlled_timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Controlled_timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_timing_check_event;
}


std::any VerilogParser::Controlled_timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_timing_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::controlled_timing_check_event() {
  Controlled_timing_check_eventContext *_localctx = _tracker.createInstance<Controlled_timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 578, VerilogParser::RuleControlled_timing_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3739);
    timing_check_event_control();
    setState(3740);
    specify_terminal_descriptor();
    setState(3743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3741);
      match(VerilogParser::AMAMAM);
      setState(3742);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_event_controlContext ------------------------------------------------------------------

VerilogParser::Timing_check_event_controlContext::Timing_check_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::Timing_check_event_controlContext::edge_control_specifier() {
  return getRuleContext<VerilogParser::Edge_control_specifierContext>(0);
}


size_t VerilogParser::Timing_check_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event_control;
}


std::any VerilogParser::Timing_check_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::timing_check_event_control() {
  Timing_check_event_controlContext *_localctx = _tracker.createInstance<Timing_check_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 580, VerilogParser::RuleTiming_check_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3748);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::POSEDGE: {
        enterOuterAlt(_localctx, 1);
        setState(3745);
        match(VerilogParser::POSEDGE);
        break;
      }

      case VerilogParser::NEGEDGE: {
        enterOuterAlt(_localctx, 2);
        setState(3746);
        match(VerilogParser::NEGEDGE);
        break;
      }

      case VerilogParser::EDGE: {
        enterOuterAlt(_localctx, 3);
        setState(3747);
        edge_control_specifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_terminal_descriptorContext::Specify_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Specify_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_terminal_descriptor;
}


std::any VerilogParser::Specify_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::specify_terminal_descriptor() {
  Specify_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 582, VerilogParser::RuleSpecify_terminal_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3752);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3750);
      specify_input_terminal_descriptor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3751);
      specify_output_terminal_descriptor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_control_specifierContext ------------------------------------------------------------------

VerilogParser::Edge_control_specifierContext::Edge_control_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::EDGE() {
  return getToken(VerilogParser::EDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Edge_descriptorContext *> VerilogParser::Edge_control_specifierContext::edge_descriptor() {
  return getRuleContexts<VerilogParser::Edge_descriptorContext>();
}

VerilogParser::Edge_descriptorContext* VerilogParser::Edge_control_specifierContext::edge_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Edge_descriptorContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Edge_control_specifierContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Edge_control_specifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_control_specifier;
}


std::any VerilogParser::Edge_control_specifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_control_specifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::edge_control_specifier() {
  Edge_control_specifierContext *_localctx = _tracker.createInstance<Edge_control_specifierContext>(_ctx, getState());
  enterRule(_localctx, 584, VerilogParser::RuleEdge_control_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3754);
    match(VerilogParser::EDGE);
    setState(3755);
    match(VerilogParser::LB);
    setState(3756);
    edge_descriptor();
    setState(3761);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3757);
      match(VerilogParser::CO);
      setState(3758);
      edge_descriptor();
      setState(3763);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3764);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_descriptorContext ------------------------------------------------------------------

VerilogParser::Edge_descriptorContext::Edge_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_descriptorContext::EDGE_DESCRIPTOR() {
  return getToken(VerilogParser::EDGE_DESCRIPTOR, 0);
}


size_t VerilogParser::Edge_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_descriptor;
}


std::any VerilogParser::Edge_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_descriptorContext* VerilogParser::edge_descriptor() {
  Edge_descriptorContext *_localctx = _tracker.createInstance<Edge_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 586, VerilogParser::RuleEdge_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3766);
    match(VerilogParser::EDGE_DESCRIPTOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Timing_check_conditionContext::Timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::Timing_check_conditionContext::scalar_timing_check_condition() {
  return getRuleContext<VerilogParser::Scalar_timing_check_conditionContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_condition;
}


std::any VerilogParser::Timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::timing_check_condition() {
  Timing_check_conditionContext *_localctx = _tracker.createInstance<Timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 588, VerilogParser::RuleTiming_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3773);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3768);
      scalar_timing_check_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3769);
      match(VerilogParser::LP);
      setState(3770);
      scalar_timing_check_condition();
      setState(3771);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Scalar_timing_check_conditionContext::Scalar_timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Scalar_timing_check_conditionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

VerilogParser::Scalar_constantContext* VerilogParser::Scalar_timing_check_conditionContext::scalar_constant() {
  return getRuleContext<VerilogParser::Scalar_constantContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}


size_t VerilogParser::Scalar_timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_timing_check_condition;
}


std::any VerilogParser::Scalar_timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_timing_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::scalar_timing_check_condition() {
  Scalar_timing_check_conditionContext *_localctx = _tracker.createInstance<Scalar_timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 590, VerilogParser::RuleScalar_timing_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3794);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3775);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3776);
      match(VerilogParser::TI);
      setState(3777);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3778);
      expression(0);
      setState(3779);
      match(VerilogParser::EQEQ);
      setState(3780);
      scalar_constant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3782);
      expression(0);
      setState(3783);
      match(VerilogParser::EQEQEQ);
      setState(3784);
      scalar_constant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3786);
      expression(0);
      setState(3787);
      match(VerilogParser::EMEQ);
      setState(3788);
      scalar_constant();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3790);
      expression(0);
      setState(3791);
      match(VerilogParser::EMEQEQ);
      setState(3792);
      scalar_constant();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_constantContext ------------------------------------------------------------------

VerilogParser::Scalar_constantContext::Scalar_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Scalar_constantContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Scalar_constantContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Scalar_constantContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_constant;
}


std::any VerilogParser::Scalar_constantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_constant(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_constantContext* VerilogParser::scalar_constant() {
  Scalar_constantContext *_localctx = _tracker.createInstance<Scalar_constantContext>(_ctx, getState());
  enterRule(_localctx, 592, VerilogParser::RuleScalar_constant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3798);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3796);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3797);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcatenationContext ------------------------------------------------------------------

VerilogParser::ConcatenationContext::ConcatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::ConcatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ConcatenationContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ConcatenationContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::ConcatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::ConcatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConcatenation;
}


std::any VerilogParser::ConcatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConcatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ConcatenationContext* VerilogParser::concatenation() {
  ConcatenationContext *_localctx = _tracker.createInstance<ConcatenationContext>(_ctx, getState());
  enterRule(_localctx, 594, VerilogParser::RuleConcatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3800);
    match(VerilogParser::LC);
    setState(3801);
    expression(0);
    setState(3806);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3802);
      match(VerilogParser::CO);
      setState(3803);
      expression(0);
      setState(3808);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3809);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_concatenationContext::Constant_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_concatenationContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_concatenationContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_concatenation;
}


std::any VerilogParser::Constant_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_concatenationContext* VerilogParser::constant_concatenation() {
  Constant_concatenationContext *_localctx = _tracker.createInstance<Constant_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 596, VerilogParser::RuleConstant_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3811);
    match(VerilogParser::LC);
    setState(3812);
    constant_expression(0);
    setState(3817);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3813);
      match(VerilogParser::CO);
      setState(3814);
      constant_expression(0);
      setState(3819);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3820);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_multiple_concatenationContext::Constant_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_multiple_concatenationContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Constant_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_multiple_concatenation;
}


std::any VerilogParser::Constant_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::constant_multiple_concatenation() {
  Constant_multiple_concatenationContext *_localctx = _tracker.createInstance<Constant_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 598, VerilogParser::RuleConstant_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3822);
    match(VerilogParser::LC);
    setState(3823);
    constant_expression(0);
    setState(3824);
    constant_concatenation();
    setState(3825);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_concatenationContext::Module_path_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_concatenationContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_concatenationContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_path_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_concatenation;
}


std::any VerilogParser::Module_path_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::module_path_concatenation() {
  Module_path_concatenationContext *_localctx = _tracker.createInstance<Module_path_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 600, VerilogParser::RuleModule_path_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3827);
    match(VerilogParser::LC);
    setState(3828);
    module_path_expression(0);
    setState(3833);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3829);
      match(VerilogParser::CO);
      setState(3830);
      module_path_expression(0);
      setState(3835);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3836);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_multiple_concatenationContext::Module_path_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Module_path_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_multiple_concatenationContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Module_path_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_multiple_concatenation;
}


std::any VerilogParser::Module_path_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::module_path_multiple_concatenation() {
  Module_path_multiple_concatenationContext *_localctx = _tracker.createInstance<Module_path_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 602, VerilogParser::RuleModule_path_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3838);
    match(VerilogParser::LC);
    setState(3839);
    constant_expression(0);
    setState(3840);
    module_path_concatenation();
    setState(3841);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Multiple_concatenationContext::Multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::Multiple_concatenationContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleMultiple_concatenation;
}


std::any VerilogParser::Multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMultiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::multiple_concatenation() {
  Multiple_concatenationContext *_localctx = _tracker.createInstance<Multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 604, VerilogParser::RuleMultiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3843);
    match(VerilogParser::LC);
    setState(3844);
    constant_expression(0);
    setState(3845);
    concatenation();
    setState(3846);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_function_callContext::Constant_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Function_identifierContext* VerilogParser::Constant_function_callContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_function_call;
}


std::any VerilogParser::Constant_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_function_callContext* VerilogParser::constant_function_call() {
  Constant_function_callContext *_localctx = _tracker.createInstance<Constant_function_callContext>(_ctx, getState());
  enterRule(_localctx, 606, VerilogParser::RuleConstant_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3848);
    function_identifier();
    setState(3852);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3849);
        attribute_instance(); 
      }
      setState(3854);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx);
    }
    setState(3855);
    match(VerilogParser::LP);
    setState(3856);
    constant_expression(0);
    setState(3861);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3857);
      match(VerilogParser::CO);
      setState(3858);
      constant_expression(0);
      setState(3863);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3864);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_system_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_system_function_callContext::Constant_system_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::Constant_system_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_system_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_system_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_system_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_system_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_system_function_call;
}


std::any VerilogParser::Constant_system_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_system_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::constant_system_function_call() {
  Constant_system_function_callContext *_localctx = _tracker.createInstance<Constant_system_function_callContext>(_ctx, getState());
  enterRule(_localctx, 608, VerilogParser::RuleConstant_system_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3866);
    system_function_identifier();
    setState(3867);
    match(VerilogParser::LP);
    setState(3868);
    constant_expression(0);
    setState(3873);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3869);
      match(VerilogParser::CO);
      setState(3870);
      constant_expression(0);
      setState(3875);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3876);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

VerilogParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Function_callContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Function_callContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Function_callContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_callContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_call;
}


std::any VerilogParser::Function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_callContext* VerilogParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 610, VerilogParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3878);
    hierarchical_identifier();
    setState(3882);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3879);
        attribute_instance(); 
      }
      setState(3884);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx);
    }
    setState(3885);
    match(VerilogParser::LP);
    setState(3886);
    expression(0);
    setState(3891);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3887);
      match(VerilogParser::CO);
      setState(3888);
      expression(0);
      setState(3893);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3894);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_callContext ------------------------------------------------------------------

VerilogParser::System_function_callContext::System_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::System_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::System_function_callContext::sys_func_call_port_list() {
  return getRuleContext<VerilogParser::Sys_func_call_port_listContext>(0);
}


size_t VerilogParser::System_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_call;
}


std::any VerilogParser::System_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_callContext* VerilogParser::system_function_call() {
  System_function_callContext *_localctx = _tracker.createInstance<System_function_callContext>(_ctx, getState());
  enterRule(_localctx, 612, VerilogParser::RuleSystem_function_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3896);
    system_function_identifier();
    setState(3898);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
    case 1: {
      setState(3897);
      sys_func_call_port_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_func_call_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_func_call_port_listContext::Sys_func_call_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Sys_func_call_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Sys_func_call_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_func_call_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_func_call_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_func_call_port_list;
}


std::any VerilogParser::Sys_func_call_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_func_call_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::sys_func_call_port_list() {
  Sys_func_call_port_listContext *_localctx = _tracker.createInstance<Sys_func_call_port_listContext>(_ctx, getState());
  enterRule(_localctx, 614, VerilogParser::RuleSys_func_call_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3900);
    match(VerilogParser::LP);
    setState(3901);
    expression(0);
    setState(3906);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3902);
      match(VerilogParser::CO);
      setState(3903);
      expression(0);
      setState(3908);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3909);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_expressionContext ------------------------------------------------------------------

VerilogParser::Base_expressionContext::Base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Base_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleBase_expression;
}


std::any VerilogParser::Base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBase_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Base_expressionContext* VerilogParser::base_expression() {
  Base_expressionContext *_localctx = _tracker.createInstance<Base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 616, VerilogParser::RuleBase_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3911);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_base_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_base_expressionContext::Constant_base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_base_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Constant_base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_base_expression;
}


std::any VerilogParser::Constant_base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_base_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::constant_base_expression() {
  Constant_base_expressionContext *_localctx = _tracker.createInstance<Constant_base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 618, VerilogParser::RuleConstant_base_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3913);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_primaryContext* VerilogParser::Constant_expressionContext::constant_primary() {
  return getRuleContext<VerilogParser::Constant_primaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::Constant_expressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_expression;
}


std::any VerilogParser::Constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Constant_expressionContext* VerilogParser::constant_expression() {
   return constant_expression(0);
}

VerilogParser::Constant_expressionContext* VerilogParser::constant_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, parentState);
  VerilogParser::Constant_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 620;
  enterRecursionRule(_localctx, 620, VerilogParser::RuleConstant_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3926);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(3916);
        constant_primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI: {
        setState(3917);
        unary_operator();
        setState(3921);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3918);
            attribute_instance(); 
          }
          setState(3923);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx);
        }
        setState(3924);
        constant_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4041);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4039);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3928);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(3929);
          match(VerilogParser::ASAS);
          setState(3933);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3930);
              attribute_instance(); 
            }
            setState(3935);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx);
          }
          setState(3936);
          constant_expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3937);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(3938);
          _la = _input->LA(1);
          if (!(((((_la - 167) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 167)) & 67371009) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3942);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3939);
              attribute_instance(); 
            }
            setState(3944);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
          }
          setState(3945);
          constant_expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3946);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(3947);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3951);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3948);
              attribute_instance(); 
            }
            setState(3953);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
          }
          setState(3954);
          constant_expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3955);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(3956);
          _la = _input->LA(1);
          if (!(((((_la - 146) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 146)) & 8227) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3960);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3957);
              attribute_instance(); 
            }
            setState(3962);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
          }
          setState(3963);
          constant_expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3964);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(3965);
          _la = _input->LA(1);
          if (!(((((_la - 150) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 150)) & 8858370305) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3969);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3966);
              attribute_instance(); 
            }
            setState(3971);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
          }
          setState(3972);
          constant_expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3973);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(3974);
          _la = _input->LA(1);
          if (!(((((_la - 144) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 144)) & 9219) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3978);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3975);
              attribute_instance(); 
            }
            setState(3980);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          }
          setState(3981);
          constant_expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3982);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(3983);
          match(VerilogParser::AM);
          setState(3987);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3984);
              attribute_instance(); 
            }
            setState(3989);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          }
          setState(3990);
          constant_expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3991);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(3992);
          _la = _input->LA(1);
          if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 156)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3996);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3993);
              attribute_instance(); 
            }
            setState(3998);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          }
          setState(3999);
          constant_expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4000);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4001);
          match(VerilogParser::VL);
          setState(4005);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4002);
              attribute_instance(); 
            }
            setState(4007);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          }
          setState(4008);
          constant_expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4009);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4010);
          match(VerilogParser::AMAM);
          setState(4014);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4011);
              attribute_instance(); 
            }
            setState(4016);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
          }
          setState(4017);
          constant_expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4018);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4019);
          match(VerilogParser::VLVL);
          setState(4023);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4020);
              attribute_instance(); 
            }
            setState(4025);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
          }
          setState(4026);
          constant_expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4027);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4028);
          match(VerilogParser::QM);
          setState(4032);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4029);
              attribute_instance(); 
            }
            setState(4034);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
          }
          setState(4035);
          constant_expression(0);
          setState(4036);
          match(VerilogParser::CL);
          setState(4037);
          constant_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4043);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Constant_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_mintypmax_expressionContext::Constant_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_mintypmax_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_mintypmax_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Constant_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Constant_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_mintypmax_expression;
}


std::any VerilogParser::Constant_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::constant_mintypmax_expression() {
  Constant_mintypmax_expressionContext *_localctx = _tracker.createInstance<Constant_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 622, VerilogParser::RuleConstant_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4044);
    constant_expression(0);
    setState(4050);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4045);
      match(VerilogParser::CL);
      setState(4046);
      constant_expression(0);
      setState(4047);
      match(VerilogParser::CL);
      setState(4048);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_range_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_range_expressionContext::Constant_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_range_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::Constant_range_expressionContext::constant_base_expression() {
  return getRuleContext<VerilogParser::Constant_base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Constant_range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Constant_range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_range_expression;
}


std::any VerilogParser::Constant_range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_range_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::constant_range_expression() {
  Constant_range_expressionContext *_localctx = _tracker.createInstance<Constant_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 624, VerilogParser::RuleConstant_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4065);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4052);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4053);
      msb_constant_expression();
      setState(4054);
      match(VerilogParser::CL);
      setState(4055);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4057);
      constant_base_expression();
      setState(4058);
      match(VerilogParser::PLCL);
      setState(4059);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4061);
      constant_base_expression();
      setState(4062);
      match(VerilogParser::MICL);
      setState(4063);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dimension_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Dimension_constant_expressionContext::Dimension_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Dimension_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Dimension_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension_constant_expression;
}


std::any VerilogParser::Dimension_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::dimension_constant_expression() {
  Dimension_constant_expressionContext *_localctx = _tracker.createInstance<Dimension_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 626, VerilogParser::RuleDimension_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4067);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

VerilogParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::PrimaryContext* VerilogParser::ExpressionContext::primary() {
  return getRuleContext<VerilogParser::PrimaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::ExpressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::ExpressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::ExpressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ExpressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ExpressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::ExpressionContext::getRuleIndex() const {
  return VerilogParser::RuleExpression;
}


std::any VerilogParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::ExpressionContext* VerilogParser::expression() {
   return expression(0);
}

VerilogParser::ExpressionContext* VerilogParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  VerilogParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 628;
  enterRecursionRule(_localctx, 628, VerilogParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4080);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(4070);
        primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI: {
        setState(4071);
        unary_operator();
        setState(4075);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4072);
            attribute_instance(); 
          }
          setState(4077);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
        }
        setState(4078);
        primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4195);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4193);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4082);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4083);
          match(VerilogParser::ASAS);
          setState(4087);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4084);
              attribute_instance(); 
            }
            setState(4089);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
          }
          setState(4090);
          expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4091);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(4092);
          _la = _input->LA(1);
          if (!(((((_la - 167) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 167)) & 67371009) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4096);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4093);
              attribute_instance(); 
            }
            setState(4098);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx);
          }
          setState(4099);
          expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4100);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(4101);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4105);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4102);
              attribute_instance(); 
            }
            setState(4107);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx);
          }
          setState(4108);
          expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4109);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(4110);
          _la = _input->LA(1);
          if (!(((((_la - 146) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 146)) & 8227) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4114);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4111);
              attribute_instance(); 
            }
            setState(4116);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
          }
          setState(4117);
          expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4118);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(4119);
          _la = _input->LA(1);
          if (!(((((_la - 150) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 150)) & 8858370305) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4123);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4120);
              attribute_instance(); 
            }
            setState(4125);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
          }
          setState(4126);
          expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4127);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4128);
          _la = _input->LA(1);
          if (!(((((_la - 144) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 144)) & 9219) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4132);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4129);
              attribute_instance(); 
            }
            setState(4134);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          }
          setState(4135);
          expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4136);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4137);
          match(VerilogParser::AM);
          setState(4141);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4138);
              attribute_instance(); 
            }
            setState(4143);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          }
          setState(4144);
          expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4145);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4146);
          _la = _input->LA(1);
          if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 156)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4150);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4147);
              attribute_instance(); 
            }
            setState(4152);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          }
          setState(4153);
          expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4154);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4155);
          match(VerilogParser::VL);
          setState(4159);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4156);
              attribute_instance(); 
            }
            setState(4161);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          }
          setState(4162);
          expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4163);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4164);
          match(VerilogParser::AMAM);
          setState(4168);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4165);
              attribute_instance(); 
            }
            setState(4170);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx);
          }
          setState(4171);
          expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4172);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4173);
          match(VerilogParser::VLVL);
          setState(4177);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4174);
              attribute_instance(); 
            }
            setState(4179);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
          }
          setState(4180);
          expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4181);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4182);
          match(VerilogParser::QM);
          setState(4186);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4183);
              attribute_instance(); 
            }
            setState(4188);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
          }
          setState(4189);
          expression(0);
          setState(4190);
          match(VerilogParser::CL);
          setState(4191);
          expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4197);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Lsb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Lsb_constant_expressionContext::Lsb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Lsb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Lsb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleLsb_constant_expression;
}


std::any VerilogParser::Lsb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::lsb_constant_expression() {
  Lsb_constant_expressionContext *_localctx = _tracker.createInstance<Lsb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 630, VerilogParser::RuleLsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4198);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Mintypmax_expressionContext::Mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Mintypmax_expressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Mintypmax_expressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMintypmax_expression;
}


std::any VerilogParser::Mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::mintypmax_expression() {
  Mintypmax_expressionContext *_localctx = _tracker.createInstance<Mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 632, VerilogParser::RuleMintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4200);
    expression(0);
    setState(4206);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4201);
      match(VerilogParser::CL);
      setState(4202);
      expression(0);
      setState(4203);
      match(VerilogParser::CL);
      setState(4204);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_expressionContext::Module_path_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_path_primaryContext* VerilogParser::Module_path_expressionContext::module_path_primary() {
  return getRuleContext<VerilogParser::Module_path_primaryContext>(0);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::Module_path_expressionContext::unary_module_path_operator() {
  return getRuleContext<VerilogParser::Unary_module_path_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_path_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_path_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Module_path_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_expression;
}


std::any VerilogParser::Module_path_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression() {
   return module_path_expression(0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Module_path_expressionContext *_localctx = _tracker.createInstance<Module_path_expressionContext>(_ctx, parentState);
  VerilogParser::Module_path_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 634;
  enterRecursionRule(_localctx, 634, VerilogParser::RuleModule_path_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4219);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(4209);
        module_path_primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::TI: {
        setState(4210);
        unary_module_path_operator();
        setState(4214);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4211);
            attribute_instance(); 
          }
          setState(4216);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
        }
        setState(4217);
        module_path_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4289);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4287);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4221);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4222);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::EQEQ

          || _la == VerilogParser::EMEQ)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4226);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4223);
              attribute_instance(); 
            }
            setState(4228);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx);
          }
          setState(4229);
          module_path_expression(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4230);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4231);
          match(VerilogParser::AM);
          setState(4235);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4232);
              attribute_instance(); 
            }
            setState(4237);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
          }
          setState(4238);
          module_path_expression(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4239);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4240);
          _la = _input->LA(1);
          if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 156)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4244);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4241);
              attribute_instance(); 
            }
            setState(4246);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx);
          }
          setState(4247);
          module_path_expression(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4248);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4249);
          match(VerilogParser::VL);
          setState(4253);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4250);
              attribute_instance(); 
            }
            setState(4255);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
          }
          setState(4256);
          module_path_expression(5);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4257);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4258);
          match(VerilogParser::AMAM);
          setState(4262);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4259);
              attribute_instance(); 
            }
            setState(4264);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx);
          }
          setState(4265);
          module_path_expression(4);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4266);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4267);
          match(VerilogParser::VLVL);
          setState(4271);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4268);
              attribute_instance(); 
            }
            setState(4273);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
          }
          setState(4274);
          module_path_expression(3);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4275);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4276);
          match(VerilogParser::QM);
          setState(4280);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4277);
              attribute_instance(); 
            }
            setState(4282);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx);
          }
          setState(4283);
          module_path_expression(0);
          setState(4284);
          match(VerilogParser::CL);
          setState(4285);
          module_path_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4291);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Module_path_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_mintypmax_expressionContext::Module_path_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Module_path_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Module_path_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_mintypmax_expression;
}


std::any VerilogParser::Module_path_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::module_path_mintypmax_expression() {
  Module_path_mintypmax_expressionContext *_localctx = _tracker.createInstance<Module_path_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 636, VerilogParser::RuleModule_path_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4292);
    module_path_expression(0);
    setState(4298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4293);
      match(VerilogParser::CL);
      setState(4294);
      module_path_expression(0);
      setState(4295);
      match(VerilogParser::CL);
      setState(4296);
      module_path_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Msb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Msb_constant_expressionContext::Msb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Msb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Msb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMsb_constant_expression;
}


std::any VerilogParser::Msb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::msb_constant_expression() {
  Msb_constant_expressionContext *_localctx = _tracker.createInstance<Msb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 638, VerilogParser::RuleMsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4300);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_expressionContext ------------------------------------------------------------------

VerilogParser::Range_expressionContext::Range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Range_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Base_expressionContext* VerilogParser::Range_expressionContext::base_expression() {
  return getRuleContext<VerilogParser::Base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleRange_expression;
}


std::any VerilogParser::Range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_expressionContext* VerilogParser::range_expression() {
  Range_expressionContext *_localctx = _tracker.createInstance<Range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 640, VerilogParser::RuleRange_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4315);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4302);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4303);
      msb_constant_expression();
      setState(4304);
      match(VerilogParser::CL);
      setState(4305);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4307);
      base_expression();
      setState(4308);
      match(VerilogParser::PLCL);
      setState(4309);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4311);
      base_expression();
      setState(4312);
      match(VerilogParser::MICL);
      setState(4313);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Width_constant_expressionContext::Width_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Width_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Width_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_constant_expression;
}


std::any VerilogParser::Width_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::width_constant_expression() {
  Width_constant_expressionContext *_localctx = _tracker.createInstance<Width_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 642, VerilogParser::RuleWidth_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4317);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_primaryContext ------------------------------------------------------------------

VerilogParser::Constant_primaryContext::Constant_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Constant_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Constant_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Constant_primaryContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_primaryContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::Constant_primaryContext::constant_multiple_concatenation() {
  return getRuleContext<VerilogParser::Constant_multiple_concatenationContext>(0);
}

VerilogParser::Constant_function_callContext* VerilogParser::Constant_primaryContext::constant_function_call() {
  return getRuleContext<VerilogParser::Constant_function_callContext>(0);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::Constant_primaryContext::constant_system_function_call() {
  return getRuleContext<VerilogParser::Constant_system_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Constant_primaryContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::Constant_primaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::Constant_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_primary;
}


std::any VerilogParser::Constant_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_primaryContext* VerilogParser::constant_primary() {
  Constant_primaryContext *_localctx = _tracker.createInstance<Constant_primaryContext>(_ctx, getState());
  enterRule(_localctx, 644, VerilogParser::RuleConstant_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4336);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4319);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4320);
      identifier();
      setState(4325);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx)) {
      case 1: {
        setState(4321);
        match(VerilogParser::LB);
        setState(4322);
        constant_range_expression();
        setState(4323);
        match(VerilogParser::RB);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4327);
      constant_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4328);
      constant_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4329);
      constant_function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4330);
      constant_system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4331);
      match(VerilogParser::LP);
      setState(4332);
      constant_mintypmax_expression();
      setState(4333);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4335);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_primaryContext ------------------------------------------------------------------

VerilogParser::Module_path_primaryContext::Module_path_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Module_path_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Module_path_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_multiple_concatenation() {
  return getRuleContext<VerilogParser::Module_path_multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::Module_path_primaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::Module_path_primaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::Module_path_primaryContext::module_path_mintypmax_expression() {
  return getRuleContext<VerilogParser::Module_path_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_path_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_primary;
}


std::any VerilogParser::Module_path_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_primaryContext* VerilogParser::module_path_primary() {
  Module_path_primaryContext *_localctx = _tracker.createInstance<Module_path_primaryContext>(_ctx, getState());
  enterRule(_localctx, 646, VerilogParser::RuleModule_path_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4348);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4338);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4339);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4340);
      module_path_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4341);
      module_path_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4342);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4343);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4344);
      match(VerilogParser::LP);
      setState(4345);
      module_path_mintypmax_expression();
      setState(4346);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

VerilogParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::PrimaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::PrimaryContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::PrimaryContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::PrimaryContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::PrimaryContext::multiple_concatenation() {
  return getRuleContext<VerilogParser::Multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::PrimaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::PrimaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::PrimaryContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::PrimaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::PrimaryContext::getRuleIndex() const {
  return VerilogParser::RulePrimary;
}


std::any VerilogParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPrimary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PrimaryContext* VerilogParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 648, VerilogParser::RulePrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4350);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4351);
      hierarchical_identifier();
      setState(4353);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx)) {
      case 1: {
        setState(4352);
        select_();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4355);
      concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4356);
      multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4357);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4358);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4359);
      match(VerilogParser::LP);
      setState(4360);
      mintypmax_expression();
      setState(4361);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4363);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_Context ------------------------------------------------------------------

VerilogParser::Select_Context::Select_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Select_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Range_expressionContext* VerilogParser::Select_Context::range_expression() {
  return getRuleContext<VerilogParser::Range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Select_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Select_Context::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Select_Context::getRuleIndex() const {
  return VerilogParser::RuleSelect_;
}


std::any VerilogParser::Select_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSelect_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Select_Context* VerilogParser::select_() {
  Select_Context *_localctx = _tracker.createInstance<Select_Context>(_ctx, getState());
  enterRule(_localctx, 650, VerilogParser::RuleSelect_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4367);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
    case 1: {
      setState(4366);
      bit_select();
      break;
    }

    default:
      break;
    }
    setState(4369);
    match(VerilogParser::LB);
    setState(4370);
    range_expression();
    setState(4371);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_selectContext ------------------------------------------------------------------

VerilogParser::Bit_selectContext::Bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Bit_selectContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Bit_selectContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleBit_select;
}


std::any VerilogParser::Bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Bit_selectContext* VerilogParser::bit_select() {
  Bit_selectContext *_localctx = _tracker.createInstance<Bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 652, VerilogParser::RuleBit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4377); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4373);
              match(VerilogParser::LB);
              setState(4374);
              expression(0);
              setState(4375);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4379); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 452, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_lvalueContext ------------------------------------------------------------------

VerilogParser::Net_lvalueContext::Net_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Net_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Const_selectContext* VerilogParser::Net_lvalueContext::const_select() {
  return getRuleContext<VerilogParser::Const_selectContext>(0);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Net_lvalueContext *> VerilogParser::Net_lvalueContext::net_lvalue() {
  return getRuleContexts<VerilogParser::Net_lvalueContext>();
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_lvalueContext::net_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Net_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Net_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Net_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleNet_lvalue;
}


std::any VerilogParser::Net_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_lvalueContext* VerilogParser::net_lvalue() {
  Net_lvalueContext *_localctx = _tracker.createInstance<Net_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 654, VerilogParser::RuleNet_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4396);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4381);
        hierarchical_identifier();
        setState(4383);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4382);
          const_select();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4385);
        match(VerilogParser::LC);
        setState(4386);
        net_lvalue();
        setState(4391);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4387);
          match(VerilogParser::CO);
          setState(4388);
          net_lvalue();
          setState(4393);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4394);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_selectContext ------------------------------------------------------------------

VerilogParser::Const_selectContext::Const_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Const_selectContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Const_selectContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Const_selectContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Const_selectContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Const_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_select;
}


std::any VerilogParser::Const_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_selectContext* VerilogParser::const_select() {
  Const_selectContext *_localctx = _tracker.createInstance<Const_selectContext>(_ctx, getState());
  enterRule(_localctx, 656, VerilogParser::RuleConst_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4399);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
    case 1: {
      setState(4398);
      const_bit_select();
      break;
    }

    default:
      break;
    }
    setState(4401);
    match(VerilogParser::LB);
    setState(4402);
    constant_range_expression();
    setState(4403);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_bit_selectContext ------------------------------------------------------------------

VerilogParser::Const_bit_selectContext::Const_bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Const_bit_selectContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Const_bit_selectContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Const_bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_bit_select;
}


std::any VerilogParser::Const_bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_bit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_bit_selectContext* VerilogParser::const_bit_select() {
  Const_bit_selectContext *_localctx = _tracker.createInstance<Const_bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 658, VerilogParser::RuleConst_bit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4409); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4405);
              match(VerilogParser::LB);
              setState(4406);
              constant_expression(0);
              setState(4407);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4411); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 457, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_lvalueContext ------------------------------------------------------------------

VerilogParser::Variable_lvalueContext::Variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Variable_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::Variable_lvalueContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Variable_lvalueContext *> VerilogParser::Variable_lvalueContext::variable_lvalue() {
  return getRuleContexts<VerilogParser::Variable_lvalueContext>();
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_lvalueContext::variable_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Variable_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Variable_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_lvalue;
}


std::any VerilogParser::Variable_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_lvalueContext* VerilogParser::variable_lvalue() {
  Variable_lvalueContext *_localctx = _tracker.createInstance<Variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 660, VerilogParser::RuleVariable_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4428);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4413);
        hierarchical_identifier();
        setState(4415);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4414);
          select_();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4417);
        match(VerilogParser::LC);
        setState(4418);
        variable_lvalue();
        setState(4423);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4419);
          match(VerilogParser::CO);
          setState(4420);
          variable_lvalue();
          setState(4425);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4426);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_operator;
}


std::any VerilogParser::Unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_operatorContext* VerilogParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 662, VerilogParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4430);
    _la = _input->LA(1);
    if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 276220618465) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_module_path_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_module_path_operatorContext::Unary_module_path_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_module_path_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_module_path_operator;
}


std::any VerilogParser::Unary_module_path_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_module_path_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::unary_module_path_operator() {
  Unary_module_path_operatorContext *_localctx = _tracker.createInstance<Unary_module_path_operatorContext>(_ctx, getState());
  enterRule(_localctx, 664, VerilogParser::RuleUnary_module_path_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4432);
    _la = _input->LA(1);
    if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & 274878441185) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

VerilogParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Decimal_numberContext* VerilogParser::NumberContext::decimal_number() {
  return getRuleContext<VerilogParser::Decimal_numberContext>(0);
}

VerilogParser::Octal_numberContext* VerilogParser::NumberContext::octal_number() {
  return getRuleContext<VerilogParser::Octal_numberContext>(0);
}

VerilogParser::Binary_numberContext* VerilogParser::NumberContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Hex_numberContext* VerilogParser::NumberContext::hex_number() {
  return getRuleContext<VerilogParser::Hex_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::NumberContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}


size_t VerilogParser::NumberContext::getRuleIndex() const {
  return VerilogParser::RuleNumber;
}


std::any VerilogParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NumberContext* VerilogParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 666, VerilogParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4439);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4434);
      decimal_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4435);
      octal_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4436);
      binary_number();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4437);
      hex_number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4438);
      real_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_numberContext ------------------------------------------------------------------

VerilogParser::Real_numberContext::Real_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Fixed_point_numberContext* VerilogParser::Real_numberContext::fixed_point_number() {
  return getRuleContext<VerilogParser::Fixed_point_numberContext>(0);
}

tree::TerminalNode* VerilogParser::Real_numberContext::UNIT() {
  return getToken(VerilogParser::UNIT, 0);
}

VerilogParser::Exponential_numberContext* VerilogParser::Real_numberContext::exponential_number() {
  return getRuleContext<VerilogParser::Exponential_numberContext>(0);
}


size_t VerilogParser::Real_numberContext::getRuleIndex() const {
  return VerilogParser::RuleReal_number;
}


std::any VerilogParser::Real_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_numberContext* VerilogParser::real_number() {
  Real_numberContext *_localctx = _tracker.createInstance<Real_numberContext>(_ctx, getState());
  enterRule(_localctx, 668, VerilogParser::RuleReal_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4449);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FIXED_POINT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(4441);
        fixed_point_number();
        setState(4443);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
        case 1: {
          setState(4442);
          match(VerilogParser::UNIT);
          break;
        }

        default:
          break;
        }
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(4445);
        exponential_number();
        setState(4447);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
        case 1: {
          setState(4446);
          match(VerilogParser::UNIT);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_numberContext ------------------------------------------------------------------

VerilogParser::Decimal_numberContext::Decimal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Decimal_numberContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Decimal_baseContext* VerilogParser::Decimal_numberContext::decimal_base() {
  return getRuleContext<VerilogParser::Decimal_baseContext>(0);
}

VerilogParser::Decimal_valueContext* VerilogParser::Decimal_numberContext::decimal_value() {
  return getRuleContext<VerilogParser::Decimal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Decimal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Decimal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_number;
}


std::any VerilogParser::Decimal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_numberContext* VerilogParser::decimal_number() {
  Decimal_numberContext *_localctx = _tracker.createInstance<Decimal_numberContext>(_ctx, getState());
  enterRule(_localctx, 670, VerilogParser::RuleDecimal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4451);
      unsigned_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4453);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::UNSIGNED_NUMBER) {
        setState(4452);
        size();
      }
      setState(4455);
      decimal_base();
      setState(4456);
      decimal_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_numberContext ------------------------------------------------------------------

VerilogParser::Binary_numberContext::Binary_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_baseContext* VerilogParser::Binary_numberContext::binary_base() {
  return getRuleContext<VerilogParser::Binary_baseContext>(0);
}

VerilogParser::Binary_valueContext* VerilogParser::Binary_numberContext::binary_value() {
  return getRuleContext<VerilogParser::Binary_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Binary_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Binary_numberContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_number;
}


std::any VerilogParser::Binary_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_numberContext* VerilogParser::binary_number() {
  Binary_numberContext *_localctx = _tracker.createInstance<Binary_numberContext>(_ctx, getState());
  enterRule(_localctx, 672, VerilogParser::RuleBinary_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4460);
      size();
    }
    setState(4463);
    binary_base();
    setState(4464);
    binary_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_numberContext ------------------------------------------------------------------

VerilogParser::Octal_numberContext::Octal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Octal_baseContext* VerilogParser::Octal_numberContext::octal_base() {
  return getRuleContext<VerilogParser::Octal_baseContext>(0);
}

VerilogParser::Octal_valueContext* VerilogParser::Octal_numberContext::octal_value() {
  return getRuleContext<VerilogParser::Octal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Octal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Octal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_number;
}


std::any VerilogParser::Octal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_numberContext* VerilogParser::octal_number() {
  Octal_numberContext *_localctx = _tracker.createInstance<Octal_numberContext>(_ctx, getState());
  enterRule(_localctx, 674, VerilogParser::RuleOctal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4467);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4466);
      size();
    }
    setState(4469);
    octal_base();
    setState(4470);
    octal_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_numberContext ------------------------------------------------------------------

VerilogParser::Hex_numberContext::Hex_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hex_baseContext* VerilogParser::Hex_numberContext::hex_base() {
  return getRuleContext<VerilogParser::Hex_baseContext>(0);
}

VerilogParser::Hex_valueContext* VerilogParser::Hex_numberContext::hex_value() {
  return getRuleContext<VerilogParser::Hex_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Hex_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Hex_numberContext::getRuleIndex() const {
  return VerilogParser::RuleHex_number;
}


std::any VerilogParser::Hex_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_numberContext* VerilogParser::hex_number() {
  Hex_numberContext *_localctx = _tracker.createInstance<Hex_numberContext>(_ctx, getState());
  enterRule(_localctx, 676, VerilogParser::RuleHex_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4473);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4472);
      size();
    }
    setState(4475);
    hex_base();
    setState(4476);
    hex_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeContext ------------------------------------------------------------------

VerilogParser::SizeContext::SizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::SizeContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::SizeContext::getRuleIndex() const {
  return VerilogParser::RuleSize;
}


std::any VerilogParser::SizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSize(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::SizeContext* VerilogParser::size() {
  SizeContext *_localctx = _tracker.createInstance<SizeContext>(_ctx, getState());
  enterRule(_localctx, 678, VerilogParser::RuleSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4478);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fixed_point_numberContext ------------------------------------------------------------------

VerilogParser::Fixed_point_numberContext::Fixed_point_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fixed_point_numberContext::FIXED_POINT_NUMBER() {
  return getToken(VerilogParser::FIXED_POINT_NUMBER, 0);
}


size_t VerilogParser::Fixed_point_numberContext::getRuleIndex() const {
  return VerilogParser::RuleFixed_point_number;
}


std::any VerilogParser::Fixed_point_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFixed_point_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fixed_point_numberContext* VerilogParser::fixed_point_number() {
  Fixed_point_numberContext *_localctx = _tracker.createInstance<Fixed_point_numberContext>(_ctx, getState());
  enterRule(_localctx, 680, VerilogParser::RuleFixed_point_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4480);
    match(VerilogParser::FIXED_POINT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exponential_numberContext ------------------------------------------------------------------

VerilogParser::Exponential_numberContext::Exponential_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Exponential_numberContext::EXPONENTIAL_NUMBER() {
  return getToken(VerilogParser::EXPONENTIAL_NUMBER, 0);
}


size_t VerilogParser::Exponential_numberContext::getRuleIndex() const {
  return VerilogParser::RuleExponential_number;
}


std::any VerilogParser::Exponential_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExponential_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Exponential_numberContext* VerilogParser::exponential_number() {
  Exponential_numberContext *_localctx = _tracker.createInstance<Exponential_numberContext>(_ctx, getState());
  enterRule(_localctx, 682, VerilogParser::RuleExponential_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4482);
    match(VerilogParser::EXPONENTIAL_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unsigned_numberContext ------------------------------------------------------------------

VerilogParser::Unsigned_numberContext::Unsigned_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unsigned_numberContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::Unsigned_numberContext::getRuleIndex() const {
  return VerilogParser::RuleUnsigned_number;
}


std::any VerilogParser::Unsigned_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnsigned_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unsigned_numberContext* VerilogParser::unsigned_number() {
  Unsigned_numberContext *_localctx = _tracker.createInstance<Unsigned_numberContext>(_ctx, getState());
  enterRule(_localctx, 684, VerilogParser::RuleUnsigned_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4484);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_valueContext ------------------------------------------------------------------

VerilogParser::Decimal_valueContext::Decimal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::X_OR_Z_UNDERSCORE() {
  return getToken(VerilogParser::X_OR_Z_UNDERSCORE, 0);
}


size_t VerilogParser::Decimal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_value;
}


std::any VerilogParser::Decimal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_valueContext* VerilogParser::decimal_value() {
  Decimal_valueContext *_localctx = _tracker.createInstance<Decimal_valueContext>(_ctx, getState());
  enterRule(_localctx, 686, VerilogParser::RuleDecimal_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4486);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::UNSIGNED_NUMBER

    || _la == VerilogParser::X_OR_Z_UNDERSCORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_valueContext ------------------------------------------------------------------

VerilogParser::Binary_valueContext::Binary_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_valueContext::BINARY_VALUE() {
  return getToken(VerilogParser::BINARY_VALUE, 0);
}


size_t VerilogParser::Binary_valueContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_value;
}


std::any VerilogParser::Binary_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_valueContext* VerilogParser::binary_value() {
  Binary_valueContext *_localctx = _tracker.createInstance<Binary_valueContext>(_ctx, getState());
  enterRule(_localctx, 688, VerilogParser::RuleBinary_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4488);
    match(VerilogParser::BINARY_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_valueContext ------------------------------------------------------------------

VerilogParser::Octal_valueContext::Octal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_valueContext::OCTAL_VALUE() {
  return getToken(VerilogParser::OCTAL_VALUE, 0);
}


size_t VerilogParser::Octal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_value;
}


std::any VerilogParser::Octal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_valueContext* VerilogParser::octal_value() {
  Octal_valueContext *_localctx = _tracker.createInstance<Octal_valueContext>(_ctx, getState());
  enterRule(_localctx, 690, VerilogParser::RuleOctal_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4490);
    match(VerilogParser::OCTAL_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_valueContext ------------------------------------------------------------------

VerilogParser::Hex_valueContext::Hex_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_valueContext::HEX_VALUE() {
  return getToken(VerilogParser::HEX_VALUE, 0);
}


size_t VerilogParser::Hex_valueContext::getRuleIndex() const {
  return VerilogParser::RuleHex_value;
}


std::any VerilogParser::Hex_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_valueContext* VerilogParser::hex_value() {
  Hex_valueContext *_localctx = _tracker.createInstance<Hex_valueContext>(_ctx, getState());
  enterRule(_localctx, 692, VerilogParser::RuleHex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4492);
    match(VerilogParser::HEX_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_baseContext ------------------------------------------------------------------

VerilogParser::Decimal_baseContext::Decimal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_baseContext::DECIMAL_BASE() {
  return getToken(VerilogParser::DECIMAL_BASE, 0);
}


size_t VerilogParser::Decimal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_base;
}


std::any VerilogParser::Decimal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_baseContext* VerilogParser::decimal_base() {
  Decimal_baseContext *_localctx = _tracker.createInstance<Decimal_baseContext>(_ctx, getState());
  enterRule(_localctx, 694, VerilogParser::RuleDecimal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4494);
    match(VerilogParser::DECIMAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_baseContext ------------------------------------------------------------------

VerilogParser::Binary_baseContext::Binary_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_baseContext::BINARY_BASE() {
  return getToken(VerilogParser::BINARY_BASE, 0);
}


size_t VerilogParser::Binary_baseContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_base;
}


std::any VerilogParser::Binary_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_baseContext* VerilogParser::binary_base() {
  Binary_baseContext *_localctx = _tracker.createInstance<Binary_baseContext>(_ctx, getState());
  enterRule(_localctx, 696, VerilogParser::RuleBinary_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4496);
    match(VerilogParser::BINARY_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_baseContext ------------------------------------------------------------------

VerilogParser::Octal_baseContext::Octal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_baseContext::OCTAL_BASE() {
  return getToken(VerilogParser::OCTAL_BASE, 0);
}


size_t VerilogParser::Octal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_base;
}


std::any VerilogParser::Octal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_baseContext* VerilogParser::octal_base() {
  Octal_baseContext *_localctx = _tracker.createInstance<Octal_baseContext>(_ctx, getState());
  enterRule(_localctx, 698, VerilogParser::RuleOctal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4498);
    match(VerilogParser::OCTAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_baseContext ------------------------------------------------------------------

VerilogParser::Hex_baseContext::Hex_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_baseContext::HEX_BASE() {
  return getToken(VerilogParser::HEX_BASE, 0);
}


size_t VerilogParser::Hex_baseContext::getRuleIndex() const {
  return VerilogParser::RuleHex_base;
}


std::any VerilogParser::Hex_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_baseContext* VerilogParser::hex_base() {
  Hex_baseContext *_localctx = _tracker.createInstance<Hex_baseContext>(_ctx, getState());
  enterRule(_localctx, 700, VerilogParser::RuleHex_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4500);
    match(VerilogParser::HEX_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_Context ------------------------------------------------------------------

VerilogParser::String_Context::String_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::String_Context::STRING() {
  return getToken(VerilogParser::STRING, 0);
}


size_t VerilogParser::String_Context::getRuleIndex() const {
  return VerilogParser::RuleString_;
}


std::any VerilogParser::String_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitString_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::String_Context* VerilogParser::string_() {
  String_Context *_localctx = _tracker.createInstance<String_Context>(_ctx, getState());
  enterRule(_localctx, 702, VerilogParser::RuleString_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4502);
    match(VerilogParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_instanceContext ------------------------------------------------------------------

VerilogParser::Attribute_instanceContext::Attribute_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::AS() {
  return getTokens(VerilogParser::AS);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::AS(size_t i) {
  return getToken(VerilogParser::AS, i);
}

std::vector<VerilogParser::Attr_specContext *> VerilogParser::Attribute_instanceContext::attr_spec() {
  return getRuleContexts<VerilogParser::Attr_specContext>();
}

VerilogParser::Attr_specContext* VerilogParser::Attribute_instanceContext::attr_spec(size_t i) {
  return getRuleContext<VerilogParser::Attr_specContext>(i);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Attribute_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleAttribute_instance;
}


std::any VerilogParser::Attribute_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttribute_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attribute_instanceContext* VerilogParser::attribute_instance() {
  Attribute_instanceContext *_localctx = _tracker.createInstance<Attribute_instanceContext>(_ctx, getState());
  enterRule(_localctx, 704, VerilogParser::RuleAttribute_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4504);
    match(VerilogParser::LP);
    setState(4505);
    match(VerilogParser::AS);
    setState(4506);
    attr_spec();
    setState(4511);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(4507);
      match(VerilogParser::CO);
      setState(4508);
      attr_spec();
      setState(4513);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4514);
    match(VerilogParser::AS);
    setState(4515);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_specContext ------------------------------------------------------------------

VerilogParser::Attr_specContext::Attr_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Attr_nameContext* VerilogParser::Attr_specContext::attr_name() {
  return getRuleContext<VerilogParser::Attr_nameContext>(0);
}

tree::TerminalNode* VerilogParser::Attr_specContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Attr_specContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Attr_specContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_spec;
}


std::any VerilogParser::Attr_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_specContext* VerilogParser::attr_spec() {
  Attr_specContext *_localctx = _tracker.createInstance<Attr_specContext>(_ctx, getState());
  enterRule(_localctx, 706, VerilogParser::RuleAttr_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4517);
    attr_name();
    setState(4520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(4518);
      match(VerilogParser::EQ);
      setState(4519);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

VerilogParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Attr_nameContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Attr_nameContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_name;
}


std::any VerilogParser::Attr_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_nameContext* VerilogParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 708, VerilogParser::RuleAttr_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4522);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_identifierContext ------------------------------------------------------------------

VerilogParser::Block_identifierContext::Block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_identifier;
}


std::any VerilogParser::Block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_identifierContext* VerilogParser::block_identifier() {
  Block_identifierContext *_localctx = _tracker.createInstance<Block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 710, VerilogParser::RuleBlock_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4524);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_identifierContext ------------------------------------------------------------------

VerilogParser::Cell_identifierContext::Cell_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Cell_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Cell_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleCell_identifier;
}


std::any VerilogParser::Cell_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_identifierContext* VerilogParser::cell_identifier() {
  Cell_identifierContext *_localctx = _tracker.createInstance<Cell_identifierContext>(_ctx, getState());
  enterRule(_localctx, 712, VerilogParser::RuleCell_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4526);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_identifierContext ------------------------------------------------------------------

VerilogParser::Config_identifierContext::Config_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Config_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Config_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_identifier;
}


std::any VerilogParser::Config_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_identifierContext* VerilogParser::config_identifier() {
  Config_identifierContext *_localctx = _tracker.createInstance<Config_identifierContext>(_ctx, getState());
  enterRule(_localctx, 714, VerilogParser::RuleConfig_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4528);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Escaped_identifierContext ------------------------------------------------------------------

VerilogParser::Escaped_identifierContext::Escaped_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Escaped_identifierContext::ESCAPED_IDENTIFIER() {
  return getToken(VerilogParser::ESCAPED_IDENTIFIER, 0);
}


size_t VerilogParser::Escaped_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEscaped_identifier;
}


std::any VerilogParser::Escaped_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEscaped_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Escaped_identifierContext* VerilogParser::escaped_identifier() {
  Escaped_identifierContext *_localctx = _tracker.createInstance<Escaped_identifierContext>(_ctx, getState());
  enterRule(_localctx, 716, VerilogParser::RuleEscaped_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4530);
    match(VerilogParser::ESCAPED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_identifierContext ------------------------------------------------------------------

VerilogParser::Event_identifierContext::Event_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Event_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Event_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_identifier;
}


std::any VerilogParser::Event_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_identifierContext* VerilogParser::event_identifier() {
  Event_identifierContext *_localctx = _tracker.createInstance<Event_identifierContext>(_ctx, getState());
  enterRule(_localctx, 718, VerilogParser::RuleEvent_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4532);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_identifierContext ------------------------------------------------------------------

VerilogParser::Function_identifierContext::Function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Function_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_identifier;
}


std::any VerilogParser::Function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_identifierContext* VerilogParser::function_identifier() {
  Function_identifierContext *_localctx = _tracker.createInstance<Function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 720, VerilogParser::RuleFunction_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4534);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Gate_instance_identifierContext::Gate_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Gate_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Gate_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instance_identifier;
}


std::any VerilogParser::Gate_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::gate_instance_identifier() {
  Gate_instance_identifierContext *_localctx = _tracker.createInstance<Gate_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 722, VerilogParser::RuleGate_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4536);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_identifierContext ------------------------------------------------------------------

VerilogParser::Generate_block_identifierContext::Generate_block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Generate_block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Generate_block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_identifier;
}


std::any VerilogParser::Generate_block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::generate_block_identifier() {
  Generate_block_identifierContext *_localctx = _tracker.createInstance<Generate_block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 724, VerilogParser::RuleGenerate_block_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4538);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_identifierContext ------------------------------------------------------------------

VerilogParser::Genvar_identifierContext::Genvar_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Genvar_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Genvar_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_identifier;
}


std::any VerilogParser::Genvar_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_identifierContext* VerilogParser::genvar_identifier() {
  Genvar_identifierContext *_localctx = _tracker.createInstance<Genvar_identifierContext>(_ctx, getState());
  enterRule(_localctx, 726, VerilogParser::RuleGenvar_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4540);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hierarchical_identifierContext ------------------------------------------------------------------

VerilogParser::Hierarchical_identifierContext::Hierarchical_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hierarchical_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

std::vector<VerilogParser::Hier_refContext *> VerilogParser::Hierarchical_identifierContext::hier_ref() {
  return getRuleContexts<VerilogParser::Hier_refContext>();
}

VerilogParser::Hier_refContext* VerilogParser::Hierarchical_identifierContext::hier_ref(size_t i) {
  return getRuleContext<VerilogParser::Hier_refContext>(i);
}


size_t VerilogParser::Hierarchical_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleHierarchical_identifier;
}


std::any VerilogParser::Hierarchical_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHierarchical_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::hierarchical_identifier() {
  Hierarchical_identifierContext *_localctx = _tracker.createInstance<Hierarchical_identifierContext>(_ctx, getState());
  enterRule(_localctx, 728, VerilogParser::RuleHierarchical_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4545);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4542);
        hier_ref(); 
      }
      setState(4547);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx);
    }
    setState(4548);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hier_refContext ------------------------------------------------------------------

VerilogParser::Hier_refContext::Hier_refContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hier_refContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Hier_refContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Hier_refContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Hier_refContext::getRuleIndex() const {
  return VerilogParser::RuleHier_ref;
}


std::any VerilogParser::Hier_refContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHier_ref(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hier_refContext* VerilogParser::hier_ref() {
  Hier_refContext *_localctx = _tracker.createInstance<Hier_refContext>(_ctx, getState());
  enterRule(_localctx, 730, VerilogParser::RuleHier_ref);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4550);
    identifier();
    setState(4552);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(4551);
      const_bit_select();
    }
    setState(4554);
    match(VerilogParser::DT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

VerilogParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Escaped_identifierContext* VerilogParser::IdentifierContext::escaped_identifier() {
  return getRuleContext<VerilogParser::Escaped_identifierContext>(0);
}

VerilogParser::Simple_identifierContext* VerilogParser::IdentifierContext::simple_identifier() {
  return getRuleContext<VerilogParser::Simple_identifierContext>(0);
}


size_t VerilogParser::IdentifierContext::getRuleIndex() const {
  return VerilogParser::RuleIdentifier;
}


std::any VerilogParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::IdentifierContext* VerilogParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 732, VerilogParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4558);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4556);
        escaped_identifier();
        break;
      }

      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(4557);
        simple_identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_port_identifierContext ------------------------------------------------------------------

VerilogParser::Input_port_identifierContext::Input_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Input_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Input_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_port_identifier;
}


std::any VerilogParser::Input_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_port_identifierContext* VerilogParser::input_port_identifier() {
  Input_port_identifierContext *_localctx = _tracker.createInstance<Input_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 734, VerilogParser::RuleInput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4560);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Instance_identifierContext ------------------------------------------------------------------

VerilogParser::Instance_identifierContext::Instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInstance_identifier;
}


std::any VerilogParser::Instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInstance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Instance_identifierContext* VerilogParser::instance_identifier() {
  Instance_identifierContext *_localctx = _tracker.createInstance<Instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 736, VerilogParser::RuleInstance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4562);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_identifierContext ------------------------------------------------------------------

VerilogParser::Library_identifierContext::Library_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Library_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Library_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_identifier;
}


std::any VerilogParser::Library_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_identifierContext* VerilogParser::library_identifier() {
  Library_identifierContext *_localctx = _tracker.createInstance<Library_identifierContext>(_ctx, getState());
  enterRule(_localctx, 738, VerilogParser::RuleLibrary_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4564);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_identifierContext ------------------------------------------------------------------

VerilogParser::Module_identifierContext::Module_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_identifier;
}


std::any VerilogParser::Module_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_identifierContext* VerilogParser::module_identifier() {
  Module_identifierContext *_localctx = _tracker.createInstance<Module_identifierContext>(_ctx, getState());
  enterRule(_localctx, 740, VerilogParser::RuleModule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4566);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Module_instance_identifierContext::Module_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance_identifier;
}


std::any VerilogParser::Module_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instance_identifierContext* VerilogParser::module_instance_identifier() {
  Module_instance_identifierContext *_localctx = _tracker.createInstance<Module_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 742, VerilogParser::RuleModule_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4568);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_identifierContext ------------------------------------------------------------------

VerilogParser::Net_identifierContext::Net_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Net_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Net_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleNet_identifier;
}


std::any VerilogParser::Net_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_identifierContext* VerilogParser::net_identifier() {
  Net_identifierContext *_localctx = _tracker.createInstance<Net_identifierContext>(_ctx, getState());
  enterRule(_localctx, 744, VerilogParser::RuleNet_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4570);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_port_identifierContext ------------------------------------------------------------------

VerilogParser::Output_port_identifierContext::Output_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Output_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Output_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_port_identifier;
}


std::any VerilogParser::Output_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_port_identifierContext* VerilogParser::output_port_identifier() {
  Output_port_identifierContext *_localctx = _tracker.createInstance<Output_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 746, VerilogParser::RuleOutput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4572);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_identifierContext ------------------------------------------------------------------

VerilogParser::Parameter_identifierContext::Parameter_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Parameter_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Parameter_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_identifier;
}


std::any VerilogParser::Parameter_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_identifierContext* VerilogParser::parameter_identifier() {
  Parameter_identifierContext *_localctx = _tracker.createInstance<Parameter_identifierContext>(_ctx, getState());
  enterRule(_localctx, 748, VerilogParser::RuleParameter_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4574);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_identifierContext ------------------------------------------------------------------

VerilogParser::Port_identifierContext::Port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Port_identifierContext::getRuleIndex() const {
  return VerilogParser::RulePort_identifier;
}


std::any VerilogParser::Port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_identifierContext* VerilogParser::port_identifier() {
  Port_identifierContext *_localctx = _tracker.createInstance<Port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 750, VerilogParser::RulePort_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4576);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_identifierContext ------------------------------------------------------------------

VerilogParser::Real_identifierContext::Real_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Real_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Real_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleReal_identifier;
}


std::any VerilogParser::Real_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_identifierContext* VerilogParser::real_identifier() {
  Real_identifierContext *_localctx = _tracker.createInstance<Real_identifierContext>(_ctx, getState());
  enterRule(_localctx, 752, VerilogParser::RuleReal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4578);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_identifierContext ------------------------------------------------------------------

VerilogParser::Simple_identifierContext::Simple_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Simple_identifierContext::SIMPLE_IDENTIFIER() {
  return getToken(VerilogParser::SIMPLE_IDENTIFIER, 0);
}


size_t VerilogParser::Simple_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_identifier;
}


std::any VerilogParser::Simple_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_identifierContext* VerilogParser::simple_identifier() {
  Simple_identifierContext *_localctx = _tracker.createInstance<Simple_identifierContext>(_ctx, getState());
  enterRule(_localctx, 754, VerilogParser::RuleSimple_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4580);
    match(VerilogParser::SIMPLE_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_identifierContext ------------------------------------------------------------------

VerilogParser::Specparam_identifierContext::Specparam_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Specparam_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Specparam_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_identifier;
}


std::any VerilogParser::Specparam_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_identifierContext* VerilogParser::specparam_identifier() {
  Specparam_identifierContext *_localctx = _tracker.createInstance<Specparam_identifierContext>(_ctx, getState());
  enterRule(_localctx, 756, VerilogParser::RuleSpecparam_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4582);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_identifierContext ------------------------------------------------------------------

VerilogParser::System_function_identifierContext::System_function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_function_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_identifier;
}


std::any VerilogParser::System_function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_identifierContext* VerilogParser::system_function_identifier() {
  System_function_identifierContext *_localctx = _tracker.createInstance<System_function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 758, VerilogParser::RuleSystem_function_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4584);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_identifierContext ------------------------------------------------------------------

VerilogParser::System_task_identifierContext::System_task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_task_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_identifier;
}


std::any VerilogParser::System_task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_identifierContext* VerilogParser::system_task_identifier() {
  System_task_identifierContext *_localctx = _tracker.createInstance<System_task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 760, VerilogParser::RuleSystem_task_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4586);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_identifierContext ------------------------------------------------------------------

VerilogParser::Task_identifierContext::Task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Task_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTask_identifier;
}


std::any VerilogParser::Task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_identifierContext* VerilogParser::task_identifier() {
  Task_identifierContext *_localctx = _tracker.createInstance<Task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 762, VerilogParser::RuleTask_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4588);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Terminal_identifierContext ------------------------------------------------------------------

VerilogParser::Terminal_identifierContext::Terminal_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Terminal_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Terminal_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTerminal_identifier;
}


std::any VerilogParser::Terminal_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTerminal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Terminal_identifierContext* VerilogParser::terminal_identifier() {
  Terminal_identifierContext *_localctx = _tracker.createInstance<Terminal_identifierContext>(_ctx, getState());
  enterRule(_localctx, 764, VerilogParser::RuleTerminal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4590);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topmodule_identifierContext ------------------------------------------------------------------

VerilogParser::Topmodule_identifierContext::Topmodule_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Topmodule_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Topmodule_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTopmodule_identifier;
}


std::any VerilogParser::Topmodule_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTopmodule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Topmodule_identifierContext* VerilogParser::topmodule_identifier() {
  Topmodule_identifierContext *_localctx = _tracker.createInstance<Topmodule_identifierContext>(_ctx, getState());
  enterRule(_localctx, 766, VerilogParser::RuleTopmodule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4592);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_identifierContext::Udp_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_identifier;
}


std::any VerilogParser::Udp_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_identifierContext* VerilogParser::udp_identifier() {
  Udp_identifierContext *_localctx = _tracker.createInstance<Udp_identifierContext>(_ctx, getState());
  enterRule(_localctx, 768, VerilogParser::RuleUdp_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4594);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_instance_identifierContext::Udp_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance_identifier;
}


std::any VerilogParser::Udp_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::udp_instance_identifier() {
  Udp_instance_identifierContext *_localctx = _tracker.createInstance<Udp_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 770, VerilogParser::RuleUdp_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4596);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_identifierContext ------------------------------------------------------------------

VerilogParser::Variable_identifierContext::Variable_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Variable_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Variable_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_identifier;
}


std::any VerilogParser::Variable_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_identifierContext* VerilogParser::variable_identifier() {
  Variable_identifierContext *_localctx = _tracker.createInstance<Variable_identifierContext>(_ctx, getState());
  enterRule(_localctx, 772, VerilogParser::RuleVariable_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4598);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool VerilogParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 198: return event_expressionSempred(antlrcpp::downCast<Event_expressionContext *>(context), predicateIndex);
    case 310: return constant_expressionSempred(antlrcpp::downCast<Constant_expressionContext *>(context), predicateIndex);
    case 314: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 317: return module_path_expressionSempred(antlrcpp::downCast<Module_path_expressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool VerilogParser::event_expressionSempred(Event_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::constant_expressionSempred(Constant_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 12);
    case 3: return precpred(_ctx, 11);
    case 4: return precpred(_ctx, 10);
    case 5: return precpred(_ctx, 9);
    case 6: return precpred(_ctx, 8);
    case 7: return precpred(_ctx, 7);
    case 8: return precpred(_ctx, 6);
    case 9: return precpred(_ctx, 5);
    case 10: return precpred(_ctx, 4);
    case 11: return precpred(_ctx, 3);
    case 12: return precpred(_ctx, 2);
    case 13: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 12);
    case 15: return precpred(_ctx, 11);
    case 16: return precpred(_ctx, 10);
    case 17: return precpred(_ctx, 9);
    case 18: return precpred(_ctx, 8);
    case 19: return precpred(_ctx, 7);
    case 20: return precpred(_ctx, 6);
    case 21: return precpred(_ctx, 5);
    case 22: return precpred(_ctx, 4);
    case 23: return precpred(_ctx, 3);
    case 24: return precpred(_ctx, 2);
    case 25: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::module_path_expressionSempred(Module_path_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 26: return precpred(_ctx, 7);
    case 27: return precpred(_ctx, 6);
    case 28: return precpred(_ctx, 5);
    case 29: return precpred(_ctx, 4);
    case 30: return precpred(_ctx, 3);
    case 31: return precpred(_ctx, 2);
    case 32: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void VerilogParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  verilogparserParserInitialize();
#else
  ::antlr4::internal::call_once(verilogparserParserOnceFlag, verilogparserParserInitialize);
#endif
}
