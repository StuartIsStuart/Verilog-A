
// Generated from VerilogParser.g4 by ANTLR 4.13.2


#include "VerilogParserVisitor.h"

#include "VerilogParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct VerilogParserStaticData final {
  VerilogParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  VerilogParserStaticData(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData(VerilogParserStaticData&&) = delete;
  VerilogParserStaticData& operator=(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData& operator=(VerilogParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag verilogparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<VerilogParserStaticData> verilogparserParserStaticData = nullptr;

void verilogparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (verilogparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(verilogparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<VerilogParserStaticData>(
    std::vector<std::string>{
      "library_text", "library_description", "library_declaration", "library_incdir", 
      "include_statement", "file_path_spec", "source_text", "description", 
      "module_declaration", "module_keyword", "discipline_declaration", 
      "discipline_name", "discipline_item", "domain_statement", "potential_declaration", 
      "flow_declaration", "nature_declaration", "nature_item", "access_spec", 
      "module_parameter_port_list", "list_of_port_declarations", "port", 
      "port_implicit", "port_explicit", "port_expression", "port_reference", 
      "port_declaration", "module_item", "module_or_generate_item", "module_or_generate_item_declaration", 
      "parameter_override", "config_declaration", "design_statement", "design_statement_item", 
      "config_rule_statement", "default_clause", "inst_clause", "inst_name", 
      "cell_clause", "liblist_clause", "use_clause", "local_parameter_declaration", 
      "parameter_declaration", "specparam_declaration", "parameter_type", 
      "inout_declaration", "input_declaration", "output_declaration", "event_declaration", 
      "integer_declaration", "net_declaration", "real_declaration", "realtime_declaration", 
      "reg_declaration", "time_declaration", "net_type", "electrical_declaration", 
      "output_variable_type", "real_type", "variable_type", "drive_strength", 
      "strength0", "strength1", "charge_strength", "delay3", "delay2", "delay_value", 
      "list_of_defparam_assignments", "list_of_event_identifiers", "event_id", 
      "list_of_net_decl_assignments", "list_of_net_identifiers", "net_id", 
      "list_of_param_assignments", "list_of_port_identifiers", "list_of_real_identifiers", 
      "list_of_specparam_assignments", "list_of_variable_identifiers", "list_of_variable_port_identifiers", 
      "var_port_id", "defparam_assignment", "net_decl_assignment", "param_assignment", 
      "specparam_assignment", "pulse_control_specparam", "error_limit_value", 
      "reject_limit_value", "limit_value", "dimension", "range_", "function_declaration", 
      "function_item_declaration", "function_port_list", "func_port_item", 
      "function_range_or_type", "task_declaration", "task_item_declaration", 
      "task_port_list", "task_port_item", "tf_input_declaration", "tf_output_declaration", 
      "tf_inout_declaration", "task_port_type", "block_item_declaration", 
      "list_of_block_variable_identifiers", "list_of_block_real_identifiers", 
      "block_variable_type", "block_real_type", "gate_instantiation", "cmos_switch_instance", 
      "enable_gate_instance", "mos_switch_instance", "n_input_gate_instance", 
      "n_output_gate_instance", "pass_switch_instance", "pass_enable_switch_instance", 
      "pull_gate_instance", "name_of_gate_instance", "pulldown_strength", 
      "pullup_strength", "enable_terminal", "inout_terminal", "input_terminal", 
      "ncontrol_terminal", "output_terminal", "pcontrol_terminal", "cmos_switchtype", 
      "enable_gatetype", "mos_switchtype", "n_input_gatetype", "n_output_gatetype", 
      "pass_en_switchtype", "pass_switchtype", "module_instantiation", "parameter_value_assignment", 
      "list_of_parameter_assignments", "ordered_parameter_assignment", "named_parameter_assignment", 
      "module_instance", "name_of_module_instance", "list_of_port_connections", 
      "ordered_port_connection", "named_port_connection", "generate_region", 
      "genvar_declaration", "list_of_genvar_identifiers", "loop_generate_construct", 
      "genvar_initialization", "genvar_expression", "genvar_iteration", 
      "conditional_generate_construct", "if_generate_construct", "case_generate_construct", 
      "case_generate_item", "generate_block", "generate_block_name", "generate_block_or_null", 
      "udp_declaration", "udp_port_list", "udp_declaration_port_list", "udp_port_declaration", 
      "udp_output_declaration", "udp_input_declaration", "udp_reg_declaration", 
      "udp_body", "combinational_body", "combinational_entry", "sequential_body", 
      "udp_initial_statement", "init_val", "sequential_entry", "seq_input_list", 
      "level_input_list", "edge_input_list", "edge_indicator", "current_state", 
      "next_state", "output_symbol", "level_symbol", "edge_symbol", "udp_instantiation", 
      "udp_instance", "name_of_udp_instance", "continuous_assign", "list_of_net_assignments", 
      "net_assignment", "initial_construct", "always_construct", "analog_construct", 
      "blocking_assignment", "nonblocking_assignment", "analog_assignment", 
      "procedural_continuous_assignments", "variable_assignment", "par_block", 
      "block_name", "seq_block", "statement", "statement_or_null", "function_statement", 
      "delay_control", "delay_or_event_control", "disable_statement", "event_control", 
      "event_trigger", "event_expression", "procedural_timing_control", 
      "procedural_timing_control_statement", "wait_statement", "conditional_statement", 
      "case_statement", "case_item", "loop_statement", "system_task_enable", 
      "sys_task_en_port_list", "sys_task_en_port_item", "task_enable", "task_en_port_list", 
      "specify_block", "specify_item", "pulsestyle_declaration", "showcancelled_declaration", 
      "path_declaration", "simple_path_declaration", "parallel_path_description", 
      "full_path_description", "list_of_path_inputs", "list_of_path_outputs", 
      "specify_input_terminal_descriptor", "specify_output_terminal_descriptor", 
      "input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions", 
      "t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression", 
      "tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression", 
      "t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression", 
      "tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression", 
      "t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression", 
      "tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration", 
      "parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description", 
      "data_source_expression", "edge_identifier", "state_dependent_path_declaration", 
      "polarity_operator", "system_timing_check", "setup_timing_check", 
      "notifier_opt", "hold_timing_check", "setuphold_timing_check", "timing_check_opt", 
      "stamptime_cond_opt", "checktime_cond_opt", "delayed_ref_opt", "delayed_data_opt", 
      "recovery_timing_check", "removal_timing_check", "recrem_timing_check", 
      "skew_timing_check", "timeskew_timing_check", "skew_timing_check_opt", 
      "event_based_flag_opt", "remain_active_flag_opt", "fullskew_timing_check", 
      "period_timing_check", "width_timing_check", "threshold_opt", "nochange_timing_check", 
      "checktime_condition", "controlled_reference_event", "data_event", 
      "delayed_data", "delayed_reference", "end_edge_offset", "event_based_flag", 
      "notifier", "reference_event", "remain_active_flag", "stamptime_condition", 
      "start_edge_offset", "threshold", "timing_check_limit", "timing_check_event", 
      "controlled_timing_check_event", "timing_check_event_control", "specify_terminal_descriptor", 
      "edge_control_specifier", "edge_descriptor", "timing_check_condition", 
      "scalar_timing_check_condition", "scalar_constant", "concatenation", 
      "constant_concatenation", "constant_multiple_concatenation", "module_path_concatenation", 
      "module_path_multiple_concatenation", "multiple_concatenation", "constant_function_call", 
      "constant_system_function_call", "function_call", "system_function_call", 
      "sys_func_call_port_list", "base_expression", "constant_base_expression", 
      "constant_expression", "constant_mintypmax_expression", "constant_range_expression", 
      "dimension_constant_expression", "expression", "lsb_constant_expression", 
      "mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression", 
      "msb_constant_expression", "range_expression", "width_constant_expression", 
      "constant_primary", "module_path_primary", "primary", "select_", "bit_select", 
      "net_lvalue", "const_select", "const_bit_select", "variable_lvalue", 
      "unary_operator", "unary_module_path_operator", "number", "real_number", 
      "decimal_number", "binary_number", "octal_number", "hex_number", "size", 
      "fixed_point_number", "unit_number", "exponential_number", "unsigned_number", 
      "decimal_value", "binary_value", "octal_value", "hex_value", "decimal_base", 
      "binary_base", "octal_base", "hex_base", "string_", "attribute_instance", 
      "attr_spec", "attr_name", "block_identifier", "cell_identifier", "config_identifier", 
      "escaped_identifier", "event_identifier", "function_identifier", "gate_instance_identifier", 
      "generate_block_identifier", "genvar_identifier", "hierarchical_identifier", 
      "hier_ref", "identifier", "input_port_identifier", "instance_identifier", 
      "library_identifier", "module_identifier", "module_instance_identifier", 
      "net_identifier", "output_port_identifier", "parameter_identifier", 
      "port_identifier", "real_identifier", "simple_identifier", "specparam_identifier", 
      "system_function_identifier", "system_task_identifier", "task_identifier", 
      "terminal_identifier", "topmodule_identifier", "udp_identifier", "udp_instance_identifier", 
      "variable_identifier"
    },
    std::vector<std::string>{
      "", "'always'", "'and'", "'assign'", "'automatic'", "'begin'", "'buf'", 
      "'bufif1'", "'bufif0'", "'case'", "'casex'", "'casez'", "'cell'", 
      "'cmos'", "'config'", "'deassign'", "'default'", "'defparam'", "'design'", 
      "'disable'", "'$fullskew'", "'$hold'", "'$nochange'", "'$period'", 
      "'$recovery'", "'$recrem'", "'$removal'", "'$setup'", "'$setuphold'", 
      "'$skew'", "'$timeskew'", "'$width'", "'edge'", "'else'", "'end'", 
      "'endcase'", "'endconfig'", "'endfunction'", "'endgenerate'", "'endmodule'", 
      "'endprimitive'", "'endspecify'", "'endtable'", "'endtask'", "'event'", 
      "'for'", "'force'", "'forever'", "'fork'", "'function'", "'generate'", 
      "'genvar'", "'highz1'", "'highz0'", "'if'", "'ifnone'", "'include'", 
      "'initial'", "'inout'", "'input'", "'instance'", "'integer'", "'join'", 
      "'large'", "'liblist'", "'library'", "'localparam'", "'macromodule'", 
      "'medium'", "'-incdir'", "'module'", "'nand'", "'negedge'", "'nmos'", 
      "'nor'", "'noshowcancelled'", "'not'", "'notif1'", "'notif0'", "'or'", 
      "'output'", "'parameter'", "'PATHPULSE$'", "'pmos'", "'posedge'", 
      "'primitive'", "'pulldown'", "'pull1'", "'pullup'", "'pull0'", "'pulsestyle_ondetect'", 
      "'pulsestyle_onevent'", "'rcmos'", "'real'", "'realtime'", "'reg'", 
      "'release'", "'repeat'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif1'", 
      "'rtranif0'", "'scalared'", "'showcancelled'", "'signed'", "'small'", 
      "'specify'", "'specparam'", "'strong1'", "'strong0'", "'supply1'", 
      "'supply0'", "'table'", "'task'", "'time'", "'tran'", "'tranif1'", 
      "'tranif0'", "'tri'", "'triand'", "'tri1'", "'trior'", "'trireg'", 
      "'tri0'", "'use'", "'uwire'", "'vectored'", "'wait'", "'wand'", "'weak1'", 
      "'weak0'", "'while'", "'wire'", "'wor'", "'xnor'", "'xor'", "'analog'", 
      "'electrical'", "'branch'", "'discipline'", "'enddiscipline'", "'nature'", 
      "'endnature'", "'voltage'", "'current'", "'flow'", "'domain'", "'potential'", 
      "'units'", "'access'", "'idt_nature'", "'ddt_nature'", "'abstol'", 
      "'<+'", "'&&&'", "'!=='", "'==='", "'>>>'", "'<<<'", "'-:'", "'->'", 
      "'<='", "'<<'", "'&&'", "'*>'", "'=='", "'**'", "'^~'", "'!='", "'>='", 
      "'>>'", "'=>'", "'~&'", "'~^'", "'~|'", "'||'", "'|'", "'&'", "'*'", 
      "'@'", "'^'", "':'", "','", "'$'", "'\"'", "'.'", "'!'", "'='", "", 
      "'>'", "'#'", "'['", "'{'", "'('", "'<'", "'-'", "'%'", "'+'", "'+:'", 
      "'\\u003F'", "']'", "'}'", "')'", "';'", "'/'", "'~'", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "'celldefine'", "", "", "", "", "'end_keywords'", 
      "'endcelldefine'", "", "", "", "", "", "'nounconnected_drive'", "", 
      "'resetall'", "", "", "", "", "", "", "", "", "'``'", "", "'`\\`\"'", 
      "'`\"'"
    },
    std::vector<std::string>{
      "", "ALWAYS", "AND", "ASSIGN", "AUTOMATIC", "BEGIN", "BUF", "BUFIFONE", 
      "BUFIFZERO", "CASE", "CASEX", "CASEZ", "CELL", "CMOS", "CONFIG", "DEASSIGN", 
      "DEFAULT", "DEFPARAM", "DESIGN", "DISABLE", "DLFULLSKEW", "DLHOLD", 
      "DLNOCHANGE", "DLPERIOD", "DLRECOVERY", "DLRECREM", "DLREMOVAL", "DLSETUP", 
      "DLSETUPHOLD", "DLSKEW", "DLTIMESKEW", "DLWIDTH", "EDGE", "ELSE", 
      "END", "ENDCASE", "ENDCONFIG", "ENDFUNCTION", "ENDGENERATE", "ENDMODULE", 
      "ENDPRIMITIVE", "ENDSPECIFY", "ENDTABLE", "ENDTASK", "EVENT", "FOR", 
      "FORCE", "FOREVER", "FORK", "FUNCTION", "GENERATE", "GENVAR", "HIGHZONE", 
      "HIGHZZERO", "IF", "IFNONE", "INCLUDE", "INITIAL", "INOUT", "INPUT", 
      "INSTANCE", "INTEGER", "JOIN", "LARGE", "LIBLIST", "LIBRARY", "LOCALPARAM", 
      "MACROMODULE", "MEDIUM", "MIINCDIR", "MODULE", "NAND", "NEGEDGE", 
      "NMOS", "NOR", "NOSHOWCANCELLED", "NOT", "NOTIFONE", "NOTIFZERO", 
      "OR", "OUTPUT", "PARAMETER", "PATHPULSEDL", "PMOS", "POSEDGE", "PRIMITIVE", 
      "PULLDOWN", "PULLONE", "PULLUP", "PULLZERO", "PULSESTYLE_ONDETECT", 
      "PULSESTYLE_ONEVENT", "RCMOS", "REAL", "REALTIME", "REG", "RELEASE", 
      "REPEAT", "RNMOS", "RPMOS", "RTRAN", "RTRANIFONE", "RTRANIFZERO", 
      "SCALARED", "SHOWCANCELLED", "SIGNED", "SMALL", "SPECIFY", "SPECPARAM", 
      "STRONGONE", "STRONGZERO", "SUPPLYONE", "SUPPLYZERO", "TABLE", "TASK", 
      "TIME", "TRAN", "TRANIFONE", "TRANIFZERO", "TRI", "TRIAND", "TRIONE", 
      "TRIOR", "TRIREG", "TRIZERO", "USE", "UWIRE", "VECTORED", "WAIT", 
      "WAND", "WEAKONE", "WEAKZERO", "WHILE", "WIRE", "WOR", "XNOR", "XOR", 
      "ANALOG", "ELECTRICAL", "BRANCH", "DISCIPLINE", "ENDDISCIPLINE", "NATURE", 
      "ENDNATURE", "VOLTAGE", "CURRENT", "FLOW", "DOMAIN", "POTENTIAL", 
      "UNITS", "ACCESS", "IDT_NATURE", "DDT_NATURE", "ABSTOL", "LTPL", "AMAMAM", 
      "EMEQEQ", "EQEQEQ", "GTGTGT", "LTLTLT", "MICL", "MIGT", "LTEQ", "LTLT", 
      "AMAM", "ASGT", "EQEQ", "ASAS", "CATI", "EMEQ", "GTEQ", "GTGT", "EQGT", 
      "TIAM", "TICA", "TIVL", "VLVL", "VL", "AM", "AS", "AT", "CA", "CL", 
      "CO", "DL", "DQ", "DT", "EM", "EQ", "GA", "GT", "HA", "LB", "LC", 
      "LP", "LT", "MI", "MO", "PL", "PLCL", "QM", "RB", "RC", "RP", "SC", 
      "SL", "TI", "BINARY_BASE", "BLOCK_COMMENT", "DECIMAL_BASE", "ESCAPED_IDENTIFIER", 
      "EXPONENTIAL_NUMBER", "FIXED_POINT_NUMBER", "HEX_BASE", "LINE_COMMENT", 
      "OCTAL_BASE", "SIMPLE_IDENTIFIER", "STRING", "SYSTEM_TF_IDENTIFIER", 
      "UNSIGNED_NUMBER", "UNIT_NUMBER", "WHITE_SPACE", "BINARY_VALUE", "X_OR_Z_UNDERSCORE", 
      "EDGE_DESCRIPTOR", "HEX_VALUE", "FILE_PATH_SPEC", "OCTAL_VALUE", "EDGE_SYMBOL", 
      "LEVEL_ONLY_SYMBOL", "OUTPUT_OR_LEVEL_SYMBOL", "BEGIN_KEYWORDS_DIRECTIVE", 
      "CELLDEFINE_DIRECTIVE", "DEFAULT_NETTYPE_DIRECTIVE", "DEFINE_DIRECTIVE", 
      "ELSE_DIRECTIVE", "ELSIF_DIRECTIVE", "END_KEYWORDS_DIRECTIVE", "ENDCELLDEFINE_DIRECTIVE", 
      "ENDIF_DIRECTIVE", "IFDEF_DIRECTIVE", "IFNDEF_DIRECTIVE", "INCLUDE_DIRECTIVE", 
      "LINE_DIRECTIVE", "NOUNCONNECTED_DRIVE_DIRECTIVE", "PRAGMA_DIRECTIVE", 
      "RESETALL_DIRECTIVE", "TIMESCALE_DIRECTIVE", "UNCONNECTED_DRIVE_DIRECTIVE", 
      "UNDEF_DIRECTIVE", "MACRO_USAGE", "VERSION_SPECIFIER", "DEFAULT_NETTYPE_VALUE", 
      "MACRO_NAME", "FILENAME", "MACRO_DELIMITER", "MACRO_ESC_NEWLINE", 
      "MACRO_ESC_QUOTE", "MACRO_QUOTE", "MACRO_TEXT", "SOURCE_TEXT", "TIME_UNIT", 
      "TIME_VALUE", "UNCONNECTED_DRIVE_VALUE", "MACRO_IDENTIFIER", "IDENTIFIER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,265,4686,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,
  	7,356,2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
  	7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,2,368,
  	7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,7,373,2,374,
  	7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,2,379,7,379,2,380,
  	7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,7,384,2,385,7,385,2,386,
  	7,386,2,387,7,387,2,388,7,388,2,389,7,389,2,390,7,390,2,391,7,391,2,392,
  	7,392,2,393,7,393,2,394,7,394,1,0,5,0,792,8,0,10,0,12,0,795,9,0,1,0,1,
  	0,1,1,1,1,1,1,3,1,802,8,1,1,2,1,2,1,2,1,2,1,2,5,2,809,8,2,10,2,12,2,812,
  	9,2,1,2,3,2,815,8,2,1,2,1,2,1,3,1,3,1,3,1,3,5,3,823,8,3,10,3,12,3,826,
  	9,3,1,4,1,4,1,4,1,4,1,5,1,5,1,6,5,6,835,8,6,10,6,12,6,838,9,6,1,6,1,6,
  	1,7,1,7,1,7,1,7,1,7,3,7,847,8,7,1,8,5,8,850,8,8,10,8,12,8,853,9,8,1,8,
  	1,8,1,8,3,8,858,8,8,1,8,3,8,861,8,8,1,8,1,8,5,8,865,8,8,10,8,12,8,868,
  	9,8,1,8,1,8,1,9,1,9,1,10,1,10,1,10,1,10,5,10,878,8,10,10,10,12,10,881,
  	9,10,1,10,1,10,1,11,1,11,1,11,1,11,3,11,889,8,11,1,12,1,12,1,12,1,12,
  	3,12,895,8,12,1,13,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,15,1,15,1,15,
  	1,15,1,16,1,16,1,16,1,16,5,16,913,8,16,10,16,12,16,916,9,16,1,16,1,16,
  	1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
  	1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
  	1,17,3,17,949,8,17,1,18,1,18,1,19,1,19,1,19,1,19,1,19,5,19,958,8,19,10,
  	19,12,19,961,9,19,1,19,1,19,1,20,1,20,1,20,1,20,5,20,969,8,20,10,20,12,
  	20,972,9,20,1,20,1,20,1,20,1,20,1,20,1,20,4,20,980,8,20,11,20,12,20,981,
  	1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,996,
  	8,20,1,21,3,21,999,8,21,1,21,3,21,1002,8,21,1,22,1,22,1,23,1,23,1,23,
  	1,23,3,23,1010,8,23,1,23,1,23,1,24,1,24,1,24,1,24,1,24,5,24,1019,8,24,
  	10,24,12,24,1022,9,24,1,24,1,24,3,24,1026,8,24,1,25,1,25,1,25,1,25,1,
  	25,3,25,1033,8,25,1,26,5,26,1036,8,26,10,26,12,26,1039,9,26,1,26,1,26,
  	5,26,1043,8,26,10,26,12,26,1046,9,26,1,26,1,26,5,26,1050,8,26,10,26,12,
  	26,1053,9,26,1,26,3,26,1056,8,26,1,27,1,27,1,27,1,27,1,27,1,27,1,27,5,
  	27,1065,8,27,10,27,12,27,1068,9,27,1,27,1,27,1,27,1,27,5,27,1074,8,27,
  	10,27,12,27,1077,9,27,1,27,1,27,3,27,1081,8,27,1,28,5,28,1084,8,28,10,
  	28,12,28,1087,9,28,1,28,1,28,5,28,1091,8,28,10,28,12,28,1094,9,28,1,28,
  	1,28,1,28,1,28,5,28,1100,8,28,10,28,12,28,1103,9,28,1,28,1,28,5,28,1107,
  	8,28,10,28,12,28,1110,9,28,1,28,1,28,5,28,1114,8,28,10,28,12,28,1117,
  	9,28,1,28,1,28,5,28,1121,8,28,10,28,12,28,1124,9,28,1,28,1,28,5,28,1128,
  	8,28,10,28,12,28,1131,9,28,1,28,1,28,5,28,1135,8,28,10,28,12,28,1138,
  	9,28,1,28,1,28,5,28,1142,8,28,10,28,12,28,1145,9,28,1,28,1,28,5,28,1149,
  	8,28,10,28,12,28,1152,9,28,1,28,1,28,5,28,1156,8,28,10,28,12,28,1159,
  	9,28,1,28,1,28,5,28,1163,8,28,10,28,12,28,1166,9,28,1,28,3,28,1169,8,
  	28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,1181,8,29,1,
  	30,1,30,1,30,1,30,1,31,1,31,1,31,1,31,1,31,5,31,1192,8,31,10,31,12,31,
  	1195,9,31,1,31,1,31,1,32,1,32,5,32,1201,8,32,10,32,12,32,1204,9,32,1,
  	32,1,32,1,33,1,33,1,33,3,33,1211,8,33,1,33,1,33,1,34,1,34,1,34,1,34,1,
  	34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,
  	34,1,34,3,34,1235,8,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,5,37,1245,
  	8,37,10,37,12,37,1248,9,37,1,38,1,38,1,38,1,38,3,38,1254,8,38,1,38,1,
  	38,1,39,1,39,5,39,1260,8,39,10,39,12,39,1263,9,39,1,40,1,40,1,40,1,40,
  	3,40,1269,8,40,1,40,1,40,1,40,3,40,1274,8,40,1,41,1,41,3,41,1278,8,41,
  	1,41,3,41,1281,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1288,8,41,1,42,1,42,
  	3,42,1292,8,42,1,42,3,42,1295,8,42,1,42,1,42,1,42,1,42,1,42,3,42,1302,
  	8,42,1,43,1,43,3,43,1306,8,43,1,43,1,43,1,43,1,44,1,44,1,45,1,45,3,45,
  	1315,8,45,1,45,3,45,1318,8,45,1,45,3,45,1321,8,45,1,45,1,45,1,46,1,46,
  	3,46,1327,8,46,1,46,3,46,1330,8,46,1,46,3,46,1333,8,46,1,46,1,46,1,47,
  	1,47,3,47,1339,8,47,1,47,3,47,1342,8,47,1,47,3,47,1345,8,47,1,47,1,47,
  	1,47,1,47,3,47,1351,8,47,1,47,3,47,1354,8,47,1,47,1,47,1,47,1,47,1,47,
  	3,47,1361,8,47,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,50,1,50,3,50,
  	1373,8,50,1,50,3,50,1376,8,50,1,50,1,50,1,50,1,50,1,50,3,50,1383,8,50,
  	1,50,3,50,1386,8,50,1,50,3,50,1389,8,50,1,50,1,50,1,50,1,50,1,50,3,50,
  	1396,8,50,1,50,3,50,1399,8,50,1,50,1,50,3,50,1403,8,50,1,50,1,50,1,50,
  	1,50,1,50,3,50,1410,8,50,1,50,3,50,1413,8,50,1,50,3,50,1416,8,50,1,50,
  	1,50,3,50,1420,8,50,1,50,1,50,1,50,1,50,1,50,3,50,1427,8,50,1,50,3,50,
  	1430,8,50,1,50,3,50,1433,8,50,1,50,1,50,1,50,1,50,1,50,3,50,1440,8,50,
  	1,50,3,50,1443,8,50,1,50,3,50,1446,8,50,1,50,1,50,1,50,1,50,1,50,3,50,
  	1453,8,50,1,50,3,50,1456,8,50,1,50,3,50,1459,8,50,1,50,1,50,3,50,1463,
  	8,50,1,50,1,50,1,50,1,50,1,50,3,50,1470,8,50,1,50,3,50,1473,8,50,1,50,
  	3,50,1476,8,50,1,50,1,50,3,50,1480,8,50,1,50,1,50,1,50,3,50,1485,8,50,
  	1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,53,1,53,3,53,1497,8,53,1,53,
  	3,53,1500,8,53,1,53,1,53,1,53,1,54,1,54,1,54,1,54,1,55,1,55,1,56,1,56,
  	1,56,1,56,1,57,1,57,1,58,1,58,5,58,1519,8,58,10,58,12,58,1522,9,58,1,
  	58,1,58,1,58,1,58,3,58,1528,8,58,1,59,1,59,5,59,1532,8,59,10,59,12,59,
  	1535,9,59,1,59,1,59,1,59,1,59,3,59,1541,8,59,1,60,1,60,1,60,1,60,1,60,
  	1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,
  	1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,
  	1,60,1,60,1,60,3,60,1579,8,60,1,61,1,61,1,62,1,62,1,63,1,63,1,63,1,63,
  	1,63,1,63,1,63,1,63,1,63,3,63,1594,8,63,1,64,1,64,1,64,1,64,1,64,1,64,
  	1,64,1,64,1,64,3,64,1605,8,64,3,64,1607,8,64,1,64,1,64,3,64,1611,8,64,
  	1,65,1,65,1,65,1,65,1,65,1,65,1,65,3,65,1620,8,65,1,65,1,65,3,65,1624,
  	8,65,1,66,1,66,1,66,3,66,1629,8,66,1,67,1,67,1,67,5,67,1634,8,67,10,67,
  	12,67,1637,9,67,1,68,1,68,1,68,5,68,1642,8,68,10,68,12,68,1645,9,68,1,
  	69,1,69,5,69,1649,8,69,10,69,12,69,1652,9,69,1,70,1,70,1,70,5,70,1657,
  	8,70,10,70,12,70,1660,9,70,1,71,1,71,1,71,5,71,1665,8,71,10,71,12,71,
  	1668,9,71,1,72,1,72,5,72,1672,8,72,10,72,12,72,1675,9,72,1,73,1,73,1,
  	73,5,73,1680,8,73,10,73,12,73,1683,9,73,1,74,1,74,1,74,5,74,1688,8,74,
  	10,74,12,74,1691,9,74,1,75,1,75,1,75,5,75,1696,8,75,10,75,12,75,1699,
  	9,75,1,76,1,76,1,76,5,76,1704,8,76,10,76,12,76,1707,9,76,1,77,1,77,1,
  	77,5,77,1712,8,77,10,77,12,77,1715,9,77,1,78,1,78,1,78,5,78,1720,8,78,
  	10,78,12,78,1723,9,78,1,79,1,79,1,79,3,79,1728,8,79,1,80,1,80,1,80,1,
  	80,1,81,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,83,1,83,1,83,1,83,1,83,3,
  	83,1747,8,83,1,84,1,84,1,84,1,84,1,84,1,84,3,84,1755,8,84,1,84,1,84,1,
  	84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,3,84,1768,8,84,1,84,1,84,3,
  	84,1772,8,84,1,85,1,85,1,86,1,86,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,
  	88,1,89,1,89,1,89,1,89,1,89,1,89,1,90,1,90,3,90,1794,8,90,1,90,3,90,1797,
  	8,90,1,90,1,90,1,90,4,90,1802,8,90,11,90,12,90,1803,1,90,1,90,1,90,1,
  	90,1,90,3,90,1811,8,90,1,90,3,90,1814,8,90,1,90,1,90,1,90,1,90,1,90,1,
  	90,5,90,1822,8,90,10,90,12,90,1825,9,90,1,90,1,90,1,90,3,90,1830,8,90,
  	1,91,1,91,5,91,1834,8,91,10,91,12,91,1837,9,91,1,91,1,91,1,91,3,91,1842,
  	8,91,1,92,1,92,1,92,5,92,1847,8,92,10,92,12,92,1850,9,92,1,93,5,93,1853,
  	8,93,10,93,12,93,1856,9,93,1,93,1,93,1,94,1,94,1,94,3,94,1863,8,94,1,
  	94,1,94,1,94,1,94,3,94,1869,8,94,1,95,1,95,3,95,1873,8,95,1,95,1,95,1,
  	95,5,95,1878,8,95,10,95,12,95,1881,9,95,1,95,1,95,1,95,1,95,1,95,3,95,
  	1888,8,95,1,95,1,95,1,95,3,95,1893,8,95,1,95,1,95,1,95,5,95,1898,8,95,
  	10,95,12,95,1901,9,95,1,95,1,95,1,95,3,95,1906,8,95,1,96,1,96,5,96,1910,
  	8,96,10,96,12,96,1913,9,96,1,96,1,96,1,96,1,96,5,96,1919,8,96,10,96,12,
  	96,1922,9,96,1,96,1,96,1,96,1,96,5,96,1928,8,96,10,96,12,96,1931,9,96,
  	1,96,1,96,1,96,3,96,1936,8,96,1,97,1,97,1,97,5,97,1941,8,97,10,97,12,
  	97,1944,9,97,1,98,5,98,1947,8,98,10,98,12,98,1950,9,98,1,98,1,98,5,98,
  	1954,8,98,10,98,12,98,1957,9,98,1,98,1,98,5,98,1961,8,98,10,98,12,98,
  	1964,9,98,1,98,3,98,1967,8,98,1,99,1,99,3,99,1971,8,99,1,99,3,99,1974,
  	8,99,1,99,3,99,1977,8,99,1,99,1,99,1,99,1,99,1,99,3,99,1984,8,99,1,100,
  	1,100,3,100,1988,8,100,1,100,3,100,1991,8,100,1,100,3,100,1994,8,100,
  	1,100,1,100,1,100,1,100,1,100,3,100,2001,8,100,1,101,1,101,3,101,2005,
  	8,101,1,101,3,101,2008,8,101,1,101,3,101,2011,8,101,1,101,1,101,1,101,
  	1,101,1,101,3,101,2018,8,101,1,102,1,102,1,103,5,103,2023,8,103,10,103,
  	12,103,2026,9,103,1,103,1,103,3,103,2030,8,103,1,103,3,103,2033,8,103,
  	1,103,1,103,1,103,1,103,5,103,2039,8,103,10,103,12,103,2042,9,103,1,103,
  	1,103,1,103,1,103,1,103,5,103,2049,8,103,10,103,12,103,2052,9,103,1,103,
  	1,103,1,103,1,103,1,103,5,103,2059,8,103,10,103,12,103,2062,9,103,1,103,
  	1,103,1,103,1,103,1,103,5,103,2069,8,103,10,103,12,103,2072,9,103,1,103,
  	1,103,1,103,1,103,1,103,5,103,2079,8,103,10,103,12,103,2082,9,103,1,103,
  	1,103,5,103,2086,8,103,10,103,12,103,2089,9,103,1,103,1,103,1,103,1,103,
  	5,103,2095,8,103,10,103,12,103,2098,9,103,1,103,1,103,1,103,3,103,2103,
  	8,103,1,104,1,104,1,104,5,104,2108,8,104,10,104,12,104,2111,9,104,1,105,
  	1,105,1,105,5,105,2116,8,105,10,105,12,105,2119,9,105,1,106,1,106,5,106,
  	2123,8,106,10,106,12,106,2126,9,106,1,107,1,107,5,107,2130,8,107,10,107,
  	12,107,2133,9,107,1,108,1,108,3,108,2137,8,108,1,108,1,108,1,108,5,108,
  	2142,8,108,10,108,12,108,2145,9,108,1,108,1,108,1,108,1,108,3,108,2151,
  	8,108,1,108,3,108,2154,8,108,1,108,1,108,1,108,5,108,2159,8,108,10,108,
  	12,108,2162,9,108,1,108,1,108,1,108,1,108,3,108,2168,8,108,1,108,1,108,
  	1,108,5,108,2173,8,108,10,108,12,108,2176,9,108,1,108,1,108,1,108,1,108,
  	3,108,2182,8,108,1,108,3,108,2185,8,108,1,108,1,108,1,108,5,108,2190,
  	8,108,10,108,12,108,2193,9,108,1,108,1,108,1,108,1,108,3,108,2199,8,108,
  	1,108,3,108,2202,8,108,1,108,1,108,1,108,5,108,2207,8,108,10,108,12,108,
  	2210,9,108,1,108,1,108,1,108,1,108,3,108,2216,8,108,1,108,1,108,1,108,
  	5,108,2221,8,108,10,108,12,108,2224,9,108,1,108,1,108,1,108,1,108,1,108,
  	1,108,5,108,2232,8,108,10,108,12,108,2235,9,108,1,108,1,108,1,108,1,108,
  	3,108,2241,8,108,1,108,1,108,1,108,5,108,2246,8,108,10,108,12,108,2249,
  	9,108,1,108,1,108,1,108,1,108,3,108,2255,8,108,1,108,1,108,1,108,5,108,
  	2260,8,108,10,108,12,108,2263,9,108,1,108,1,108,3,108,2267,8,108,1,109,
  	3,109,2270,8,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,110,3,110,2283,8,110,1,110,1,110,1,110,1,110,1,110,1,110,1,110,
  	1,110,1,111,3,111,2294,8,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,
  	1,111,1,112,3,112,2305,8,112,1,112,1,112,1,112,1,112,1,112,1,112,5,112,
  	2313,8,112,10,112,12,112,2316,9,112,1,112,1,112,1,113,3,113,2321,8,113,
  	1,113,1,113,1,113,1,113,5,113,2327,8,113,10,113,12,113,2330,9,113,1,113,
  	1,113,1,113,1,113,1,114,3,114,2337,8,114,1,114,1,114,1,114,1,114,1,114,
  	1,114,1,115,3,115,2346,8,115,1,115,1,115,1,115,1,115,1,115,1,115,1,115,
  	1,115,1,116,3,116,2357,8,116,1,116,1,116,1,116,1,116,1,117,1,117,3,117,
  	2365,8,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,1,118,1,118,1,118,3,118,2383,8,118,1,119,1,119,1,119,
  	1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,119,
  	1,119,3,119,2401,8,119,1,120,1,120,1,121,1,121,1,122,1,122,1,123,1,123,
  	1,124,1,124,1,125,1,125,1,126,1,126,1,127,1,127,1,128,1,128,1,129,1,129,
  	1,130,1,130,1,131,1,131,1,132,1,132,1,133,1,133,3,133,2431,8,133,1,133,
  	1,133,1,133,5,133,2436,8,133,10,133,12,133,2439,9,133,1,133,1,133,1,134,
  	1,134,1,134,1,134,1,134,1,135,1,135,1,135,5,135,2451,8,135,10,135,12,
  	135,2454,9,135,1,135,1,135,1,135,5,135,2459,8,135,10,135,12,135,2462,
  	9,135,3,135,2464,8,135,1,136,1,136,1,137,1,137,1,137,1,137,3,137,2472,
  	8,137,1,137,1,137,1,138,1,138,1,138,1,138,1,138,1,139,1,139,3,139,2483,
  	8,139,1,140,1,140,1,140,5,140,2488,8,140,10,140,12,140,2491,9,140,1,140,
  	1,140,1,140,5,140,2496,8,140,10,140,12,140,2499,9,140,3,140,2501,8,140,
  	1,141,5,141,2504,8,141,10,141,12,141,2507,9,141,1,141,3,141,2510,8,141,
  	1,142,5,142,2513,8,142,10,142,12,142,2516,9,142,1,142,1,142,1,142,1,142,
  	3,142,2522,8,142,1,142,1,142,1,143,1,143,5,143,2528,8,143,10,143,12,143,
  	2531,9,143,1,143,1,143,1,144,1,144,1,144,1,144,1,145,1,145,1,145,5,145,
  	2542,8,145,10,145,12,145,2545,9,145,1,146,1,146,1,146,1,146,1,146,1,146,
  	1,146,1,146,1,146,1,146,1,147,1,147,1,147,1,147,1,148,1,148,1,149,1,149,
  	1,149,1,149,1,150,1,150,3,150,2569,8,150,1,151,1,151,1,151,1,151,1,151,
  	1,151,1,151,3,151,2578,8,151,1,152,1,152,1,152,1,152,1,152,4,152,2585,
  	8,152,11,152,12,152,2586,1,152,1,152,1,153,1,153,1,153,5,153,2594,8,153,
  	10,153,12,153,2597,9,153,1,153,1,153,1,153,1,153,1,153,3,153,2604,8,153,
  	1,153,3,153,2607,8,153,1,154,1,154,1,154,3,154,2612,8,154,1,154,5,154,
  	2615,8,154,10,154,12,154,2618,9,154,1,154,3,154,2621,8,154,1,155,1,155,
  	1,155,1,156,1,156,3,156,2628,8,156,1,157,5,157,2631,8,157,10,157,12,157,
  	2634,9,157,1,157,1,157,1,157,1,157,1,157,1,157,1,157,4,157,2643,8,157,
  	11,157,12,157,2644,1,157,1,157,1,157,1,157,5,157,2651,8,157,10,157,12,
  	157,2654,9,157,1,157,1,157,1,157,1,157,1,157,1,157,1,157,1,157,1,157,
  	3,157,2665,8,157,1,158,1,158,1,158,1,158,1,158,5,158,2672,8,158,10,158,
  	12,158,2675,9,158,1,159,1,159,1,159,1,159,1,159,5,159,2682,8,159,10,159,
  	12,159,2685,9,159,1,160,1,160,1,160,1,160,1,160,1,160,1,160,1,160,1,160,
  	3,160,2696,8,160,1,161,5,161,2699,8,161,10,161,12,161,2702,9,161,1,161,
  	1,161,1,161,5,161,2707,8,161,10,161,12,161,2710,9,161,1,161,1,161,1,161,
  	1,161,1,161,3,161,2717,8,161,3,161,2719,8,161,1,162,5,162,2722,8,162,
  	10,162,12,162,2725,9,162,1,162,1,162,1,162,1,163,5,163,2731,8,163,10,
  	163,12,163,2734,9,163,1,163,1,163,1,163,1,164,1,164,3,164,2741,8,164,
  	1,165,1,165,4,165,2745,8,165,11,165,12,165,2746,1,165,1,165,1,166,1,166,
  	1,166,1,166,1,166,1,167,3,167,2757,8,167,1,167,1,167,4,167,2761,8,167,
  	11,167,12,167,2762,1,167,1,167,1,168,1,168,1,168,1,168,1,168,1,168,1,
  	169,1,169,3,169,2775,8,169,1,170,1,170,1,170,1,170,1,170,1,170,1,170,
  	1,171,1,171,3,171,2786,8,171,1,172,4,172,2789,8,172,11,172,12,172,2790,
  	1,173,5,173,2794,8,173,10,173,12,173,2797,9,173,1,173,1,173,5,173,2801,
  	8,173,10,173,12,173,2804,9,173,1,174,1,174,1,174,1,174,1,174,1,174,3,
  	174,2812,8,174,1,175,1,175,1,176,1,176,3,176,2818,8,176,1,177,1,177,1,
  	178,1,178,1,179,1,179,1,180,1,180,3,180,2828,8,180,1,180,3,180,2831,8,
  	180,1,180,1,180,1,180,5,180,2836,8,180,10,180,12,180,2839,9,180,1,180,
  	1,180,1,181,3,181,2844,8,181,1,181,1,181,1,181,1,181,1,181,1,181,5,181,
  	2852,8,181,10,181,12,181,2855,9,181,1,181,1,181,1,182,1,182,3,182,2861,
  	8,182,1,183,1,183,3,183,2865,8,183,1,183,3,183,2868,8,183,1,183,1,183,
  	1,183,1,184,1,184,1,184,5,184,2876,8,184,10,184,12,184,2879,9,184,1,185,
  	1,185,1,185,1,185,1,186,1,186,1,186,1,187,1,187,1,187,1,188,1,188,1,188,
  	1,189,1,189,1,189,3,189,2897,8,189,1,189,1,189,1,190,1,190,1,190,3,190,
  	2904,8,190,1,190,1,190,1,191,1,191,1,191,3,191,2911,8,191,1,191,1,191,
  	1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,3,192,2923,8,192,1,193,
  	1,193,1,193,1,193,1,194,1,194,1,194,5,194,2932,8,194,10,194,12,194,2935,
  	9,194,3,194,2937,8,194,1,194,5,194,2940,8,194,10,194,12,194,2943,9,194,
  	1,194,1,194,1,195,1,195,1,195,1,196,1,196,1,196,5,196,2953,8,196,10,196,
  	12,196,2956,9,196,3,196,2958,8,196,1,196,5,196,2961,8,196,10,196,12,196,
  	2964,9,196,1,196,1,196,1,197,5,197,2969,8,197,10,197,12,197,2972,9,197,
  	1,197,1,197,1,197,1,197,5,197,2978,8,197,10,197,12,197,2981,9,197,1,197,
  	1,197,5,197,2985,8,197,10,197,12,197,2988,9,197,1,197,1,197,5,197,2992,
  	8,197,10,197,12,197,2995,9,197,1,197,1,197,5,197,2999,8,197,10,197,12,
  	197,3002,9,197,1,197,1,197,5,197,3006,8,197,10,197,12,197,3009,9,197,
  	1,197,1,197,5,197,3013,8,197,10,197,12,197,3016,9,197,1,197,1,197,1,197,
  	1,197,5,197,3022,8,197,10,197,12,197,3025,9,197,1,197,1,197,1,197,1,197,
  	5,197,3031,8,197,10,197,12,197,3034,9,197,1,197,1,197,5,197,3038,8,197,
  	10,197,12,197,3041,9,197,1,197,1,197,1,197,1,197,5,197,3047,8,197,10,
  	197,12,197,3050,9,197,1,197,1,197,5,197,3054,8,197,10,197,12,197,3057,
  	9,197,1,197,1,197,5,197,3061,8,197,10,197,12,197,3064,9,197,1,197,1,197,
  	5,197,3068,8,197,10,197,12,197,3071,9,197,1,197,1,197,5,197,3075,8,197,
  	10,197,12,197,3078,9,197,1,197,3,197,3081,8,197,1,198,1,198,5,198,3085,
  	8,198,10,198,12,198,3088,9,198,1,198,3,198,3091,8,198,1,199,1,199,1,200,
  	1,200,1,200,1,200,1,200,1,200,1,200,3,200,3102,8,200,1,201,1,201,1,201,
  	1,201,1,201,1,201,1,201,1,201,3,201,3112,8,201,1,202,1,202,1,202,1,202,
  	1,203,1,203,1,203,1,203,1,203,1,203,1,203,1,203,1,203,1,203,1,203,1,203,
  	1,203,3,203,3131,8,203,1,204,1,204,1,204,3,204,3136,8,204,1,204,1,204,
  	1,205,1,205,1,205,1,205,1,205,1,205,3,205,3146,8,205,1,205,1,205,1,205,
  	1,205,1,205,1,205,5,205,3154,8,205,10,205,12,205,3157,9,205,1,206,1,206,
  	3,206,3161,8,206,1,207,1,207,1,207,1,208,1,208,1,208,1,208,1,208,1,208,
  	1,209,1,209,1,209,1,209,1,209,1,209,1,209,3,209,3179,8,209,1,210,1,210,
  	1,210,1,210,1,210,4,210,3186,8,210,11,210,12,210,3187,1,210,1,210,1,210,
  	1,210,1,210,1,210,1,210,4,210,3197,8,210,11,210,12,210,3198,1,210,1,210,
  	1,210,1,210,1,210,1,210,1,210,4,210,3208,8,210,11,210,12,210,3209,1,210,
  	1,210,3,210,3214,8,210,1,211,1,211,1,211,5,211,3219,8,211,10,211,12,211,
  	3222,9,211,1,211,1,211,1,211,1,211,1,211,3,211,3229,8,211,1,211,3,211,
  	3232,8,211,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,
  	1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,1,212,
  	1,212,1,212,3,212,3258,8,212,1,213,1,213,3,213,3262,8,213,1,213,1,213,
  	1,214,1,214,1,214,1,214,5,214,3270,8,214,10,214,12,214,3273,9,214,1,214,
  	1,214,1,215,3,215,3278,8,215,1,216,1,216,3,216,3282,8,216,1,216,1,216,
  	1,217,1,217,1,217,1,217,5,217,3290,8,217,10,217,12,217,3293,9,217,1,217,
  	1,217,1,218,1,218,5,218,3299,8,218,10,218,12,218,3302,9,218,1,218,1,218,
  	1,219,1,219,1,219,1,219,1,219,3,219,3311,8,219,1,220,1,220,1,220,1,220,
  	1,220,1,220,1,220,1,220,3,220,3321,8,220,1,221,1,221,1,221,1,221,1,221,
  	1,221,1,221,1,221,3,221,3331,8,221,1,222,1,222,1,222,1,222,1,222,1,222,
  	1,222,1,222,1,222,3,222,3342,8,222,1,223,1,223,1,223,1,223,1,223,1,223,
  	1,223,1,223,3,223,3352,8,223,1,224,1,224,1,224,3,224,3357,8,224,1,224,
  	1,224,1,224,1,224,1,225,1,225,1,225,3,225,3366,8,225,1,225,1,225,1,225,
  	1,225,1,226,1,226,1,226,5,226,3375,8,226,10,226,12,226,3378,9,226,1,227,
  	1,227,1,227,5,227,3383,8,227,10,227,12,227,3386,9,227,1,228,1,228,1,228,
  	1,228,1,228,3,228,3393,8,228,1,229,1,229,1,229,1,229,1,229,3,229,3400,
  	8,229,1,230,1,230,1,231,1,231,1,232,1,232,1,232,1,232,1,232,3,232,3411,
  	8,232,1,233,1,233,1,233,1,233,1,233,1,233,3,233,3419,8,233,1,233,1,233,
  	1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,
  	1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,3,233,3445,
  	8,233,3,233,3447,8,233,1,234,1,234,1,235,1,235,1,236,1,236,1,237,1,237,
  	1,238,1,238,1,239,1,239,1,240,1,240,1,241,1,241,1,242,1,242,1,243,1,243,
  	1,244,1,244,1,245,1,245,1,246,1,246,1,247,1,247,1,248,1,248,1,249,1,249,
  	1,250,1,250,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,3,251,3491,
  	8,251,1,252,1,252,3,252,3495,8,252,1,252,1,252,1,252,1,252,1,252,3,252,
  	3502,8,252,1,252,1,252,1,252,1,252,1,252,1,253,1,253,3,253,3511,8,253,
  	1,253,1,253,1,253,1,253,1,253,3,253,3518,8,253,1,253,1,253,1,253,1,253,
  	1,253,1,254,1,254,1,255,1,255,1,256,1,256,1,256,1,256,1,256,1,256,1,256,
  	1,256,1,256,1,256,1,256,1,256,1,256,1,256,3,256,3543,8,256,1,257,1,257,
  	1,258,1,258,1,258,1,258,1,258,1,258,1,258,1,258,1,258,1,258,1,258,1,258,
  	3,258,3559,8,258,1,259,1,259,1,259,1,259,1,259,1,259,1,259,1,259,3,259,
  	3569,8,259,1,259,1,259,1,259,1,260,1,260,3,260,3576,8,260,1,261,1,261,
  	1,261,1,261,1,261,1,261,1,261,1,261,3,261,3586,8,261,1,261,1,261,1,261,
  	1,262,1,262,1,262,1,262,1,262,1,262,1,262,1,262,1,262,1,262,3,262,3601,
  	8,262,1,262,1,262,1,262,1,263,1,263,3,263,3608,8,263,1,263,3,263,3611,
  	8,263,1,264,1,264,3,264,3615,8,264,1,264,3,264,3618,8,264,1,265,1,265,
  	3,265,3622,8,265,1,265,3,265,3625,8,265,1,266,1,266,3,266,3629,8,266,
  	1,266,3,266,3632,8,266,1,267,1,267,3,267,3636,8,267,1,268,1,268,1,268,
  	1,268,1,268,1,268,1,268,1,268,3,268,3646,8,268,1,268,1,268,1,268,1,269,
  	1,269,1,269,1,269,1,269,1,269,1,269,1,269,3,269,3659,8,269,1,269,1,269,
  	1,269,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,3,270,
  	3674,8,270,1,270,1,270,1,270,1,271,1,271,1,271,1,271,1,271,1,271,1,271,
  	1,271,3,271,3687,8,271,1,271,1,271,1,271,1,272,1,272,1,272,1,272,1,272,
  	1,272,1,272,1,272,3,272,3700,8,272,1,272,1,272,1,272,1,273,1,273,3,273,
  	3707,8,273,1,273,3,273,3710,8,273,1,274,1,274,3,274,3714,8,274,1,274,
  	3,274,3717,8,274,1,275,1,275,3,275,3721,8,275,1,276,1,276,1,276,1,276,
  	1,276,1,276,1,276,1,276,1,276,1,276,3,276,3733,8,276,1,276,1,276,1,276,
  	1,277,1,277,1,277,1,277,1,277,1,277,3,277,3744,8,277,1,277,1,277,1,277,
  	1,278,1,278,1,278,1,278,1,278,1,278,3,278,3755,8,278,1,278,1,278,1,278,
  	1,279,1,279,1,279,1,279,3,279,3764,8,279,1,280,1,280,1,280,1,280,1,280,
  	1,280,1,280,1,280,1,280,1,280,3,280,3776,8,280,1,280,1,280,1,280,1,281,
  	1,281,1,282,1,282,1,283,1,283,1,284,1,284,1,284,1,284,1,284,3,284,3792,
  	8,284,1,285,1,285,1,285,1,285,1,285,3,285,3799,8,285,1,286,1,286,1,287,
  	1,287,1,288,1,288,1,289,1,289,1,290,1,290,1,291,1,291,1,292,1,292,1,293,
  	1,293,1,294,1,294,1,295,3,295,3820,8,295,1,295,1,295,1,295,3,295,3825,
  	8,295,1,296,1,296,1,296,1,296,3,296,3831,8,296,1,297,1,297,1,297,3,297,
  	3836,8,297,1,298,1,298,3,298,3840,8,298,1,299,1,299,1,299,1,299,1,299,
  	5,299,3847,8,299,10,299,12,299,3850,9,299,1,299,1,299,1,300,1,300,1,301,
  	1,301,1,301,1,301,1,301,3,301,3861,8,301,1,302,1,302,1,302,1,302,1,302,
  	1,302,1,302,1,302,1,302,1,302,1,302,1,302,1,302,1,302,1,302,1,302,1,302,
  	1,302,1,302,3,302,3882,8,302,1,303,1,303,3,303,3886,8,303,1,304,1,304,
  	1,304,1,304,5,304,3892,8,304,10,304,12,304,3895,9,304,1,304,1,304,1,305,
  	1,305,1,305,1,305,5,305,3903,8,305,10,305,12,305,3906,9,305,1,305,1,305,
  	1,306,1,306,1,306,1,306,1,306,1,307,1,307,1,307,1,307,5,307,3919,8,307,
  	10,307,12,307,3922,9,307,1,307,1,307,1,308,1,308,1,308,1,308,1,308,1,
  	309,1,309,1,309,1,309,1,309,1,310,1,310,5,310,3938,8,310,10,310,12,310,
  	3941,9,310,1,310,1,310,1,310,1,310,5,310,3947,8,310,10,310,12,310,3950,
  	9,310,1,310,1,310,1,311,1,311,1,311,1,311,1,311,5,311,3959,8,311,10,311,
  	12,311,3962,9,311,1,311,1,311,1,312,1,312,5,312,3968,8,312,10,312,12,
  	312,3971,9,312,1,312,1,312,1,312,1,312,5,312,3977,8,312,10,312,12,312,
  	3980,9,312,1,312,1,312,1,313,1,313,3,313,3986,8,313,1,314,1,314,1,314,
  	1,314,5,314,3992,8,314,10,314,12,314,3995,9,314,1,314,1,314,1,315,1,315,
  	1,316,1,316,1,317,1,317,1,317,1,317,5,317,4007,8,317,10,317,12,317,4010,
  	9,317,1,317,1,317,3,317,4014,8,317,1,317,1,317,1,317,5,317,4019,8,317,
  	10,317,12,317,4022,9,317,1,317,1,317,1,317,1,317,5,317,4028,8,317,10,
  	317,12,317,4031,9,317,1,317,1,317,1,317,1,317,5,317,4037,8,317,10,317,
  	12,317,4040,9,317,1,317,1,317,1,317,1,317,5,317,4046,8,317,10,317,12,
  	317,4049,9,317,1,317,1,317,1,317,1,317,5,317,4055,8,317,10,317,12,317,
  	4058,9,317,1,317,1,317,1,317,1,317,5,317,4064,8,317,10,317,12,317,4067,
  	9,317,1,317,1,317,1,317,1,317,5,317,4073,8,317,10,317,12,317,4076,9,317,
  	1,317,1,317,1,317,1,317,5,317,4082,8,317,10,317,12,317,4085,9,317,1,317,
  	1,317,1,317,1,317,5,317,4091,8,317,10,317,12,317,4094,9,317,1,317,1,317,
  	1,317,1,317,5,317,4100,8,317,10,317,12,317,4103,9,317,1,317,1,317,1,317,
  	1,317,5,317,4109,8,317,10,317,12,317,4112,9,317,1,317,1,317,1,317,1,317,
  	5,317,4118,8,317,10,317,12,317,4121,9,317,1,317,1,317,1,317,1,317,5,317,
  	4127,8,317,10,317,12,317,4130,9,317,1,318,1,318,1,318,1,318,1,318,1,318,
  	3,318,4138,8,318,1,319,1,319,1,319,1,319,1,319,1,319,1,319,1,319,1,319,
  	1,319,1,319,1,319,1,319,3,319,4153,8,319,1,320,1,320,1,321,1,321,1,321,
  	1,321,5,321,4161,8,321,10,321,12,321,4164,9,321,1,321,1,321,3,321,4168,
  	8,321,1,321,1,321,1,321,5,321,4173,8,321,10,321,12,321,4176,9,321,1,321,
  	1,321,1,321,1,321,5,321,4182,8,321,10,321,12,321,4185,9,321,1,321,1,321,
  	1,321,1,321,5,321,4191,8,321,10,321,12,321,4194,9,321,1,321,1,321,1,321,
  	1,321,5,321,4200,8,321,10,321,12,321,4203,9,321,1,321,1,321,1,321,1,321,
  	5,321,4209,8,321,10,321,12,321,4212,9,321,1,321,1,321,1,321,1,321,5,321,
  	4218,8,321,10,321,12,321,4221,9,321,1,321,1,321,1,321,1,321,5,321,4227,
  	8,321,10,321,12,321,4230,9,321,1,321,1,321,1,321,1,321,5,321,4236,8,321,
  	10,321,12,321,4239,9,321,1,321,1,321,1,321,1,321,5,321,4245,8,321,10,
  	321,12,321,4248,9,321,1,321,1,321,1,321,1,321,5,321,4254,8,321,10,321,
  	12,321,4257,9,321,1,321,1,321,1,321,1,321,5,321,4263,8,321,10,321,12,
  	321,4266,9,321,1,321,1,321,1,321,1,321,5,321,4272,8,321,10,321,12,321,
  	4275,9,321,1,321,1,321,1,321,1,321,5,321,4281,8,321,10,321,12,321,4284,
  	9,321,1,322,1,322,1,323,1,323,1,323,1,323,1,323,1,323,3,323,4294,8,323,
  	1,324,1,324,1,324,1,324,5,324,4300,8,324,10,324,12,324,4303,9,324,1,324,
  	1,324,3,324,4307,8,324,1,324,1,324,1,324,5,324,4312,8,324,10,324,12,324,
  	4315,9,324,1,324,1,324,1,324,1,324,5,324,4321,8,324,10,324,12,324,4324,
  	9,324,1,324,1,324,1,324,1,324,5,324,4330,8,324,10,324,12,324,4333,9,324,
  	1,324,1,324,1,324,1,324,5,324,4339,8,324,10,324,12,324,4342,9,324,1,324,
  	1,324,1,324,1,324,5,324,4348,8,324,10,324,12,324,4351,9,324,1,324,1,324,
  	1,324,1,324,5,324,4357,8,324,10,324,12,324,4360,9,324,1,324,1,324,1,324,
  	1,324,5,324,4366,8,324,10,324,12,324,4369,9,324,1,324,1,324,1,324,1,324,
  	5,324,4375,8,324,10,324,12,324,4378,9,324,1,325,1,325,1,325,1,325,1,325,
  	1,325,3,325,4386,8,325,1,326,1,326,1,327,1,327,1,327,1,327,1,327,1,327,
  	1,327,1,327,1,327,1,327,1,327,1,327,1,327,3,327,4403,8,327,1,328,1,328,
  	1,329,1,329,1,329,1,329,1,329,1,329,3,329,4413,8,329,1,329,1,329,1,329,
  	1,329,1,329,1,329,1,329,1,329,1,329,3,329,4424,8,329,1,330,1,330,1,330,
  	1,330,1,330,1,330,1,330,1,330,1,330,1,330,3,330,4436,8,330,1,331,1,331,
  	1,331,3,331,4441,8,331,1,331,1,331,1,331,1,331,1,331,1,331,1,331,1,331,
  	1,331,3,331,4452,8,331,1,332,3,332,4455,8,332,1,332,1,332,1,332,1,332,
  	1,333,1,333,1,333,1,333,4,333,4465,8,333,11,333,12,333,4466,1,334,1,334,
  	3,334,4471,8,334,1,334,1,334,1,334,1,334,5,334,4477,8,334,10,334,12,334,
  	4480,9,334,1,334,1,334,3,334,4484,8,334,1,335,3,335,4487,8,335,1,335,
  	1,335,1,335,1,335,1,336,1,336,1,336,1,336,4,336,4497,8,336,11,336,12,
  	336,4498,1,337,1,337,3,337,4503,8,337,1,337,1,337,1,337,1,337,5,337,4509,
  	8,337,10,337,12,337,4512,9,337,1,337,1,337,3,337,4516,8,337,1,338,1,338,
  	1,339,1,339,1,340,1,340,1,340,1,340,1,340,3,340,4527,8,340,1,341,1,341,
  	1,341,3,341,4532,8,341,1,342,1,342,3,342,4536,8,342,1,342,1,342,1,342,
  	3,342,4541,8,342,1,343,3,343,4544,8,343,1,343,1,343,1,343,1,344,3,344,
  	4550,8,344,1,344,1,344,1,344,1,345,3,345,4556,8,345,1,345,1,345,1,345,
  	1,346,1,346,1,347,1,347,1,348,1,348,1,349,1,349,1,350,1,350,1,351,1,351,
  	1,352,1,352,1,353,1,353,1,354,1,354,1,355,1,355,1,356,1,356,1,357,1,357,
  	1,358,1,358,1,359,1,359,1,360,1,360,1,360,1,360,1,360,5,360,4594,8,360,
  	10,360,12,360,4597,9,360,1,360,1,360,1,360,1,361,1,361,1,361,3,361,4605,
  	8,361,1,362,1,362,1,363,1,363,1,364,1,364,1,365,1,365,1,366,1,366,1,367,
  	1,367,1,368,1,368,1,369,1,369,1,370,1,370,1,371,1,371,1,372,5,372,4628,
  	8,372,10,372,12,372,4631,9,372,1,372,1,372,1,373,1,373,3,373,4637,8,373,
  	1,373,1,373,1,374,1,374,1,374,3,374,4644,8,374,1,375,1,375,1,376,1,376,
  	1,377,1,377,1,378,1,378,1,379,1,379,1,380,1,380,1,381,1,381,1,382,1,382,
  	1,383,1,383,1,384,1,384,1,385,1,385,1,386,1,386,1,387,1,387,1,388,1,388,
  	1,389,1,389,1,390,1,390,1,391,1,391,1,392,1,392,1,393,1,393,1,394,1,394,
  	1,394,0,4,410,634,642,648,395,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
  	30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,
  	76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
  	190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,
  	226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,
  	262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,
  	298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,
  	334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,
  	370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,
  	406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,
  	442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,
  	478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,
  	514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,
  	550,552,554,556,558,560,562,564,566,568,570,572,574,576,578,580,582,584,
  	586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,616,618,620,
  	622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,652,654,656,
  	658,660,662,664,666,668,670,672,674,676,678,680,682,684,686,688,690,692,
  	694,696,698,700,702,704,706,708,710,712,714,716,718,720,722,724,726,728,
  	730,732,734,736,738,740,742,744,746,748,750,752,754,756,758,760,762,764,
  	766,768,770,772,774,776,778,780,782,784,786,788,0,26,2,0,67,67,70,70,
  	3,0,61,61,93,94,115,115,2,0,103,103,127,127,6,0,111,112,119,122,124,124,
  	126,126,129,129,133,134,2,0,61,61,115,115,4,0,89,89,110,110,112,112,131,
  	131,4,0,87,87,109,109,111,111,130,130,2,0,13,13,92,92,2,0,7,8,77,78,3,
  	0,73,73,83,83,98,99,5,0,2,2,71,71,74,74,79,79,135,136,2,0,6,6,76,76,2,
  	0,101,102,117,118,2,0,100,100,116,116,1,0,229,230,2,0,72,72,84,84,2,0,
  	196,196,198,198,3,0,179,179,197,197,205,205,3,0,158,159,163,163,171,171,
  	4,0,162,162,170,170,190,190,195,195,3,0,156,157,166,166,169,169,3,0,168,
  	168,174,174,181,181,2,0,166,166,169,169,8,0,168,168,173,175,177,178,181,
  	181,187,187,196,196,198,198,206,206,6,0,168,168,173,175,177,178,181,181,
  	187,187,206,206,2,0,219,219,223,223,4940,0,793,1,0,0,0,2,801,1,0,0,0,
  	4,803,1,0,0,0,6,818,1,0,0,0,8,827,1,0,0,0,10,831,1,0,0,0,12,836,1,0,0,
  	0,14,846,1,0,0,0,16,851,1,0,0,0,18,871,1,0,0,0,20,873,1,0,0,0,22,888,
  	1,0,0,0,24,894,1,0,0,0,26,896,1,0,0,0,28,900,1,0,0,0,30,904,1,0,0,0,32,
  	908,1,0,0,0,34,948,1,0,0,0,36,950,1,0,0,0,38,952,1,0,0,0,40,995,1,0,0,
  	0,42,1001,1,0,0,0,44,1003,1,0,0,0,46,1005,1,0,0,0,48,1025,1,0,0,0,50,
  	1027,1,0,0,0,52,1055,1,0,0,0,54,1080,1,0,0,0,56,1168,1,0,0,0,58,1180,
  	1,0,0,0,60,1182,1,0,0,0,62,1186,1,0,0,0,64,1198,1,0,0,0,66,1210,1,0,0,
  	0,68,1234,1,0,0,0,70,1236,1,0,0,0,72,1238,1,0,0,0,74,1241,1,0,0,0,76,
  	1249,1,0,0,0,78,1257,1,0,0,0,80,1264,1,0,0,0,82,1287,1,0,0,0,84,1301,
  	1,0,0,0,86,1303,1,0,0,0,88,1310,1,0,0,0,90,1312,1,0,0,0,92,1324,1,0,0,
  	0,94,1360,1,0,0,0,96,1362,1,0,0,0,98,1366,1,0,0,0,100,1484,1,0,0,0,102,
  	1486,1,0,0,0,104,1490,1,0,0,0,106,1494,1,0,0,0,108,1504,1,0,0,0,110,1508,
  	1,0,0,0,112,1510,1,0,0,0,114,1514,1,0,0,0,116,1527,1,0,0,0,118,1540,1,
  	0,0,0,120,1578,1,0,0,0,122,1580,1,0,0,0,124,1582,1,0,0,0,126,1593,1,0,
  	0,0,128,1610,1,0,0,0,130,1623,1,0,0,0,132,1628,1,0,0,0,134,1630,1,0,0,
  	0,136,1638,1,0,0,0,138,1646,1,0,0,0,140,1653,1,0,0,0,142,1661,1,0,0,0,
  	144,1669,1,0,0,0,146,1676,1,0,0,0,148,1684,1,0,0,0,150,1692,1,0,0,0,152,
  	1700,1,0,0,0,154,1708,1,0,0,0,156,1716,1,0,0,0,158,1724,1,0,0,0,160,1729,
  	1,0,0,0,162,1733,1,0,0,0,164,1737,1,0,0,0,166,1746,1,0,0,0,168,1771,1,
  	0,0,0,170,1773,1,0,0,0,172,1775,1,0,0,0,174,1777,1,0,0,0,176,1779,1,0,
  	0,0,178,1785,1,0,0,0,180,1829,1,0,0,0,182,1841,1,0,0,0,184,1843,1,0,0,
  	0,186,1854,1,0,0,0,188,1868,1,0,0,0,190,1905,1,0,0,0,192,1935,1,0,0,0,
  	194,1937,1,0,0,0,196,1966,1,0,0,0,198,1983,1,0,0,0,200,2000,1,0,0,0,202,
  	2017,1,0,0,0,204,2019,1,0,0,0,206,2102,1,0,0,0,208,2104,1,0,0,0,210,2112,
  	1,0,0,0,212,2120,1,0,0,0,214,2127,1,0,0,0,216,2266,1,0,0,0,218,2269,1,
  	0,0,0,220,2282,1,0,0,0,222,2293,1,0,0,0,224,2304,1,0,0,0,226,2320,1,0,
  	0,0,228,2336,1,0,0,0,230,2345,1,0,0,0,232,2356,1,0,0,0,234,2362,1,0,0,
  	0,236,2382,1,0,0,0,238,2400,1,0,0,0,240,2402,1,0,0,0,242,2404,1,0,0,0,
  	244,2406,1,0,0,0,246,2408,1,0,0,0,248,2410,1,0,0,0,250,2412,1,0,0,0,252,
  	2414,1,0,0,0,254,2416,1,0,0,0,256,2418,1,0,0,0,258,2420,1,0,0,0,260,2422,
  	1,0,0,0,262,2424,1,0,0,0,264,2426,1,0,0,0,266,2428,1,0,0,0,268,2442,1,
  	0,0,0,270,2463,1,0,0,0,272,2465,1,0,0,0,274,2467,1,0,0,0,276,2475,1,0,
  	0,0,278,2480,1,0,0,0,280,2500,1,0,0,0,282,2505,1,0,0,0,284,2514,1,0,0,
  	0,286,2525,1,0,0,0,288,2534,1,0,0,0,290,2538,1,0,0,0,292,2546,1,0,0,0,
  	294,2556,1,0,0,0,296,2560,1,0,0,0,298,2562,1,0,0,0,300,2568,1,0,0,0,302,
  	2570,1,0,0,0,304,2579,1,0,0,0,306,2606,1,0,0,0,308,2620,1,0,0,0,310,2622,
  	1,0,0,0,312,2627,1,0,0,0,314,2664,1,0,0,0,316,2666,1,0,0,0,318,2676,1,
  	0,0,0,320,2695,1,0,0,0,322,2718,1,0,0,0,324,2723,1,0,0,0,326,2732,1,0,
  	0,0,328,2740,1,0,0,0,330,2742,1,0,0,0,332,2750,1,0,0,0,334,2756,1,0,0,
  	0,336,2766,1,0,0,0,338,2774,1,0,0,0,340,2776,1,0,0,0,342,2785,1,0,0,0,
  	344,2788,1,0,0,0,346,2795,1,0,0,0,348,2811,1,0,0,0,350,2813,1,0,0,0,352,
  	2817,1,0,0,0,354,2819,1,0,0,0,356,2821,1,0,0,0,358,2823,1,0,0,0,360,2825,
  	1,0,0,0,362,2843,1,0,0,0,364,2858,1,0,0,0,366,2862,1,0,0,0,368,2872,1,
  	0,0,0,370,2880,1,0,0,0,372,2884,1,0,0,0,374,2887,1,0,0,0,376,2890,1,0,
  	0,0,378,2893,1,0,0,0,380,2900,1,0,0,0,382,2907,1,0,0,0,384,2922,1,0,0,
  	0,386,2924,1,0,0,0,388,2928,1,0,0,0,390,2946,1,0,0,0,392,2949,1,0,0,0,
  	394,3080,1,0,0,0,396,3090,1,0,0,0,398,3092,1,0,0,0,400,3101,1,0,0,0,402,
  	3111,1,0,0,0,404,3113,1,0,0,0,406,3130,1,0,0,0,408,3132,1,0,0,0,410,3145,
  	1,0,0,0,412,3160,1,0,0,0,414,3162,1,0,0,0,416,3165,1,0,0,0,418,3171,1,
  	0,0,0,420,3213,1,0,0,0,422,3231,1,0,0,0,424,3257,1,0,0,0,426,3259,1,0,
  	0,0,428,3265,1,0,0,0,430,3277,1,0,0,0,432,3279,1,0,0,0,434,3285,1,0,0,
  	0,436,3296,1,0,0,0,438,3310,1,0,0,0,440,3320,1,0,0,0,442,3330,1,0,0,0,
  	444,3341,1,0,0,0,446,3351,1,0,0,0,448,3353,1,0,0,0,450,3362,1,0,0,0,452,
  	3371,1,0,0,0,454,3379,1,0,0,0,456,3387,1,0,0,0,458,3394,1,0,0,0,460,3401,
  	1,0,0,0,462,3403,1,0,0,0,464,3410,1,0,0,0,466,3446,1,0,0,0,468,3448,1,
  	0,0,0,470,3450,1,0,0,0,472,3452,1,0,0,0,474,3454,1,0,0,0,476,3456,1,0,
  	0,0,478,3458,1,0,0,0,480,3460,1,0,0,0,482,3462,1,0,0,0,484,3464,1,0,0,
  	0,486,3466,1,0,0,0,488,3468,1,0,0,0,490,3470,1,0,0,0,492,3472,1,0,0,0,
  	494,3474,1,0,0,0,496,3476,1,0,0,0,498,3478,1,0,0,0,500,3480,1,0,0,0,502,
  	3490,1,0,0,0,504,3492,1,0,0,0,506,3508,1,0,0,0,508,3524,1,0,0,0,510,3526,
  	1,0,0,0,512,3542,1,0,0,0,514,3544,1,0,0,0,516,3558,1,0,0,0,518,3560,1,
  	0,0,0,520,3573,1,0,0,0,522,3577,1,0,0,0,524,3590,1,0,0,0,526,3605,1,0,
  	0,0,528,3612,1,0,0,0,530,3619,1,0,0,0,532,3626,1,0,0,0,534,3633,1,0,0,
  	0,536,3637,1,0,0,0,538,3650,1,0,0,0,540,3663,1,0,0,0,542,3678,1,0,0,0,
  	544,3691,1,0,0,0,546,3704,1,0,0,0,548,3711,1,0,0,0,550,3718,1,0,0,0,552,
  	3722,1,0,0,0,554,3737,1,0,0,0,556,3748,1,0,0,0,558,3759,1,0,0,0,560,3765,
  	1,0,0,0,562,3780,1,0,0,0,564,3782,1,0,0,0,566,3784,1,0,0,0,568,3786,1,
  	0,0,0,570,3793,1,0,0,0,572,3800,1,0,0,0,574,3802,1,0,0,0,576,3804,1,0,
  	0,0,578,3806,1,0,0,0,580,3808,1,0,0,0,582,3810,1,0,0,0,584,3812,1,0,0,
  	0,586,3814,1,0,0,0,588,3816,1,0,0,0,590,3819,1,0,0,0,592,3826,1,0,0,0,
  	594,3835,1,0,0,0,596,3839,1,0,0,0,598,3841,1,0,0,0,600,3853,1,0,0,0,602,
  	3860,1,0,0,0,604,3881,1,0,0,0,606,3885,1,0,0,0,608,3887,1,0,0,0,610,3898,
  	1,0,0,0,612,3909,1,0,0,0,614,3914,1,0,0,0,616,3925,1,0,0,0,618,3930,1,
  	0,0,0,620,3935,1,0,0,0,622,3953,1,0,0,0,624,3965,1,0,0,0,626,3983,1,0,
  	0,0,628,3987,1,0,0,0,630,3998,1,0,0,0,632,4000,1,0,0,0,634,4013,1,0,0,
  	0,636,4131,1,0,0,0,638,4152,1,0,0,0,640,4154,1,0,0,0,642,4167,1,0,0,0,
  	644,4285,1,0,0,0,646,4287,1,0,0,0,648,4306,1,0,0,0,650,4379,1,0,0,0,652,
  	4387,1,0,0,0,654,4402,1,0,0,0,656,4404,1,0,0,0,658,4423,1,0,0,0,660,4435,
  	1,0,0,0,662,4451,1,0,0,0,664,4454,1,0,0,0,666,4464,1,0,0,0,668,4483,1,
  	0,0,0,670,4486,1,0,0,0,672,4496,1,0,0,0,674,4515,1,0,0,0,676,4517,1,0,
  	0,0,678,4519,1,0,0,0,680,4526,1,0,0,0,682,4531,1,0,0,0,684,4540,1,0,0,
  	0,686,4543,1,0,0,0,688,4549,1,0,0,0,690,4555,1,0,0,0,692,4560,1,0,0,0,
  	694,4562,1,0,0,0,696,4564,1,0,0,0,698,4566,1,0,0,0,700,4568,1,0,0,0,702,
  	4570,1,0,0,0,704,4572,1,0,0,0,706,4574,1,0,0,0,708,4576,1,0,0,0,710,4578,
  	1,0,0,0,712,4580,1,0,0,0,714,4582,1,0,0,0,716,4584,1,0,0,0,718,4586,1,
  	0,0,0,720,4588,1,0,0,0,722,4601,1,0,0,0,724,4606,1,0,0,0,726,4608,1,0,
  	0,0,728,4610,1,0,0,0,730,4612,1,0,0,0,732,4614,1,0,0,0,734,4616,1,0,0,
  	0,736,4618,1,0,0,0,738,4620,1,0,0,0,740,4622,1,0,0,0,742,4624,1,0,0,0,
  	744,4629,1,0,0,0,746,4634,1,0,0,0,748,4643,1,0,0,0,750,4645,1,0,0,0,752,
  	4647,1,0,0,0,754,4649,1,0,0,0,756,4651,1,0,0,0,758,4653,1,0,0,0,760,4655,
  	1,0,0,0,762,4657,1,0,0,0,764,4659,1,0,0,0,766,4661,1,0,0,0,768,4663,1,
  	0,0,0,770,4665,1,0,0,0,772,4667,1,0,0,0,774,4669,1,0,0,0,776,4671,1,0,
  	0,0,778,4673,1,0,0,0,780,4675,1,0,0,0,782,4677,1,0,0,0,784,4679,1,0,0,
  	0,786,4681,1,0,0,0,788,4683,1,0,0,0,790,792,3,2,1,0,791,790,1,0,0,0,792,
  	795,1,0,0,0,793,791,1,0,0,0,793,794,1,0,0,0,794,796,1,0,0,0,795,793,1,
  	0,0,0,796,797,5,0,0,1,797,1,1,0,0,0,798,802,3,4,2,0,799,802,3,8,4,0,800,
  	802,3,62,31,0,801,798,1,0,0,0,801,799,1,0,0,0,801,800,1,0,0,0,802,3,1,
  	0,0,0,803,804,5,65,0,0,804,805,3,754,377,0,805,810,3,10,5,0,806,807,5,
  	183,0,0,807,809,3,10,5,0,808,806,1,0,0,0,809,812,1,0,0,0,810,808,1,0,
  	0,0,810,811,1,0,0,0,811,814,1,0,0,0,812,810,1,0,0,0,813,815,3,6,3,0,814,
  	813,1,0,0,0,814,815,1,0,0,0,815,816,1,0,0,0,816,817,5,204,0,0,817,5,1,
  	0,0,0,818,819,5,69,0,0,819,824,3,10,5,0,820,821,5,183,0,0,821,823,3,10,
  	5,0,822,820,1,0,0,0,823,826,1,0,0,0,824,822,1,0,0,0,824,825,1,0,0,0,825,
  	7,1,0,0,0,826,824,1,0,0,0,827,828,5,56,0,0,828,829,3,10,5,0,829,830,5,
  	204,0,0,830,9,1,0,0,0,831,832,5,226,0,0,832,11,1,0,0,0,833,835,3,14,7,
  	0,834,833,1,0,0,0,835,838,1,0,0,0,836,834,1,0,0,0,836,837,1,0,0,0,837,
  	839,1,0,0,0,838,836,1,0,0,0,839,840,5,0,0,1,840,13,1,0,0,0,841,847,3,
  	16,8,0,842,847,3,314,157,0,843,847,3,62,31,0,844,847,3,32,16,0,845,847,
  	3,20,10,0,846,841,1,0,0,0,846,842,1,0,0,0,846,843,1,0,0,0,846,844,1,0,
  	0,0,846,845,1,0,0,0,847,15,1,0,0,0,848,850,3,720,360,0,849,848,1,0,0,
  	0,850,853,1,0,0,0,851,849,1,0,0,0,851,852,1,0,0,0,852,854,1,0,0,0,853,
  	851,1,0,0,0,854,855,3,18,9,0,855,857,3,756,378,0,856,858,3,38,19,0,857,
  	856,1,0,0,0,857,858,1,0,0,0,858,860,1,0,0,0,859,861,3,40,20,0,860,859,
  	1,0,0,0,860,861,1,0,0,0,861,862,1,0,0,0,862,866,5,204,0,0,863,865,3,54,
  	27,0,864,863,1,0,0,0,865,868,1,0,0,0,866,864,1,0,0,0,866,867,1,0,0,0,
  	867,869,1,0,0,0,868,866,1,0,0,0,869,870,5,39,0,0,870,17,1,0,0,0,871,872,
  	7,0,0,0,872,19,1,0,0,0,873,874,5,140,0,0,874,875,3,22,11,0,875,879,5,
  	204,0,0,876,878,3,24,12,0,877,876,1,0,0,0,878,881,1,0,0,0,879,877,1,0,
  	0,0,879,880,1,0,0,0,880,882,1,0,0,0,881,879,1,0,0,0,882,883,5,141,0,0,
  	883,21,1,0,0,0,884,889,3,748,374,0,885,889,5,138,0,0,886,889,5,144,0,
  	0,887,889,5,145,0,0,888,884,1,0,0,0,888,885,1,0,0,0,888,886,1,0,0,0,888,
  	887,1,0,0,0,889,23,1,0,0,0,890,895,3,26,13,0,891,895,3,28,14,0,892,895,
  	3,30,15,0,893,895,5,204,0,0,894,890,1,0,0,0,894,891,1,0,0,0,894,892,1,
  	0,0,0,894,893,1,0,0,0,895,25,1,0,0,0,896,897,5,147,0,0,897,898,3,748,
  	374,0,898,899,5,204,0,0,899,27,1,0,0,0,900,901,5,148,0,0,901,902,3,748,
  	374,0,902,903,5,204,0,0,903,29,1,0,0,0,904,905,5,146,0,0,905,906,3,748,
  	374,0,906,907,5,204,0,0,907,31,1,0,0,0,908,909,5,142,0,0,909,910,3,748,
  	374,0,910,914,5,204,0,0,911,913,3,34,17,0,912,911,1,0,0,0,913,916,1,0,
  	0,0,914,912,1,0,0,0,914,915,1,0,0,0,915,917,1,0,0,0,916,914,1,0,0,0,917,
  	918,5,143,0,0,918,33,1,0,0,0,919,920,5,149,0,0,920,921,5,188,0,0,921,
  	922,5,217,0,0,922,949,5,204,0,0,923,924,5,150,0,0,924,925,5,188,0,0,925,
  	926,3,36,18,0,926,927,5,204,0,0,927,949,1,0,0,0,928,929,5,151,0,0,929,
  	930,5,188,0,0,930,931,3,748,374,0,931,932,5,204,0,0,932,949,1,0,0,0,933,
  	934,5,152,0,0,934,935,5,188,0,0,935,936,3,748,374,0,936,937,5,204,0,0,
  	937,949,1,0,0,0,938,939,5,153,0,0,939,940,5,188,0,0,940,941,3,680,340,
  	0,941,942,5,204,0,0,942,949,1,0,0,0,943,944,5,265,0,0,944,945,5,188,0,
  	0,945,946,3,642,321,0,946,947,5,204,0,0,947,949,1,0,0,0,948,919,1,0,0,
  	0,948,923,1,0,0,0,948,928,1,0,0,0,948,933,1,0,0,0,948,938,1,0,0,0,948,
  	943,1,0,0,0,949,35,1,0,0,0,950,951,3,748,374,0,951,37,1,0,0,0,952,953,
  	5,191,0,0,953,954,5,194,0,0,954,959,3,84,42,0,955,956,5,183,0,0,956,958,
  	3,84,42,0,957,955,1,0,0,0,958,961,1,0,0,0,959,957,1,0,0,0,959,960,1,0,
  	0,0,960,962,1,0,0,0,961,959,1,0,0,0,962,963,5,203,0,0,963,39,1,0,0,0,
  	964,965,5,194,0,0,965,970,3,52,26,0,966,967,5,183,0,0,967,969,3,52,26,
  	0,968,966,1,0,0,0,969,972,1,0,0,0,970,968,1,0,0,0,970,971,1,0,0,0,971,
  	973,1,0,0,0,972,970,1,0,0,0,973,974,5,203,0,0,974,996,1,0,0,0,975,976,
  	5,194,0,0,976,979,3,42,21,0,977,978,5,183,0,0,978,980,3,42,21,0,979,977,
  	1,0,0,0,980,981,1,0,0,0,981,979,1,0,0,0,981,982,1,0,0,0,982,983,1,0,0,
  	0,983,984,5,203,0,0,984,996,1,0,0,0,985,986,5,194,0,0,986,987,3,44,22,
  	0,987,988,5,203,0,0,988,996,1,0,0,0,989,990,5,194,0,0,990,991,3,46,23,
  	0,991,992,5,203,0,0,992,996,1,0,0,0,993,994,5,194,0,0,994,996,5,203,0,
  	0,995,964,1,0,0,0,995,975,1,0,0,0,995,985,1,0,0,0,995,989,1,0,0,0,995,
  	993,1,0,0,0,996,41,1,0,0,0,997,999,3,44,22,0,998,997,1,0,0,0,998,999,
  	1,0,0,0,999,1002,1,0,0,0,1000,1002,3,46,23,0,1001,998,1,0,0,0,1001,1000,
  	1,0,0,0,1002,43,1,0,0,0,1003,1004,3,48,24,0,1004,45,1,0,0,0,1005,1006,
  	5,186,0,0,1006,1007,3,766,383,0,1007,1009,5,194,0,0,1008,1010,3,48,24,
  	0,1009,1008,1,0,0,0,1009,1010,1,0,0,0,1010,1011,1,0,0,0,1011,1012,5,203,
  	0,0,1012,47,1,0,0,0,1013,1026,3,50,25,0,1014,1015,5,193,0,0,1015,1020,
  	3,50,25,0,1016,1017,5,183,0,0,1017,1019,3,50,25,0,1018,1016,1,0,0,0,1019,
  	1022,1,0,0,0,1020,1018,1,0,0,0,1020,1021,1,0,0,0,1021,1023,1,0,0,0,1022,
  	1020,1,0,0,0,1023,1024,5,202,0,0,1024,1026,1,0,0,0,1025,1013,1,0,0,0,
  	1025,1014,1,0,0,0,1026,49,1,0,0,0,1027,1032,3,766,383,0,1028,1029,5,192,
  	0,0,1029,1030,3,638,319,0,1030,1031,5,201,0,0,1031,1033,1,0,0,0,1032,
  	1028,1,0,0,0,1032,1033,1,0,0,0,1033,51,1,0,0,0,1034,1036,3,720,360,0,
  	1035,1034,1,0,0,0,1036,1039,1,0,0,0,1037,1035,1,0,0,0,1037,1038,1,0,0,
  	0,1038,1040,1,0,0,0,1039,1037,1,0,0,0,1040,1056,3,90,45,0,1041,1043,3,
  	720,360,0,1042,1041,1,0,0,0,1043,1046,1,0,0,0,1044,1042,1,0,0,0,1044,
  	1045,1,0,0,0,1045,1047,1,0,0,0,1046,1044,1,0,0,0,1047,1056,3,92,46,0,
  	1048,1050,3,720,360,0,1049,1048,1,0,0,0,1050,1053,1,0,0,0,1051,1049,1,
  	0,0,0,1051,1052,1,0,0,0,1052,1054,1,0,0,0,1053,1051,1,0,0,0,1054,1056,
  	3,94,47,0,1055,1037,1,0,0,0,1055,1044,1,0,0,0,1055,1051,1,0,0,0,1056,
  	53,1,0,0,0,1057,1058,3,52,26,0,1058,1059,5,204,0,0,1059,1081,1,0,0,0,
  	1060,1081,3,56,28,0,1061,1081,3,286,143,0,1062,1081,3,436,218,0,1063,
  	1065,3,720,360,0,1064,1063,1,0,0,0,1065,1068,1,0,0,0,1066,1064,1,0,0,
  	0,1066,1067,1,0,0,0,1067,1069,1,0,0,0,1068,1066,1,0,0,0,1069,1070,3,84,
  	42,0,1070,1071,5,204,0,0,1071,1081,1,0,0,0,1072,1074,3,720,360,0,1073,
  	1072,1,0,0,0,1074,1077,1,0,0,0,1075,1073,1,0,0,0,1075,1076,1,0,0,0,1076,
  	1078,1,0,0,0,1077,1075,1,0,0,0,1078,1081,3,86,43,0,1079,1081,3,112,56,
  	0,1080,1057,1,0,0,0,1080,1060,1,0,0,0,1080,1061,1,0,0,0,1080,1062,1,0,
  	0,0,1080,1066,1,0,0,0,1080,1075,1,0,0,0,1080,1079,1,0,0,0,1081,55,1,0,
  	0,0,1082,1084,3,720,360,0,1083,1082,1,0,0,0,1084,1087,1,0,0,0,1085,1083,
  	1,0,0,0,1085,1086,1,0,0,0,1086,1088,1,0,0,0,1087,1085,1,0,0,0,1088,1169,
  	3,58,29,0,1089,1091,3,720,360,0,1090,1089,1,0,0,0,1091,1094,1,0,0,0,1092,
  	1090,1,0,0,0,1092,1093,1,0,0,0,1093,1095,1,0,0,0,1094,1092,1,0,0,0,1095,
  	1096,3,82,41,0,1096,1097,5,204,0,0,1097,1169,1,0,0,0,1098,1100,3,720,
  	360,0,1099,1098,1,0,0,0,1100,1103,1,0,0,0,1101,1099,1,0,0,0,1101,1102,
  	1,0,0,0,1102,1104,1,0,0,0,1103,1101,1,0,0,0,1104,1169,3,60,30,0,1105,
  	1107,3,720,360,0,1106,1105,1,0,0,0,1107,1110,1,0,0,0,1108,1106,1,0,0,
  	0,1108,1109,1,0,0,0,1109,1111,1,0,0,0,1110,1108,1,0,0,0,1111,1169,3,366,
  	183,0,1112,1114,3,720,360,0,1113,1112,1,0,0,0,1114,1117,1,0,0,0,1115,
  	1113,1,0,0,0,1115,1116,1,0,0,0,1116,1118,1,0,0,0,1117,1115,1,0,0,0,1118,
  	1169,3,216,108,0,1119,1121,3,720,360,0,1120,1119,1,0,0,0,1121,1124,1,
  	0,0,0,1122,1120,1,0,0,0,1122,1123,1,0,0,0,1123,1125,1,0,0,0,1124,1122,
  	1,0,0,0,1125,1169,3,266,133,0,1126,1128,3,720,360,0,1127,1126,1,0,0,0,
  	1128,1131,1,0,0,0,1129,1127,1,0,0,0,1129,1130,1,0,0,0,1130,1132,1,0,0,
  	0,1131,1129,1,0,0,0,1132,1169,3,360,180,0,1133,1135,3,720,360,0,1134,
  	1133,1,0,0,0,1135,1138,1,0,0,0,1136,1134,1,0,0,0,1136,1137,1,0,0,0,1137,
  	1139,1,0,0,0,1138,1136,1,0,0,0,1139,1169,3,372,186,0,1140,1142,3,720,
  	360,0,1141,1140,1,0,0,0,1142,1145,1,0,0,0,1143,1141,1,0,0,0,1143,1144,
  	1,0,0,0,1144,1146,1,0,0,0,1145,1143,1,0,0,0,1146,1169,3,374,187,0,1147,
  	1149,3,720,360,0,1148,1147,1,0,0,0,1149,1152,1,0,0,0,1150,1148,1,0,0,
  	0,1150,1151,1,0,0,0,1151,1153,1,0,0,0,1152,1150,1,0,0,0,1153,1169,3,376,
  	188,0,1154,1156,3,720,360,0,1155,1154,1,0,0,0,1156,1159,1,0,0,0,1157,
  	1155,1,0,0,0,1157,1158,1,0,0,0,1158,1160,1,0,0,0,1159,1157,1,0,0,0,1160,
  	1169,3,292,146,0,1161,1163,3,720,360,0,1162,1161,1,0,0,0,1163,1166,1,
  	0,0,0,1164,1162,1,0,0,0,1164,1165,1,0,0,0,1165,1167,1,0,0,0,1166,1164,
  	1,0,0,0,1167,1169,3,300,150,0,1168,1085,1,0,0,0,1168,1092,1,0,0,0,1168,
  	1101,1,0,0,0,1168,1108,1,0,0,0,1168,1115,1,0,0,0,1168,1122,1,0,0,0,1168,
  	1129,1,0,0,0,1168,1136,1,0,0,0,1168,1143,1,0,0,0,1168,1150,1,0,0,0,1168,
  	1157,1,0,0,0,1168,1164,1,0,0,0,1169,57,1,0,0,0,1170,1181,3,100,50,0,1171,
  	1181,3,106,53,0,1172,1181,3,98,49,0,1173,1181,3,102,51,0,1174,1181,3,
  	108,54,0,1175,1181,3,104,52,0,1176,1181,3,96,48,0,1177,1181,3,288,144,
  	0,1178,1181,3,190,95,0,1179,1181,3,180,90,0,1180,1170,1,0,0,0,1180,1171,
  	1,0,0,0,1180,1172,1,0,0,0,1180,1173,1,0,0,0,1180,1174,1,0,0,0,1180,1175,
  	1,0,0,0,1180,1176,1,0,0,0,1180,1177,1,0,0,0,1180,1178,1,0,0,0,1180,1179,
  	1,0,0,0,1181,59,1,0,0,0,1182,1183,5,17,0,0,1183,1184,3,134,67,0,1184,
  	1185,5,204,0,0,1185,61,1,0,0,0,1186,1187,5,14,0,0,1187,1188,3,730,365,
  	0,1188,1189,5,204,0,0,1189,1193,3,64,32,0,1190,1192,3,68,34,0,1191,1190,
  	1,0,0,0,1192,1195,1,0,0,0,1193,1191,1,0,0,0,1193,1194,1,0,0,0,1194,1196,
  	1,0,0,0,1195,1193,1,0,0,0,1196,1197,5,36,0,0,1197,63,1,0,0,0,1198,1202,
  	5,18,0,0,1199,1201,3,66,33,0,1200,1199,1,0,0,0,1201,1204,1,0,0,0,1202,
  	1200,1,0,0,0,1202,1203,1,0,0,0,1203,1205,1,0,0,0,1204,1202,1,0,0,0,1205,
  	1206,5,204,0,0,1206,65,1,0,0,0,1207,1208,3,754,377,0,1208,1209,5,186,
  	0,0,1209,1211,1,0,0,0,1210,1207,1,0,0,0,1210,1211,1,0,0,0,1211,1212,1,
  	0,0,0,1212,1213,3,728,364,0,1213,67,1,0,0,0,1214,1215,3,70,35,0,1215,
  	1216,3,78,39,0,1216,1217,5,204,0,0,1217,1235,1,0,0,0,1218,1219,3,72,36,
  	0,1219,1220,3,78,39,0,1220,1221,5,204,0,0,1221,1235,1,0,0,0,1222,1223,
  	3,72,36,0,1223,1224,3,80,40,0,1224,1225,5,204,0,0,1225,1235,1,0,0,0,1226,
  	1227,3,76,38,0,1227,1228,3,78,39,0,1228,1229,5,204,0,0,1229,1235,1,0,
  	0,0,1230,1231,3,76,38,0,1231,1232,3,80,40,0,1232,1233,5,204,0,0,1233,
  	1235,1,0,0,0,1234,1214,1,0,0,0,1234,1218,1,0,0,0,1234,1222,1,0,0,0,1234,
  	1226,1,0,0,0,1234,1230,1,0,0,0,1235,69,1,0,0,0,1236,1237,5,16,0,0,1237,
  	71,1,0,0,0,1238,1239,5,60,0,0,1239,1240,3,74,37,0,1240,73,1,0,0,0,1241,
  	1246,3,782,391,0,1242,1243,5,186,0,0,1243,1245,3,752,376,0,1244,1242,
  	1,0,0,0,1245,1248,1,0,0,0,1246,1244,1,0,0,0,1246,1247,1,0,0,0,1247,75,
  	1,0,0,0,1248,1246,1,0,0,0,1249,1253,5,12,0,0,1250,1251,3,754,377,0,1251,
  	1252,5,186,0,0,1252,1254,1,0,0,0,1253,1250,1,0,0,0,1253,1254,1,0,0,0,
  	1254,1255,1,0,0,0,1255,1256,3,728,364,0,1256,77,1,0,0,0,1257,1261,5,64,
  	0,0,1258,1260,3,754,377,0,1259,1258,1,0,0,0,1260,1263,1,0,0,0,1261,1259,
  	1,0,0,0,1261,1262,1,0,0,0,1262,79,1,0,0,0,1263,1261,1,0,0,0,1264,1268,
  	5,125,0,0,1265,1266,3,754,377,0,1266,1267,5,186,0,0,1267,1269,1,0,0,0,
  	1268,1265,1,0,0,0,1268,1269,1,0,0,0,1269,1270,1,0,0,0,1270,1273,3,728,
  	364,0,1271,1272,5,182,0,0,1272,1274,5,14,0,0,1273,1271,1,0,0,0,1273,1274,
  	1,0,0,0,1274,81,1,0,0,0,1275,1277,5,66,0,0,1276,1278,5,105,0,0,1277,1276,
  	1,0,0,0,1277,1278,1,0,0,0,1278,1280,1,0,0,0,1279,1281,3,178,89,0,1280,
  	1279,1,0,0,0,1280,1281,1,0,0,0,1281,1282,1,0,0,0,1282,1288,3,146,73,0,
  	1283,1284,5,66,0,0,1284,1285,3,88,44,0,1285,1286,3,146,73,0,1286,1288,
  	1,0,0,0,1287,1275,1,0,0,0,1287,1283,1,0,0,0,1288,83,1,0,0,0,1289,1291,
  	5,81,0,0,1290,1292,5,105,0,0,1291,1290,1,0,0,0,1291,1292,1,0,0,0,1292,
  	1294,1,0,0,0,1293,1295,3,178,89,0,1294,1293,1,0,0,0,1294,1295,1,0,0,0,
  	1295,1296,1,0,0,0,1296,1302,3,146,73,0,1297,1298,5,81,0,0,1298,1299,3,
  	88,44,0,1299,1300,3,146,73,0,1300,1302,1,0,0,0,1301,1289,1,0,0,0,1301,
  	1297,1,0,0,0,1302,85,1,0,0,0,1303,1305,5,108,0,0,1304,1306,3,178,89,0,
  	1305,1304,1,0,0,0,1305,1306,1,0,0,0,1306,1307,1,0,0,0,1307,1308,3,152,
  	76,0,1308,1309,5,204,0,0,1309,87,1,0,0,0,1310,1311,7,1,0,0,1311,89,1,
  	0,0,0,1312,1314,5,58,0,0,1313,1315,3,110,55,0,1314,1313,1,0,0,0,1314,
  	1315,1,0,0,0,1315,1317,1,0,0,0,1316,1318,5,105,0,0,1317,1316,1,0,0,0,
  	1317,1318,1,0,0,0,1318,1320,1,0,0,0,1319,1321,3,178,89,0,1320,1319,1,
  	0,0,0,1320,1321,1,0,0,0,1321,1322,1,0,0,0,1322,1323,3,148,74,0,1323,91,
  	1,0,0,0,1324,1326,5,59,0,0,1325,1327,3,110,55,0,1326,1325,1,0,0,0,1326,
  	1327,1,0,0,0,1327,1329,1,0,0,0,1328,1330,5,105,0,0,1329,1328,1,0,0,0,
  	1329,1330,1,0,0,0,1330,1332,1,0,0,0,1331,1333,3,178,89,0,1332,1331,1,
  	0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,1335,3,148,74,0,1335,93,
  	1,0,0,0,1336,1338,5,80,0,0,1337,1339,3,110,55,0,1338,1337,1,0,0,0,1338,
  	1339,1,0,0,0,1339,1341,1,0,0,0,1340,1342,5,105,0,0,1341,1340,1,0,0,0,
  	1341,1342,1,0,0,0,1342,1344,1,0,0,0,1343,1345,3,178,89,0,1344,1343,1,
  	0,0,0,1344,1345,1,0,0,0,1345,1346,1,0,0,0,1346,1361,3,148,74,0,1347,1348,
  	5,80,0,0,1348,1350,5,95,0,0,1349,1351,5,105,0,0,1350,1349,1,0,0,0,1350,
  	1351,1,0,0,0,1351,1353,1,0,0,0,1352,1354,3,178,89,0,1353,1352,1,0,0,0,
  	1353,1354,1,0,0,0,1354,1355,1,0,0,0,1355,1361,3,156,78,0,1356,1357,5,
  	80,0,0,1357,1358,3,114,57,0,1358,1359,3,156,78,0,1359,1361,1,0,0,0,1360,
  	1336,1,0,0,0,1360,1347,1,0,0,0,1360,1356,1,0,0,0,1361,95,1,0,0,0,1362,
  	1363,5,44,0,0,1363,1364,3,136,68,0,1364,1365,5,204,0,0,1365,97,1,0,0,
  	0,1366,1367,5,61,0,0,1367,1368,3,154,77,0,1368,1369,5,204,0,0,1369,99,
  	1,0,0,0,1370,1372,3,110,55,0,1371,1373,5,105,0,0,1372,1371,1,0,0,0,1372,
  	1373,1,0,0,0,1373,1375,1,0,0,0,1374,1376,3,128,64,0,1375,1374,1,0,0,0,
  	1375,1376,1,0,0,0,1376,1377,1,0,0,0,1377,1378,3,142,71,0,1378,1379,5,
  	204,0,0,1379,1485,1,0,0,0,1380,1382,3,110,55,0,1381,1383,3,120,60,0,1382,
  	1381,1,0,0,0,1382,1383,1,0,0,0,1383,1385,1,0,0,0,1384,1386,5,105,0,0,
  	1385,1384,1,0,0,0,1385,1386,1,0,0,0,1386,1388,1,0,0,0,1387,1389,3,128,
  	64,0,1388,1387,1,0,0,0,1388,1389,1,0,0,0,1389,1390,1,0,0,0,1390,1391,
  	3,140,70,0,1391,1392,5,204,0,0,1392,1485,1,0,0,0,1393,1395,3,110,55,0,
  	1394,1396,7,2,0,0,1395,1394,1,0,0,0,1395,1396,1,0,0,0,1396,1398,1,0,0,
  	0,1397,1399,5,105,0,0,1398,1397,1,0,0,0,1398,1399,1,0,0,0,1399,1400,1,
  	0,0,0,1400,1402,3,178,89,0,1401,1403,3,128,64,0,1402,1401,1,0,0,0,1402,
  	1403,1,0,0,0,1403,1404,1,0,0,0,1404,1405,3,142,71,0,1405,1406,5,204,0,
  	0,1406,1485,1,0,0,0,1407,1409,3,110,55,0,1408,1410,3,120,60,0,1409,1408,
  	1,0,0,0,1409,1410,1,0,0,0,1410,1412,1,0,0,0,1411,1413,7,2,0,0,1412,1411,
  	1,0,0,0,1412,1413,1,0,0,0,1413,1415,1,0,0,0,1414,1416,5,105,0,0,1415,
  	1414,1,0,0,0,1415,1416,1,0,0,0,1416,1417,1,0,0,0,1417,1419,3,178,89,0,
  	1418,1420,3,128,64,0,1419,1418,1,0,0,0,1419,1420,1,0,0,0,1420,1421,1,
  	0,0,0,1421,1422,3,140,70,0,1422,1423,5,204,0,0,1423,1485,1,0,0,0,1424,
  	1426,5,123,0,0,1425,1427,3,126,63,0,1426,1425,1,0,0,0,1426,1427,1,0,0,
  	0,1427,1429,1,0,0,0,1428,1430,5,105,0,0,1429,1428,1,0,0,0,1429,1430,1,
  	0,0,0,1430,1432,1,0,0,0,1431,1433,3,128,64,0,1432,1431,1,0,0,0,1432,1433,
  	1,0,0,0,1433,1434,1,0,0,0,1434,1435,3,142,71,0,1435,1436,5,204,0,0,1436,
  	1485,1,0,0,0,1437,1439,5,123,0,0,1438,1440,3,120,60,0,1439,1438,1,0,0,
  	0,1439,1440,1,0,0,0,1440,1442,1,0,0,0,1441,1443,5,105,0,0,1442,1441,1,
  	0,0,0,1442,1443,1,0,0,0,1443,1445,1,0,0,0,1444,1446,3,128,64,0,1445,1444,
  	1,0,0,0,1445,1446,1,0,0,0,1446,1447,1,0,0,0,1447,1448,3,140,70,0,1448,
  	1449,5,204,0,0,1449,1485,1,0,0,0,1450,1452,5,123,0,0,1451,1453,3,126,
  	63,0,1452,1451,1,0,0,0,1452,1453,1,0,0,0,1453,1455,1,0,0,0,1454,1456,
  	7,2,0,0,1455,1454,1,0,0,0,1455,1456,1,0,0,0,1456,1458,1,0,0,0,1457,1459,
  	5,105,0,0,1458,1457,1,0,0,0,1458,1459,1,0,0,0,1459,1460,1,0,0,0,1460,
  	1462,3,178,89,0,1461,1463,3,128,64,0,1462,1461,1,0,0,0,1462,1463,1,0,
  	0,0,1463,1464,1,0,0,0,1464,1465,3,142,71,0,1465,1466,5,204,0,0,1466,1485,
  	1,0,0,0,1467,1469,5,123,0,0,1468,1470,3,120,60,0,1469,1468,1,0,0,0,1469,
  	1470,1,0,0,0,1470,1472,1,0,0,0,1471,1473,7,2,0,0,1472,1471,1,0,0,0,1472,
  	1473,1,0,0,0,1473,1475,1,0,0,0,1474,1476,5,105,0,0,1475,1474,1,0,0,0,
  	1475,1476,1,0,0,0,1476,1477,1,0,0,0,1477,1479,3,178,89,0,1478,1480,3,
  	128,64,0,1479,1478,1,0,0,0,1479,1480,1,0,0,0,1480,1481,1,0,0,0,1481,1482,
  	3,140,70,0,1482,1483,5,204,0,0,1483,1485,1,0,0,0,1484,1370,1,0,0,0,1484,
  	1380,1,0,0,0,1484,1393,1,0,0,0,1484,1407,1,0,0,0,1484,1424,1,0,0,0,1484,
  	1437,1,0,0,0,1484,1450,1,0,0,0,1484,1467,1,0,0,0,1485,101,1,0,0,0,1486,
  	1487,5,93,0,0,1487,1488,3,150,75,0,1488,1489,5,204,0,0,1489,103,1,0,0,
  	0,1490,1491,5,94,0,0,1491,1492,3,150,75,0,1492,1493,5,204,0,0,1493,105,
  	1,0,0,0,1494,1496,5,95,0,0,1495,1497,5,105,0,0,1496,1495,1,0,0,0,1496,
  	1497,1,0,0,0,1497,1499,1,0,0,0,1498,1500,3,178,89,0,1499,1498,1,0,0,0,
  	1499,1500,1,0,0,0,1500,1501,1,0,0,0,1501,1502,3,154,77,0,1502,1503,5,
  	204,0,0,1503,107,1,0,0,0,1504,1505,5,115,0,0,1505,1506,3,154,77,0,1506,
  	1507,5,204,0,0,1507,109,1,0,0,0,1508,1509,7,3,0,0,1509,111,1,0,0,0,1510,
  	1511,5,138,0,0,1511,1512,3,148,74,0,1512,1513,5,204,0,0,1513,113,1,0,
  	0,0,1514,1515,7,4,0,0,1515,115,1,0,0,0,1516,1520,3,768,384,0,1517,1519,
  	3,176,88,0,1518,1517,1,0,0,0,1519,1522,1,0,0,0,1520,1518,1,0,0,0,1520,
  	1521,1,0,0,0,1521,1528,1,0,0,0,1522,1520,1,0,0,0,1523,1524,3,768,384,
  	0,1524,1525,5,188,0,0,1525,1526,3,634,317,0,1526,1528,1,0,0,0,1527,1516,
  	1,0,0,0,1527,1523,1,0,0,0,1528,117,1,0,0,0,1529,1533,3,788,394,0,1530,
  	1532,3,176,88,0,1531,1530,1,0,0,0,1532,1535,1,0,0,0,1533,1531,1,0,0,0,
  	1533,1534,1,0,0,0,1534,1541,1,0,0,0,1535,1533,1,0,0,0,1536,1537,3,788,
  	394,0,1537,1538,5,188,0,0,1538,1539,3,634,317,0,1539,1541,1,0,0,0,1540,
  	1529,1,0,0,0,1540,1536,1,0,0,0,1541,119,1,0,0,0,1542,1543,5,194,0,0,1543,
  	1544,3,122,61,0,1544,1545,5,183,0,0,1545,1546,3,124,62,0,1546,1547,5,
  	203,0,0,1547,1579,1,0,0,0,1548,1549,5,194,0,0,1549,1550,3,124,62,0,1550,
  	1551,5,183,0,0,1551,1552,3,122,61,0,1552,1553,5,203,0,0,1553,1579,1,0,
  	0,0,1554,1555,5,194,0,0,1555,1556,3,122,61,0,1556,1557,5,183,0,0,1557,
  	1558,5,52,0,0,1558,1559,5,203,0,0,1559,1579,1,0,0,0,1560,1561,5,194,0,
  	0,1561,1562,3,124,62,0,1562,1563,5,183,0,0,1563,1564,5,53,0,0,1564,1565,
  	5,203,0,0,1565,1579,1,0,0,0,1566,1567,5,194,0,0,1567,1568,5,53,0,0,1568,
  	1569,5,183,0,0,1569,1570,3,124,62,0,1570,1571,5,203,0,0,1571,1579,1,0,
  	0,0,1572,1573,5,194,0,0,1573,1574,5,52,0,0,1574,1575,5,183,0,0,1575,1576,
  	3,122,61,0,1576,1577,5,203,0,0,1577,1579,1,0,0,0,1578,1542,1,0,0,0,1578,
  	1548,1,0,0,0,1578,1554,1,0,0,0,1578,1560,1,0,0,0,1578,1566,1,0,0,0,1578,
  	1572,1,0,0,0,1579,121,1,0,0,0,1580,1581,7,5,0,0,1581,123,1,0,0,0,1582,
  	1583,7,6,0,0,1583,125,1,0,0,0,1584,1585,5,194,0,0,1585,1586,5,106,0,0,
  	1586,1594,5,203,0,0,1587,1588,5,194,0,0,1588,1589,5,68,0,0,1589,1594,
  	5,203,0,0,1590,1591,5,194,0,0,1591,1592,5,63,0,0,1592,1594,5,203,0,0,
  	1593,1584,1,0,0,0,1593,1587,1,0,0,0,1593,1590,1,0,0,0,1594,127,1,0,0,
  	0,1595,1596,5,191,0,0,1596,1611,3,132,66,0,1597,1598,5,191,0,0,1598,1599,
  	5,194,0,0,1599,1606,3,646,323,0,1600,1601,5,183,0,0,1601,1604,3,646,323,
  	0,1602,1603,5,183,0,0,1603,1605,3,646,323,0,1604,1602,1,0,0,0,1604,1605,
  	1,0,0,0,1605,1607,1,0,0,0,1606,1600,1,0,0,0,1606,1607,1,0,0,0,1607,1608,
  	1,0,0,0,1608,1609,5,203,0,0,1609,1611,1,0,0,0,1610,1595,1,0,0,0,1610,
  	1597,1,0,0,0,1611,129,1,0,0,0,1612,1613,5,191,0,0,1613,1624,3,132,66,
  	0,1614,1615,5,191,0,0,1615,1616,5,194,0,0,1616,1619,3,646,323,0,1617,
  	1618,5,183,0,0,1618,1620,3,646,323,0,1619,1617,1,0,0,0,1619,1620,1,0,
  	0,0,1620,1621,1,0,0,0,1621,1622,5,203,0,0,1622,1624,1,0,0,0,1623,1612,
  	1,0,0,0,1623,1614,1,0,0,0,1624,131,1,0,0,0,1625,1629,3,700,350,0,1626,
  	1629,3,682,341,0,1627,1629,3,748,374,0,1628,1625,1,0,0,0,1628,1626,1,
  	0,0,0,1628,1627,1,0,0,0,1629,133,1,0,0,0,1630,1635,3,160,80,0,1631,1632,
  	5,183,0,0,1632,1634,3,160,80,0,1633,1631,1,0,0,0,1634,1637,1,0,0,0,1635,
  	1633,1,0,0,0,1635,1636,1,0,0,0,1636,135,1,0,0,0,1637,1635,1,0,0,0,1638,
  	1643,3,138,69,0,1639,1640,5,183,0,0,1640,1642,3,138,69,0,1641,1639,1,
  	0,0,0,1642,1645,1,0,0,0,1643,1641,1,0,0,0,1643,1644,1,0,0,0,1644,137,
  	1,0,0,0,1645,1643,1,0,0,0,1646,1650,3,734,367,0,1647,1649,3,176,88,0,
  	1648,1647,1,0,0,0,1649,1652,1,0,0,0,1650,1648,1,0,0,0,1650,1651,1,0,0,
  	0,1651,139,1,0,0,0,1652,1650,1,0,0,0,1653,1658,3,162,81,0,1654,1655,5,
  	183,0,0,1655,1657,3,162,81,0,1656,1654,1,0,0,0,1657,1660,1,0,0,0,1658,
  	1656,1,0,0,0,1658,1659,1,0,0,0,1659,141,1,0,0,0,1660,1658,1,0,0,0,1661,
  	1666,3,144,72,0,1662,1663,5,183,0,0,1663,1665,3,144,72,0,1664,1662,1,
  	0,0,0,1665,1668,1,0,0,0,1666,1664,1,0,0,0,1666,1667,1,0,0,0,1667,143,
  	1,0,0,0,1668,1666,1,0,0,0,1669,1673,3,760,380,0,1670,1672,3,176,88,0,
  	1671,1670,1,0,0,0,1672,1675,1,0,0,0,1673,1671,1,0,0,0,1673,1674,1,0,0,
  	0,1674,145,1,0,0,0,1675,1673,1,0,0,0,1676,1681,3,164,82,0,1677,1678,5,
  	183,0,0,1678,1680,3,164,82,0,1679,1677,1,0,0,0,1680,1683,1,0,0,0,1681,
  	1679,1,0,0,0,1681,1682,1,0,0,0,1682,147,1,0,0,0,1683,1681,1,0,0,0,1684,
  	1689,3,766,383,0,1685,1686,5,183,0,0,1686,1688,3,766,383,0,1687,1685,
  	1,0,0,0,1688,1691,1,0,0,0,1689,1687,1,0,0,0,1689,1690,1,0,0,0,1690,149,
  	1,0,0,0,1691,1689,1,0,0,0,1692,1697,3,116,58,0,1693,1694,5,183,0,0,1694,
  	1696,3,116,58,0,1695,1693,1,0,0,0,1696,1699,1,0,0,0,1697,1695,1,0,0,0,
  	1697,1698,1,0,0,0,1698,151,1,0,0,0,1699,1697,1,0,0,0,1700,1705,3,166,
  	83,0,1701,1702,5,183,0,0,1702,1704,3,166,83,0,1703,1701,1,0,0,0,1704,
  	1707,1,0,0,0,1705,1703,1,0,0,0,1705,1706,1,0,0,0,1706,153,1,0,0,0,1707,
  	1705,1,0,0,0,1708,1713,3,118,59,0,1709,1710,5,183,0,0,1710,1712,3,118,
  	59,0,1711,1709,1,0,0,0,1712,1715,1,0,0,0,1713,1711,1,0,0,0,1713,1714,
  	1,0,0,0,1714,155,1,0,0,0,1715,1713,1,0,0,0,1716,1721,3,158,79,0,1717,
  	1718,5,183,0,0,1718,1720,3,158,79,0,1719,1717,1,0,0,0,1720,1723,1,0,0,
  	0,1721,1719,1,0,0,0,1721,1722,1,0,0,0,1722,157,1,0,0,0,1723,1721,1,0,
  	0,0,1724,1727,3,766,383,0,1725,1726,5,188,0,0,1726,1728,3,634,317,0,1727,
  	1725,1,0,0,0,1727,1728,1,0,0,0,1728,159,1,0,0,0,1729,1730,3,744,372,0,
  	1730,1731,5,188,0,0,1731,1732,3,636,318,0,1732,161,1,0,0,0,1733,1734,
  	3,760,380,0,1734,1735,5,188,0,0,1735,1736,3,642,321,0,1736,163,1,0,0,
  	0,1737,1738,3,764,382,0,1738,1739,5,188,0,0,1739,1740,3,636,318,0,1740,
  	165,1,0,0,0,1741,1742,3,772,386,0,1742,1743,5,188,0,0,1743,1744,3,636,
  	318,0,1744,1747,1,0,0,0,1745,1747,3,168,84,0,1746,1741,1,0,0,0,1746,1745,
  	1,0,0,0,1747,167,1,0,0,0,1748,1749,5,82,0,0,1749,1750,5,188,0,0,1750,
  	1751,5,194,0,0,1751,1754,3,172,86,0,1752,1753,5,183,0,0,1753,1755,3,170,
  	85,0,1754,1752,1,0,0,0,1754,1755,1,0,0,0,1755,1756,1,0,0,0,1756,1757,
  	5,203,0,0,1757,1772,1,0,0,0,1758,1759,5,82,0,0,1759,1760,3,456,228,0,
  	1760,1761,5,184,0,0,1761,1762,3,458,229,0,1762,1763,5,188,0,0,1763,1764,
  	5,194,0,0,1764,1767,3,172,86,0,1765,1766,5,183,0,0,1766,1768,3,170,85,
  	0,1767,1765,1,0,0,0,1767,1768,1,0,0,0,1768,1769,1,0,0,0,1769,1770,5,203,
  	0,0,1770,1772,1,0,0,0,1771,1748,1,0,0,0,1771,1758,1,0,0,0,1772,169,1,
  	0,0,0,1773,1774,3,174,87,0,1774,171,1,0,0,0,1775,1776,3,174,87,0,1776,
  	173,1,0,0,0,1777,1778,3,636,318,0,1778,175,1,0,0,0,1779,1780,5,192,0,
  	0,1780,1781,3,640,320,0,1781,1782,5,182,0,0,1782,1783,3,640,320,0,1783,
  	1784,5,201,0,0,1784,177,1,0,0,0,1785,1786,5,192,0,0,1786,1787,3,652,326,
  	0,1787,1788,5,182,0,0,1788,1789,3,644,322,0,1789,1790,5,201,0,0,1790,
  	179,1,0,0,0,1791,1793,5,49,0,0,1792,1794,5,4,0,0,1793,1792,1,0,0,0,1793,
  	1794,1,0,0,0,1794,1796,1,0,0,0,1795,1797,3,188,94,0,1796,1795,1,0,0,0,
  	1796,1797,1,0,0,0,1797,1798,1,0,0,0,1798,1799,3,736,368,0,1799,1801,5,
  	204,0,0,1800,1802,3,182,91,0,1801,1800,1,0,0,0,1802,1803,1,0,0,0,1803,
  	1801,1,0,0,0,1803,1804,1,0,0,0,1804,1805,1,0,0,0,1805,1806,3,398,199,
  	0,1806,1807,5,37,0,0,1807,1830,1,0,0,0,1808,1810,5,49,0,0,1809,1811,5,
  	4,0,0,1810,1809,1,0,0,0,1810,1811,1,0,0,0,1811,1813,1,0,0,0,1812,1814,
  	3,188,94,0,1813,1812,1,0,0,0,1813,1814,1,0,0,0,1814,1815,1,0,0,0,1815,
  	1816,3,736,368,0,1816,1817,5,194,0,0,1817,1818,3,184,92,0,1818,1819,5,
  	203,0,0,1819,1823,5,204,0,0,1820,1822,3,206,103,0,1821,1820,1,0,0,0,1822,
  	1825,1,0,0,0,1823,1821,1,0,0,0,1823,1824,1,0,0,0,1824,1826,1,0,0,0,1825,
  	1823,1,0,0,0,1826,1827,3,398,199,0,1827,1828,5,37,0,0,1828,1830,1,0,0,
  	0,1829,1791,1,0,0,0,1829,1808,1,0,0,0,1830,181,1,0,0,0,1831,1842,3,206,
  	103,0,1832,1834,3,720,360,0,1833,1832,1,0,0,0,1834,1837,1,0,0,0,1835,
  	1833,1,0,0,0,1835,1836,1,0,0,0,1836,1838,1,0,0,0,1837,1835,1,0,0,0,1838,
  	1839,3,198,99,0,1839,1840,5,204,0,0,1840,1842,1,0,0,0,1841,1831,1,0,0,
  	0,1841,1835,1,0,0,0,1842,183,1,0,0,0,1843,1848,3,186,93,0,1844,1845,5,
  	183,0,0,1845,1847,3,186,93,0,1846,1844,1,0,0,0,1847,1850,1,0,0,0,1848,
  	1846,1,0,0,0,1848,1849,1,0,0,0,1849,185,1,0,0,0,1850,1848,1,0,0,0,1851,
  	1853,3,720,360,0,1852,1851,1,0,0,0,1853,1856,1,0,0,0,1854,1852,1,0,0,
  	0,1854,1855,1,0,0,0,1855,1857,1,0,0,0,1856,1854,1,0,0,0,1857,1858,3,198,
  	99,0,1858,187,1,0,0,0,1859,1869,3,178,89,0,1860,1862,5,105,0,0,1861,1863,
  	3,178,89,0,1862,1861,1,0,0,0,1862,1863,1,0,0,0,1863,1869,1,0,0,0,1864,
  	1869,5,61,0,0,1865,1869,5,93,0,0,1866,1869,5,94,0,0,1867,1869,5,115,0,
  	0,1868,1859,1,0,0,0,1868,1860,1,0,0,0,1868,1864,1,0,0,0,1868,1865,1,0,
  	0,0,1868,1866,1,0,0,0,1868,1867,1,0,0,0,1869,189,1,0,0,0,1870,1872,5,
  	114,0,0,1871,1873,5,4,0,0,1872,1871,1,0,0,0,1872,1873,1,0,0,0,1873,1874,
  	1,0,0,0,1874,1875,3,778,389,0,1875,1879,5,204,0,0,1876,1878,3,192,96,
  	0,1877,1876,1,0,0,0,1878,1881,1,0,0,0,1879,1877,1,0,0,0,1879,1880,1,0,
  	0,0,1880,1882,1,0,0,0,1881,1879,1,0,0,0,1882,1883,3,396,198,0,1883,1884,
  	5,43,0,0,1884,1906,1,0,0,0,1885,1887,5,114,0,0,1886,1888,5,4,0,0,1887,
  	1886,1,0,0,0,1887,1888,1,0,0,0,1888,1889,1,0,0,0,1889,1890,3,778,389,
  	0,1890,1892,5,194,0,0,1891,1893,3,194,97,0,1892,1891,1,0,0,0,1892,1893,
  	1,0,0,0,1893,1894,1,0,0,0,1894,1895,5,203,0,0,1895,1899,5,204,0,0,1896,
  	1898,3,206,103,0,1897,1896,1,0,0,0,1898,1901,1,0,0,0,1899,1897,1,0,0,
  	0,1899,1900,1,0,0,0,1900,1902,1,0,0,0,1901,1899,1,0,0,0,1902,1903,3,396,
  	198,0,1903,1904,5,43,0,0,1904,1906,1,0,0,0,1905,1870,1,0,0,0,1905,1885,
  	1,0,0,0,1906,191,1,0,0,0,1907,1936,3,206,103,0,1908,1910,3,720,360,0,
  	1909,1908,1,0,0,0,1910,1913,1,0,0,0,1911,1909,1,0,0,0,1911,1912,1,0,0,
  	0,1912,1914,1,0,0,0,1913,1911,1,0,0,0,1914,1915,3,198,99,0,1915,1916,
  	5,204,0,0,1916,1936,1,0,0,0,1917,1919,3,720,360,0,1918,1917,1,0,0,0,1919,
  	1922,1,0,0,0,1920,1918,1,0,0,0,1920,1921,1,0,0,0,1921,1923,1,0,0,0,1922,
  	1920,1,0,0,0,1923,1924,3,200,100,0,1924,1925,5,204,0,0,1925,1936,1,0,
  	0,0,1926,1928,3,720,360,0,1927,1926,1,0,0,0,1928,1931,1,0,0,0,1929,1927,
  	1,0,0,0,1929,1930,1,0,0,0,1930,1932,1,0,0,0,1931,1929,1,0,0,0,1932,1933,
  	3,202,101,0,1933,1934,5,204,0,0,1934,1936,1,0,0,0,1935,1907,1,0,0,0,1935,
  	1911,1,0,0,0,1935,1920,1,0,0,0,1935,1929,1,0,0,0,1936,193,1,0,0,0,1937,
  	1942,3,196,98,0,1938,1939,5,183,0,0,1939,1941,3,196,98,0,1940,1938,1,
  	0,0,0,1941,1944,1,0,0,0,1942,1940,1,0,0,0,1942,1943,1,0,0,0,1943,195,
  	1,0,0,0,1944,1942,1,0,0,0,1945,1947,3,720,360,0,1946,1945,1,0,0,0,1947,
  	1950,1,0,0,0,1948,1946,1,0,0,0,1948,1949,1,0,0,0,1949,1951,1,0,0,0,1950,
  	1948,1,0,0,0,1951,1967,3,198,99,0,1952,1954,3,720,360,0,1953,1952,1,0,
  	0,0,1954,1957,1,0,0,0,1955,1953,1,0,0,0,1955,1956,1,0,0,0,1956,1958,1,
  	0,0,0,1957,1955,1,0,0,0,1958,1967,3,200,100,0,1959,1961,3,720,360,0,1960,
  	1959,1,0,0,0,1961,1964,1,0,0,0,1962,1960,1,0,0,0,1962,1963,1,0,0,0,1963,
  	1965,1,0,0,0,1964,1962,1,0,0,0,1965,1967,3,202,101,0,1966,1948,1,0,0,
  	0,1966,1955,1,0,0,0,1966,1962,1,0,0,0,1967,197,1,0,0,0,1968,1970,5,59,
  	0,0,1969,1971,5,95,0,0,1970,1969,1,0,0,0,1970,1971,1,0,0,0,1971,1973,
  	1,0,0,0,1972,1974,5,105,0,0,1973,1972,1,0,0,0,1973,1974,1,0,0,0,1974,
  	1976,1,0,0,0,1975,1977,3,178,89,0,1976,1975,1,0,0,0,1976,1977,1,0,0,0,
  	1977,1978,1,0,0,0,1978,1984,3,148,74,0,1979,1980,5,59,0,0,1980,1981,3,
  	204,102,0,1981,1982,3,148,74,0,1982,1984,1,0,0,0,1983,1968,1,0,0,0,1983,
  	1979,1,0,0,0,1984,199,1,0,0,0,1985,1987,5,80,0,0,1986,1988,5,95,0,0,1987,
  	1986,1,0,0,0,1987,1988,1,0,0,0,1988,1990,1,0,0,0,1989,1991,5,105,0,0,
  	1990,1989,1,0,0,0,1990,1991,1,0,0,0,1991,1993,1,0,0,0,1992,1994,3,178,
  	89,0,1993,1992,1,0,0,0,1993,1994,1,0,0,0,1994,1995,1,0,0,0,1995,2001,
  	3,148,74,0,1996,1997,5,80,0,0,1997,1998,3,204,102,0,1998,1999,3,148,74,
  	0,1999,2001,1,0,0,0,2000,1985,1,0,0,0,2000,1996,1,0,0,0,2001,201,1,0,
  	0,0,2002,2004,5,58,0,0,2003,2005,5,95,0,0,2004,2003,1,0,0,0,2004,2005,
  	1,0,0,0,2005,2007,1,0,0,0,2006,2008,5,105,0,0,2007,2006,1,0,0,0,2007,
  	2008,1,0,0,0,2008,2010,1,0,0,0,2009,2011,3,178,89,0,2010,2009,1,0,0,0,
  	2010,2011,1,0,0,0,2011,2012,1,0,0,0,2012,2018,3,148,74,0,2013,2014,5,
  	58,0,0,2014,2015,3,204,102,0,2015,2016,3,148,74,0,2016,2018,1,0,0,0,2017,
  	2002,1,0,0,0,2017,2013,1,0,0,0,2018,203,1,0,0,0,2019,2020,7,1,0,0,2020,
  	205,1,0,0,0,2021,2023,3,720,360,0,2022,2021,1,0,0,0,2023,2026,1,0,0,0,
  	2024,2022,1,0,0,0,2024,2025,1,0,0,0,2025,2027,1,0,0,0,2026,2024,1,0,0,
  	0,2027,2029,5,95,0,0,2028,2030,5,105,0,0,2029,2028,1,0,0,0,2029,2030,
  	1,0,0,0,2030,2032,1,0,0,0,2031,2033,3,178,89,0,2032,2031,1,0,0,0,2032,
  	2033,1,0,0,0,2033,2034,1,0,0,0,2034,2035,3,208,104,0,2035,2036,5,204,
  	0,0,2036,2103,1,0,0,0,2037,2039,3,720,360,0,2038,2037,1,0,0,0,2039,2042,
  	1,0,0,0,2040,2038,1,0,0,0,2040,2041,1,0,0,0,2041,2043,1,0,0,0,2042,2040,
  	1,0,0,0,2043,2044,5,61,0,0,2044,2045,3,208,104,0,2045,2046,5,204,0,0,
  	2046,2103,1,0,0,0,2047,2049,3,720,360,0,2048,2047,1,0,0,0,2049,2052,1,
  	0,0,0,2050,2048,1,0,0,0,2050,2051,1,0,0,0,2051,2053,1,0,0,0,2052,2050,
  	1,0,0,0,2053,2054,5,115,0,0,2054,2055,3,208,104,0,2055,2056,5,204,0,0,
  	2056,2103,1,0,0,0,2057,2059,3,720,360,0,2058,2057,1,0,0,0,2059,2062,1,
  	0,0,0,2060,2058,1,0,0,0,2060,2061,1,0,0,0,2061,2063,1,0,0,0,2062,2060,
  	1,0,0,0,2063,2064,5,93,0,0,2064,2065,3,210,105,0,2065,2066,5,204,0,0,
  	2066,2103,1,0,0,0,2067,2069,3,720,360,0,2068,2067,1,0,0,0,2069,2072,1,
  	0,0,0,2070,2068,1,0,0,0,2070,2071,1,0,0,0,2071,2073,1,0,0,0,2072,2070,
  	1,0,0,0,2073,2074,5,94,0,0,2074,2075,3,210,105,0,2075,2076,5,204,0,0,
  	2076,2103,1,0,0,0,2077,2079,3,720,360,0,2078,2077,1,0,0,0,2079,2082,1,
  	0,0,0,2080,2078,1,0,0,0,2080,2081,1,0,0,0,2081,2083,1,0,0,0,2082,2080,
  	1,0,0,0,2083,2103,3,96,48,0,2084,2086,3,720,360,0,2085,2084,1,0,0,0,2086,
  	2089,1,0,0,0,2087,2085,1,0,0,0,2087,2088,1,0,0,0,2088,2090,1,0,0,0,2089,
  	2087,1,0,0,0,2090,2091,3,82,41,0,2091,2092,5,204,0,0,2092,2103,1,0,0,
  	0,2093,2095,3,720,360,0,2094,2093,1,0,0,0,2095,2098,1,0,0,0,2096,2094,
  	1,0,0,0,2096,2097,1,0,0,0,2097,2099,1,0,0,0,2098,2096,1,0,0,0,2099,2100,
  	3,84,42,0,2100,2101,5,204,0,0,2101,2103,1,0,0,0,2102,2024,1,0,0,0,2102,
  	2040,1,0,0,0,2102,2050,1,0,0,0,2102,2060,1,0,0,0,2102,2070,1,0,0,0,2102,
  	2080,1,0,0,0,2102,2087,1,0,0,0,2102,2096,1,0,0,0,2103,207,1,0,0,0,2104,
  	2109,3,212,106,0,2105,2106,5,183,0,0,2106,2108,3,212,106,0,2107,2105,
  	1,0,0,0,2108,2111,1,0,0,0,2109,2107,1,0,0,0,2109,2110,1,0,0,0,2110,209,
  	1,0,0,0,2111,2109,1,0,0,0,2112,2117,3,214,107,0,2113,2114,5,183,0,0,2114,
  	2116,3,214,107,0,2115,2113,1,0,0,0,2116,2119,1,0,0,0,2117,2115,1,0,0,
  	0,2117,2118,1,0,0,0,2118,211,1,0,0,0,2119,2117,1,0,0,0,2120,2124,3,788,
  	394,0,2121,2123,3,176,88,0,2122,2121,1,0,0,0,2123,2126,1,0,0,0,2124,2122,
  	1,0,0,0,2124,2125,1,0,0,0,2125,213,1,0,0,0,2126,2124,1,0,0,0,2127,2131,
  	3,768,384,0,2128,2130,3,176,88,0,2129,2128,1,0,0,0,2130,2133,1,0,0,0,
  	2131,2129,1,0,0,0,2131,2132,1,0,0,0,2132,215,1,0,0,0,2133,2131,1,0,0,
  	0,2134,2136,3,252,126,0,2135,2137,3,128,64,0,2136,2135,1,0,0,0,2136,2137,
  	1,0,0,0,2137,2138,1,0,0,0,2138,2143,3,218,109,0,2139,2140,5,183,0,0,2140,
  	2142,3,218,109,0,2141,2139,1,0,0,0,2142,2145,1,0,0,0,2143,2141,1,0,0,
  	0,2143,2144,1,0,0,0,2144,2146,1,0,0,0,2145,2143,1,0,0,0,2146,2147,5,204,
  	0,0,2147,2267,1,0,0,0,2148,2150,3,254,127,0,2149,2151,3,120,60,0,2150,
  	2149,1,0,0,0,2150,2151,1,0,0,0,2151,2153,1,0,0,0,2152,2154,3,128,64,0,
  	2153,2152,1,0,0,0,2153,2154,1,0,0,0,2154,2155,1,0,0,0,2155,2160,3,220,
  	110,0,2156,2157,5,183,0,0,2157,2159,3,220,110,0,2158,2156,1,0,0,0,2159,
  	2162,1,0,0,0,2160,2158,1,0,0,0,2160,2161,1,0,0,0,2161,2163,1,0,0,0,2162,
  	2160,1,0,0,0,2163,2164,5,204,0,0,2164,2267,1,0,0,0,2165,2167,3,256,128,
  	0,2166,2168,3,128,64,0,2167,2166,1,0,0,0,2167,2168,1,0,0,0,2168,2169,
  	1,0,0,0,2169,2174,3,222,111,0,2170,2171,5,183,0,0,2171,2173,3,222,111,
  	0,2172,2170,1,0,0,0,2173,2176,1,0,0,0,2174,2172,1,0,0,0,2174,2175,1,0,
  	0,0,2175,2177,1,0,0,0,2176,2174,1,0,0,0,2177,2178,5,204,0,0,2178,2267,
  	1,0,0,0,2179,2181,3,258,129,0,2180,2182,3,120,60,0,2181,2180,1,0,0,0,
  	2181,2182,1,0,0,0,2182,2184,1,0,0,0,2183,2185,3,130,65,0,2184,2183,1,
  	0,0,0,2184,2185,1,0,0,0,2185,2186,1,0,0,0,2186,2191,3,224,112,0,2187,
  	2188,5,183,0,0,2188,2190,3,224,112,0,2189,2187,1,0,0,0,2190,2193,1,0,
  	0,0,2191,2189,1,0,0,0,2191,2192,1,0,0,0,2192,2194,1,0,0,0,2193,2191,1,
  	0,0,0,2194,2195,5,204,0,0,2195,2267,1,0,0,0,2196,2198,3,260,130,0,2197,
  	2199,3,120,60,0,2198,2197,1,0,0,0,2198,2199,1,0,0,0,2199,2201,1,0,0,0,
  	2200,2202,3,130,65,0,2201,2200,1,0,0,0,2201,2202,1,0,0,0,2202,2203,1,
  	0,0,0,2203,2208,3,226,113,0,2204,2205,5,183,0,0,2205,2207,3,226,113,0,
  	2206,2204,1,0,0,0,2207,2210,1,0,0,0,2208,2206,1,0,0,0,2208,2209,1,0,0,
  	0,2209,2211,1,0,0,0,2210,2208,1,0,0,0,2211,2212,5,204,0,0,2212,2267,1,
  	0,0,0,2213,2215,3,262,131,0,2214,2216,3,130,65,0,2215,2214,1,0,0,0,2215,
  	2216,1,0,0,0,2216,2217,1,0,0,0,2217,2222,3,230,115,0,2218,2219,5,183,
  	0,0,2219,2221,3,230,115,0,2220,2218,1,0,0,0,2221,2224,1,0,0,0,2222,2220,
  	1,0,0,0,2222,2223,1,0,0,0,2223,2225,1,0,0,0,2224,2222,1,0,0,0,2225,2226,
  	5,204,0,0,2226,2267,1,0,0,0,2227,2228,3,264,132,0,2228,2233,3,228,114,
  	0,2229,2230,5,183,0,0,2230,2232,3,228,114,0,2231,2229,1,0,0,0,2232,2235,
  	1,0,0,0,2233,2231,1,0,0,0,2233,2234,1,0,0,0,2234,2236,1,0,0,0,2235,2233,
  	1,0,0,0,2236,2237,5,204,0,0,2237,2267,1,0,0,0,2238,2240,5,86,0,0,2239,
  	2241,3,236,118,0,2240,2239,1,0,0,0,2240,2241,1,0,0,0,2241,2242,1,0,0,
  	0,2242,2247,3,232,116,0,2243,2244,5,183,0,0,2244,2246,3,232,116,0,2245,
  	2243,1,0,0,0,2246,2249,1,0,0,0,2247,2245,1,0,0,0,2247,2248,1,0,0,0,2248,
  	2250,1,0,0,0,2249,2247,1,0,0,0,2250,2251,5,204,0,0,2251,2267,1,0,0,0,
  	2252,2254,5,88,0,0,2253,2255,3,238,119,0,2254,2253,1,0,0,0,2254,2255,
  	1,0,0,0,2255,2256,1,0,0,0,2256,2261,3,232,116,0,2257,2258,5,183,0,0,2258,
  	2260,3,232,116,0,2259,2257,1,0,0,0,2260,2263,1,0,0,0,2261,2259,1,0,0,
  	0,2261,2262,1,0,0,0,2262,2264,1,0,0,0,2263,2261,1,0,0,0,2264,2265,5,204,
  	0,0,2265,2267,1,0,0,0,2266,2134,1,0,0,0,2266,2148,1,0,0,0,2266,2165,1,
  	0,0,0,2266,2179,1,0,0,0,2266,2196,1,0,0,0,2266,2213,1,0,0,0,2266,2227,
  	1,0,0,0,2266,2238,1,0,0,0,2266,2252,1,0,0,0,2267,217,1,0,0,0,2268,2270,
  	3,234,117,0,2269,2268,1,0,0,0,2269,2270,1,0,0,0,2270,2271,1,0,0,0,2271,
  	2272,5,194,0,0,2272,2273,3,248,124,0,2273,2274,5,183,0,0,2274,2275,3,
  	244,122,0,2275,2276,5,183,0,0,2276,2277,3,246,123,0,2277,2278,5,183,0,
  	0,2278,2279,3,250,125,0,2279,2280,5,203,0,0,2280,219,1,0,0,0,2281,2283,
  	3,234,117,0,2282,2281,1,0,0,0,2282,2283,1,0,0,0,2283,2284,1,0,0,0,2284,
  	2285,5,194,0,0,2285,2286,3,248,124,0,2286,2287,5,183,0,0,2287,2288,3,
  	244,122,0,2288,2289,5,183,0,0,2289,2290,3,240,120,0,2290,2291,5,203,0,
  	0,2291,221,1,0,0,0,2292,2294,3,234,117,0,2293,2292,1,0,0,0,2293,2294,
  	1,0,0,0,2294,2295,1,0,0,0,2295,2296,5,194,0,0,2296,2297,3,248,124,0,2297,
  	2298,5,183,0,0,2298,2299,3,244,122,0,2299,2300,5,183,0,0,2300,2301,3,
  	240,120,0,2301,2302,5,203,0,0,2302,223,1,0,0,0,2303,2305,3,234,117,0,
  	2304,2303,1,0,0,0,2304,2305,1,0,0,0,2305,2306,1,0,0,0,2306,2307,5,194,
  	0,0,2307,2308,3,248,124,0,2308,2309,5,183,0,0,2309,2314,3,244,122,0,2310,
  	2311,5,183,0,0,2311,2313,3,244,122,0,2312,2310,1,0,0,0,2313,2316,1,0,
  	0,0,2314,2312,1,0,0,0,2314,2315,1,0,0,0,2315,2317,1,0,0,0,2316,2314,1,
  	0,0,0,2317,2318,5,203,0,0,2318,225,1,0,0,0,2319,2321,3,234,117,0,2320,
  	2319,1,0,0,0,2320,2321,1,0,0,0,2321,2322,1,0,0,0,2322,2323,5,194,0,0,
  	2323,2328,3,248,124,0,2324,2325,5,183,0,0,2325,2327,3,248,124,0,2326,
  	2324,1,0,0,0,2327,2330,1,0,0,0,2328,2326,1,0,0,0,2328,2329,1,0,0,0,2329,
  	2331,1,0,0,0,2330,2328,1,0,0,0,2331,2332,5,183,0,0,2332,2333,3,244,122,
  	0,2333,2334,5,203,0,0,2334,227,1,0,0,0,2335,2337,3,234,117,0,2336,2335,
  	1,0,0,0,2336,2337,1,0,0,0,2337,2338,1,0,0,0,2338,2339,5,194,0,0,2339,
  	2340,3,242,121,0,2340,2341,5,183,0,0,2341,2342,3,242,121,0,2342,2343,
  	5,203,0,0,2343,229,1,0,0,0,2344,2346,3,234,117,0,2345,2344,1,0,0,0,2345,
  	2346,1,0,0,0,2346,2347,1,0,0,0,2347,2348,5,194,0,0,2348,2349,3,242,121,
  	0,2349,2350,5,183,0,0,2350,2351,3,242,121,0,2351,2352,5,183,0,0,2352,
  	2353,3,240,120,0,2353,2354,5,203,0,0,2354,231,1,0,0,0,2355,2357,3,234,
  	117,0,2356,2355,1,0,0,0,2356,2357,1,0,0,0,2357,2358,1,0,0,0,2358,2359,
  	5,194,0,0,2359,2360,3,248,124,0,2360,2361,5,203,0,0,2361,233,1,0,0,0,
  	2362,2364,3,738,369,0,2363,2365,3,178,89,0,2364,2363,1,0,0,0,2364,2365,
  	1,0,0,0,2365,235,1,0,0,0,2366,2367,5,194,0,0,2367,2368,3,122,61,0,2368,
  	2369,5,183,0,0,2369,2370,3,124,62,0,2370,2371,5,203,0,0,2371,2383,1,0,
  	0,0,2372,2373,5,194,0,0,2373,2374,3,124,62,0,2374,2375,5,183,0,0,2375,
  	2376,3,122,61,0,2376,2377,5,203,0,0,2377,2383,1,0,0,0,2378,2379,5,194,
  	0,0,2379,2380,3,122,61,0,2380,2381,5,203,0,0,2381,2383,1,0,0,0,2382,2366,
  	1,0,0,0,2382,2372,1,0,0,0,2382,2378,1,0,0,0,2383,237,1,0,0,0,2384,2385,
  	5,194,0,0,2385,2386,3,122,61,0,2386,2387,5,183,0,0,2387,2388,3,124,62,
  	0,2388,2389,5,203,0,0,2389,2401,1,0,0,0,2390,2391,5,194,0,0,2391,2392,
  	3,124,62,0,2392,2393,5,183,0,0,2393,2394,3,122,61,0,2394,2395,5,203,0,
  	0,2395,2401,1,0,0,0,2396,2397,5,194,0,0,2397,2398,3,124,62,0,2398,2399,
  	5,203,0,0,2399,2401,1,0,0,0,2400,2384,1,0,0,0,2400,2390,1,0,0,0,2400,
  	2396,1,0,0,0,2401,239,1,0,0,0,2402,2403,3,642,321,0,2403,241,1,0,0,0,
  	2404,2405,3,668,334,0,2405,243,1,0,0,0,2406,2407,3,642,321,0,2407,245,
  	1,0,0,0,2408,2409,3,642,321,0,2409,247,1,0,0,0,2410,2411,3,668,334,0,
  	2411,249,1,0,0,0,2412,2413,3,642,321,0,2413,251,1,0,0,0,2414,2415,7,7,
  	0,0,2415,253,1,0,0,0,2416,2417,7,8,0,0,2417,255,1,0,0,0,2418,2419,7,9,
  	0,0,2419,257,1,0,0,0,2420,2421,7,10,0,0,2421,259,1,0,0,0,2422,2423,7,
  	11,0,0,2423,261,1,0,0,0,2424,2425,7,12,0,0,2425,263,1,0,0,0,2426,2427,
  	7,13,0,0,2427,265,1,0,0,0,2428,2430,3,756,378,0,2429,2431,3,268,134,0,
  	2430,2429,1,0,0,0,2430,2431,1,0,0,0,2431,2432,1,0,0,0,2432,2437,3,276,
  	138,0,2433,2434,5,183,0,0,2434,2436,3,276,138,0,2435,2433,1,0,0,0,2436,
  	2439,1,0,0,0,2437,2435,1,0,0,0,2437,2438,1,0,0,0,2438,2440,1,0,0,0,2439,
  	2437,1,0,0,0,2440,2441,5,204,0,0,2441,267,1,0,0,0,2442,2443,5,191,0,0,
  	2443,2444,5,194,0,0,2444,2445,3,270,135,0,2445,2446,5,203,0,0,2446,269,
  	1,0,0,0,2447,2452,3,272,136,0,2448,2449,5,183,0,0,2449,2451,3,272,136,
  	0,2450,2448,1,0,0,0,2451,2454,1,0,0,0,2452,2450,1,0,0,0,2452,2453,1,0,
  	0,0,2453,2464,1,0,0,0,2454,2452,1,0,0,0,2455,2460,3,274,137,0,2456,2457,
  	5,183,0,0,2457,2459,3,274,137,0,2458,2456,1,0,0,0,2459,2462,1,0,0,0,2460,
  	2458,1,0,0,0,2460,2461,1,0,0,0,2461,2464,1,0,0,0,2462,2460,1,0,0,0,2463,
  	2447,1,0,0,0,2463,2455,1,0,0,0,2464,271,1,0,0,0,2465,2466,3,642,321,0,
  	2466,273,1,0,0,0,2467,2468,5,186,0,0,2468,2469,3,764,382,0,2469,2471,
  	5,194,0,0,2470,2472,3,646,323,0,2471,2470,1,0,0,0,2471,2472,1,0,0,0,2472,
  	2473,1,0,0,0,2473,2474,5,203,0,0,2474,275,1,0,0,0,2475,2476,3,278,139,
  	0,2476,2477,5,194,0,0,2477,2478,3,280,140,0,2478,2479,5,203,0,0,2479,
  	277,1,0,0,0,2480,2482,3,758,379,0,2481,2483,3,178,89,0,2482,2481,1,0,
  	0,0,2482,2483,1,0,0,0,2483,279,1,0,0,0,2484,2489,3,282,141,0,2485,2486,
  	5,183,0,0,2486,2488,3,282,141,0,2487,2485,1,0,0,0,2488,2491,1,0,0,0,2489,
  	2487,1,0,0,0,2489,2490,1,0,0,0,2490,2501,1,0,0,0,2491,2489,1,0,0,0,2492,
  	2497,3,284,142,0,2493,2494,5,183,0,0,2494,2496,3,284,142,0,2495,2493,
  	1,0,0,0,2496,2499,1,0,0,0,2497,2495,1,0,0,0,2497,2498,1,0,0,0,2498,2501,
  	1,0,0,0,2499,2497,1,0,0,0,2500,2484,1,0,0,0,2500,2492,1,0,0,0,2501,281,
  	1,0,0,0,2502,2504,3,720,360,0,2503,2502,1,0,0,0,2504,2507,1,0,0,0,2505,
  	2503,1,0,0,0,2505,2506,1,0,0,0,2506,2509,1,0,0,0,2507,2505,1,0,0,0,2508,
  	2510,3,642,321,0,2509,2508,1,0,0,0,2509,2510,1,0,0,0,2510,283,1,0,0,0,
  	2511,2513,3,720,360,0,2512,2511,1,0,0,0,2513,2516,1,0,0,0,2514,2512,1,
  	0,0,0,2514,2515,1,0,0,0,2515,2517,1,0,0,0,2516,2514,1,0,0,0,2517,2518,
  	5,186,0,0,2518,2519,3,766,383,0,2519,2521,5,194,0,0,2520,2522,3,642,321,
  	0,2521,2520,1,0,0,0,2521,2522,1,0,0,0,2522,2523,1,0,0,0,2523,2524,5,203,
  	0,0,2524,285,1,0,0,0,2525,2529,5,50,0,0,2526,2528,3,56,28,0,2527,2526,
  	1,0,0,0,2528,2531,1,0,0,0,2529,2527,1,0,0,0,2529,2530,1,0,0,0,2530,2532,
  	1,0,0,0,2531,2529,1,0,0,0,2532,2533,5,38,0,0,2533,287,1,0,0,0,2534,2535,
  	5,51,0,0,2535,2536,3,290,145,0,2536,2537,5,204,0,0,2537,289,1,0,0,0,2538,
  	2543,3,742,371,0,2539,2540,5,183,0,0,2540,2542,3,742,371,0,2541,2539,
  	1,0,0,0,2542,2545,1,0,0,0,2543,2541,1,0,0,0,2543,2544,1,0,0,0,2544,291,
  	1,0,0,0,2545,2543,1,0,0,0,2546,2547,5,45,0,0,2547,2548,5,194,0,0,2548,
  	2549,3,294,147,0,2549,2550,5,204,0,0,2550,2551,3,296,148,0,2551,2552,
  	5,204,0,0,2552,2553,3,298,149,0,2553,2554,5,203,0,0,2554,2555,3,308,154,
  	0,2555,293,1,0,0,0,2556,2557,3,742,371,0,2557,2558,5,188,0,0,2558,2559,
  	3,634,317,0,2559,295,1,0,0,0,2560,2561,3,634,317,0,2561,297,1,0,0,0,2562,
  	2563,3,742,371,0,2563,2564,5,188,0,0,2564,2565,3,296,148,0,2565,299,1,
  	0,0,0,2566,2569,3,302,151,0,2567,2569,3,304,152,0,2568,2566,1,0,0,0,2568,
  	2567,1,0,0,0,2569,301,1,0,0,0,2570,2571,5,54,0,0,2571,2572,5,194,0,0,
  	2572,2573,3,634,317,0,2573,2574,5,203,0,0,2574,2577,3,312,156,0,2575,
  	2576,5,33,0,0,2576,2578,3,312,156,0,2577,2575,1,0,0,0,2577,2578,1,0,0,
  	0,2578,303,1,0,0,0,2579,2580,5,9,0,0,2580,2581,5,194,0,0,2581,2582,3,
  	634,317,0,2582,2584,5,203,0,0,2583,2585,3,306,153,0,2584,2583,1,0,0,0,
  	2585,2586,1,0,0,0,2586,2584,1,0,0,0,2586,2587,1,0,0,0,2587,2588,1,0,0,
  	0,2588,2589,5,35,0,0,2589,305,1,0,0,0,2590,2595,3,634,317,0,2591,2592,
  	5,183,0,0,2592,2594,3,634,317,0,2593,2591,1,0,0,0,2594,2597,1,0,0,0,2595,
  	2593,1,0,0,0,2595,2596,1,0,0,0,2596,2598,1,0,0,0,2597,2595,1,0,0,0,2598,
  	2599,5,182,0,0,2599,2600,3,312,156,0,2600,2607,1,0,0,0,2601,2603,5,16,
  	0,0,2602,2604,5,182,0,0,2603,2602,1,0,0,0,2603,2604,1,0,0,0,2604,2605,
  	1,0,0,0,2605,2607,3,312,156,0,2606,2590,1,0,0,0,2606,2601,1,0,0,0,2607,
  	307,1,0,0,0,2608,2621,3,56,28,0,2609,2611,5,5,0,0,2610,2612,3,310,155,
  	0,2611,2610,1,0,0,0,2611,2612,1,0,0,0,2612,2616,1,0,0,0,2613,2615,3,56,
  	28,0,2614,2613,1,0,0,0,2615,2618,1,0,0,0,2616,2614,1,0,0,0,2616,2617,
  	1,0,0,0,2617,2619,1,0,0,0,2618,2616,1,0,0,0,2619,2621,5,34,0,0,2620,2608,
  	1,0,0,0,2620,2609,1,0,0,0,2621,309,1,0,0,0,2622,2623,5,182,0,0,2623,2624,
  	3,740,370,0,2624,311,1,0,0,0,2625,2628,3,308,154,0,2626,2628,5,204,0,
  	0,2627,2625,1,0,0,0,2627,2626,1,0,0,0,2628,313,1,0,0,0,2629,2631,3,720,
  	360,0,2630,2629,1,0,0,0,2631,2634,1,0,0,0,2632,2630,1,0,0,0,2632,2633,
  	1,0,0,0,2633,2635,1,0,0,0,2634,2632,1,0,0,0,2635,2636,5,85,0,0,2636,2637,
  	3,784,392,0,2637,2638,5,194,0,0,2638,2639,3,316,158,0,2639,2640,5,203,
  	0,0,2640,2642,5,204,0,0,2641,2643,3,320,160,0,2642,2641,1,0,0,0,2643,
  	2644,1,0,0,0,2644,2642,1,0,0,0,2644,2645,1,0,0,0,2645,2646,1,0,0,0,2646,
  	2647,3,328,164,0,2647,2648,5,40,0,0,2648,2665,1,0,0,0,2649,2651,3,720,
  	360,0,2650,2649,1,0,0,0,2651,2654,1,0,0,0,2652,2650,1,0,0,0,2652,2653,
  	1,0,0,0,2653,2655,1,0,0,0,2654,2652,1,0,0,0,2655,2656,5,85,0,0,2656,2657,
  	3,784,392,0,2657,2658,5,194,0,0,2658,2659,3,318,159,0,2659,2660,5,203,
  	0,0,2660,2661,5,204,0,0,2661,2662,3,328,164,0,2662,2663,5,40,0,0,2663,
  	2665,1,0,0,0,2664,2632,1,0,0,0,2664,2652,1,0,0,0,2665,315,1,0,0,0,2666,
  	2667,3,762,381,0,2667,2668,5,183,0,0,2668,2673,3,750,375,0,2669,2670,
  	5,183,0,0,2670,2672,3,750,375,0,2671,2669,1,0,0,0,2672,2675,1,0,0,0,2673,
  	2671,1,0,0,0,2673,2674,1,0,0,0,2674,317,1,0,0,0,2675,2673,1,0,0,0,2676,
  	2677,3,322,161,0,2677,2678,5,183,0,0,2678,2683,3,324,162,0,2679,2680,
  	5,183,0,0,2680,2682,3,324,162,0,2681,2679,1,0,0,0,2682,2685,1,0,0,0,2683,
  	2681,1,0,0,0,2683,2684,1,0,0,0,2684,319,1,0,0,0,2685,2683,1,0,0,0,2686,
  	2687,3,322,161,0,2687,2688,5,204,0,0,2688,2696,1,0,0,0,2689,2690,3,324,
  	162,0,2690,2691,5,204,0,0,2691,2696,1,0,0,0,2692,2693,3,326,163,0,2693,
  	2694,5,204,0,0,2694,2696,1,0,0,0,2695,2686,1,0,0,0,2695,2689,1,0,0,0,
  	2695,2692,1,0,0,0,2696,321,1,0,0,0,2697,2699,3,720,360,0,2698,2697,1,
  	0,0,0,2699,2702,1,0,0,0,2700,2698,1,0,0,0,2700,2701,1,0,0,0,2701,2703,
  	1,0,0,0,2702,2700,1,0,0,0,2703,2704,5,80,0,0,2704,2719,3,766,383,0,2705,
  	2707,3,720,360,0,2706,2705,1,0,0,0,2707,2710,1,0,0,0,2708,2706,1,0,0,
  	0,2708,2709,1,0,0,0,2709,2711,1,0,0,0,2710,2708,1,0,0,0,2711,2712,5,80,
  	0,0,2712,2713,5,95,0,0,2713,2716,3,766,383,0,2714,2715,5,188,0,0,2715,
  	2717,3,634,317,0,2716,2714,1,0,0,0,2716,2717,1,0,0,0,2717,2719,1,0,0,
  	0,2718,2700,1,0,0,0,2718,2708,1,0,0,0,2719,323,1,0,0,0,2720,2722,3,720,
  	360,0,2721,2720,1,0,0,0,2722,2725,1,0,0,0,2723,2721,1,0,0,0,2723,2724,
  	1,0,0,0,2724,2726,1,0,0,0,2725,2723,1,0,0,0,2726,2727,5,59,0,0,2727,2728,
  	3,148,74,0,2728,325,1,0,0,0,2729,2731,3,720,360,0,2730,2729,1,0,0,0,2731,
  	2734,1,0,0,0,2732,2730,1,0,0,0,2732,2733,1,0,0,0,2733,2735,1,0,0,0,2734,
  	2732,1,0,0,0,2735,2736,5,95,0,0,2736,2737,3,788,394,0,2737,327,1,0,0,
  	0,2738,2741,3,330,165,0,2739,2741,3,334,167,0,2740,2738,1,0,0,0,2740,
  	2739,1,0,0,0,2741,329,1,0,0,0,2742,2744,5,113,0,0,2743,2745,3,332,166,
  	0,2744,2743,1,0,0,0,2745,2746,1,0,0,0,2746,2744,1,0,0,0,2746,2747,1,0,
  	0,0,2747,2748,1,0,0,0,2748,2749,5,42,0,0,2749,331,1,0,0,0,2750,2751,3,
  	344,172,0,2751,2752,5,182,0,0,2752,2753,3,354,177,0,2753,2754,5,204,0,
  	0,2754,333,1,0,0,0,2755,2757,3,336,168,0,2756,2755,1,0,0,0,2756,2757,
  	1,0,0,0,2757,2758,1,0,0,0,2758,2760,5,113,0,0,2759,2761,3,340,170,0,2760,
  	2759,1,0,0,0,2761,2762,1,0,0,0,2762,2760,1,0,0,0,2762,2763,1,0,0,0,2763,
  	2764,1,0,0,0,2764,2765,5,42,0,0,2765,335,1,0,0,0,2766,2767,5,57,0,0,2767,
  	2768,3,762,381,0,2768,2769,5,188,0,0,2769,2770,3,338,169,0,2770,2771,
  	5,204,0,0,2771,337,1,0,0,0,2772,2775,3,686,343,0,2773,2775,3,700,350,
  	0,2774,2772,1,0,0,0,2774,2773,1,0,0,0,2775,339,1,0,0,0,2776,2777,3,342,
  	171,0,2777,2778,5,182,0,0,2778,2779,3,350,175,0,2779,2780,5,182,0,0,2780,
  	2781,3,352,176,0,2781,2782,5,204,0,0,2782,341,1,0,0,0,2783,2786,3,344,
  	172,0,2784,2786,3,346,173,0,2785,2783,1,0,0,0,2785,2784,1,0,0,0,2786,
  	343,1,0,0,0,2787,2789,3,356,178,0,2788,2787,1,0,0,0,2789,2790,1,0,0,0,
  	2790,2788,1,0,0,0,2790,2791,1,0,0,0,2791,345,1,0,0,0,2792,2794,3,356,
  	178,0,2793,2792,1,0,0,0,2794,2797,1,0,0,0,2795,2793,1,0,0,0,2795,2796,
  	1,0,0,0,2796,2798,1,0,0,0,2797,2795,1,0,0,0,2798,2802,3,348,174,0,2799,
  	2801,3,356,178,0,2800,2799,1,0,0,0,2801,2804,1,0,0,0,2802,2800,1,0,0,
  	0,2802,2803,1,0,0,0,2803,347,1,0,0,0,2804,2802,1,0,0,0,2805,2806,5,194,
  	0,0,2806,2807,3,356,178,0,2807,2808,3,356,178,0,2808,2809,5,203,0,0,2809,
  	2812,1,0,0,0,2810,2812,3,358,179,0,2811,2805,1,0,0,0,2811,2810,1,0,0,
  	0,2812,349,1,0,0,0,2813,2814,3,356,178,0,2814,351,1,0,0,0,2815,2818,3,
  	354,177,0,2816,2818,5,196,0,0,2817,2815,1,0,0,0,2817,2816,1,0,0,0,2818,
  	353,1,0,0,0,2819,2820,5,230,0,0,2820,355,1,0,0,0,2821,2822,7,14,0,0,2822,
  	357,1,0,0,0,2823,2824,5,228,0,0,2824,359,1,0,0,0,2825,2827,3,784,392,
  	0,2826,2828,3,120,60,0,2827,2826,1,0,0,0,2827,2828,1,0,0,0,2828,2830,
  	1,0,0,0,2829,2831,3,130,65,0,2830,2829,1,0,0,0,2830,2831,1,0,0,0,2831,
  	2832,1,0,0,0,2832,2837,3,362,181,0,2833,2834,5,183,0,0,2834,2836,3,362,
  	181,0,2835,2833,1,0,0,0,2836,2839,1,0,0,0,2837,2835,1,0,0,0,2837,2838,
  	1,0,0,0,2838,2840,1,0,0,0,2839,2837,1,0,0,0,2840,2841,5,204,0,0,2841,
  	361,1,0,0,0,2842,2844,3,364,182,0,2843,2842,1,0,0,0,2843,2844,1,0,0,0,
  	2844,2845,1,0,0,0,2845,2846,5,194,0,0,2846,2847,3,248,124,0,2847,2848,
  	5,183,0,0,2848,2853,3,244,122,0,2849,2850,5,183,0,0,2850,2852,3,244,122,
  	0,2851,2849,1,0,0,0,2852,2855,1,0,0,0,2853,2851,1,0,0,0,2853,2854,1,0,
  	0,0,2854,2856,1,0,0,0,2855,2853,1,0,0,0,2856,2857,5,203,0,0,2857,363,
  	1,0,0,0,2858,2860,3,786,393,0,2859,2861,3,178,89,0,2860,2859,1,0,0,0,
  	2860,2861,1,0,0,0,2861,365,1,0,0,0,2862,2864,5,3,0,0,2863,2865,3,120,
  	60,0,2864,2863,1,0,0,0,2864,2865,1,0,0,0,2865,2867,1,0,0,0,2866,2868,
  	3,128,64,0,2867,2866,1,0,0,0,2867,2868,1,0,0,0,2868,2869,1,0,0,0,2869,
  	2870,3,368,184,0,2870,2871,5,204,0,0,2871,367,1,0,0,0,2872,2877,3,370,
  	185,0,2873,2874,5,183,0,0,2874,2876,3,370,185,0,2875,2873,1,0,0,0,2876,
  	2879,1,0,0,0,2877,2875,1,0,0,0,2877,2878,1,0,0,0,2878,369,1,0,0,0,2879,
  	2877,1,0,0,0,2880,2881,3,668,334,0,2881,2882,5,188,0,0,2882,2883,3,642,
  	321,0,2883,371,1,0,0,0,2884,2885,5,57,0,0,2885,2886,3,394,197,0,2886,
  	373,1,0,0,0,2887,2888,5,1,0,0,2888,2889,3,394,197,0,2889,375,1,0,0,0,
  	2890,2891,5,137,0,0,2891,2892,3,394,197,0,2892,377,1,0,0,0,2893,2894,
  	3,674,337,0,2894,2896,5,188,0,0,2895,2897,3,402,201,0,2896,2895,1,0,0,
  	0,2896,2897,1,0,0,0,2897,2898,1,0,0,0,2898,2899,3,642,321,0,2899,379,
  	1,0,0,0,2900,2901,3,674,337,0,2901,2903,5,162,0,0,2902,2904,3,402,201,
  	0,2903,2902,1,0,0,0,2903,2904,1,0,0,0,2904,2905,1,0,0,0,2905,2906,3,642,
  	321,0,2906,381,1,0,0,0,2907,2908,3,624,312,0,2908,2910,5,154,0,0,2909,
  	2911,3,402,201,0,2910,2909,1,0,0,0,2910,2911,1,0,0,0,2911,2912,1,0,0,
  	0,2912,2913,3,642,321,0,2913,383,1,0,0,0,2914,2915,5,3,0,0,2915,2923,
  	3,386,193,0,2916,2917,5,15,0,0,2917,2923,3,674,337,0,2918,2919,5,46,0,
  	0,2919,2923,3,386,193,0,2920,2921,5,96,0,0,2921,2923,3,674,337,0,2922,
  	2914,1,0,0,0,2922,2916,1,0,0,0,2922,2918,1,0,0,0,2922,2920,1,0,0,0,2923,
  	385,1,0,0,0,2924,2925,3,674,337,0,2925,2926,5,188,0,0,2926,2927,3,642,
  	321,0,2927,387,1,0,0,0,2928,2936,5,48,0,0,2929,2933,3,390,195,0,2930,
  	2932,3,206,103,0,2931,2930,1,0,0,0,2932,2935,1,0,0,0,2933,2931,1,0,0,
  	0,2933,2934,1,0,0,0,2934,2937,1,0,0,0,2935,2933,1,0,0,0,2936,2929,1,0,
  	0,0,2936,2937,1,0,0,0,2937,2941,1,0,0,0,2938,2940,3,394,197,0,2939,2938,
  	1,0,0,0,2940,2943,1,0,0,0,2941,2939,1,0,0,0,2941,2942,1,0,0,0,2942,2944,
  	1,0,0,0,2943,2941,1,0,0,0,2944,2945,5,62,0,0,2945,389,1,0,0,0,2946,2947,
  	5,182,0,0,2947,2948,3,726,363,0,2948,391,1,0,0,0,2949,2957,5,5,0,0,2950,
  	2954,3,390,195,0,2951,2953,3,206,103,0,2952,2951,1,0,0,0,2953,2956,1,
  	0,0,0,2954,2952,1,0,0,0,2954,2955,1,0,0,0,2955,2958,1,0,0,0,2956,2954,
  	1,0,0,0,2957,2950,1,0,0,0,2957,2958,1,0,0,0,2958,2962,1,0,0,0,2959,2961,
  	3,394,197,0,2960,2959,1,0,0,0,2961,2964,1,0,0,0,2962,2960,1,0,0,0,2962,
  	2963,1,0,0,0,2963,2965,1,0,0,0,2964,2962,1,0,0,0,2965,2966,5,34,0,0,2966,
  	393,1,0,0,0,2967,2969,3,720,360,0,2968,2967,1,0,0,0,2969,2972,1,0,0,0,
  	2970,2968,1,0,0,0,2970,2971,1,0,0,0,2971,2973,1,0,0,0,2972,2970,1,0,0,
  	0,2973,2974,3,378,189,0,2974,2975,5,204,0,0,2975,3081,1,0,0,0,2976,2978,
  	3,720,360,0,2977,2976,1,0,0,0,2978,2981,1,0,0,0,2979,2977,1,0,0,0,2979,
  	2980,1,0,0,0,2980,2982,1,0,0,0,2981,2979,1,0,0,0,2982,3081,3,420,210,
  	0,2983,2985,3,720,360,0,2984,2983,1,0,0,0,2985,2988,1,0,0,0,2986,2984,
  	1,0,0,0,2986,2987,1,0,0,0,2987,2989,1,0,0,0,2988,2986,1,0,0,0,2989,3081,
  	3,418,209,0,2990,2992,3,720,360,0,2991,2990,1,0,0,0,2992,2995,1,0,0,0,
  	2993,2991,1,0,0,0,2993,2994,1,0,0,0,2994,2996,1,0,0,0,2995,2993,1,0,0,
  	0,2996,3081,3,404,202,0,2997,2999,3,720,360,0,2998,2997,1,0,0,0,2999,
  	3002,1,0,0,0,3000,2998,1,0,0,0,3000,3001,1,0,0,0,3001,3003,1,0,0,0,3002,
  	3000,1,0,0,0,3003,3081,3,408,204,0,3004,3006,3,720,360,0,3005,3004,1,
  	0,0,0,3006,3009,1,0,0,0,3007,3005,1,0,0,0,3007,3008,1,0,0,0,3008,3010,
  	1,0,0,0,3009,3007,1,0,0,0,3010,3081,3,424,212,0,3011,3013,3,720,360,0,
  	3012,3011,1,0,0,0,3013,3016,1,0,0,0,3014,3012,1,0,0,0,3014,3015,1,0,0,
  	0,3015,3017,1,0,0,0,3016,3014,1,0,0,0,3017,3018,3,380,190,0,3018,3019,
  	5,204,0,0,3019,3081,1,0,0,0,3020,3022,3,720,360,0,3021,3020,1,0,0,0,3022,
  	3025,1,0,0,0,3023,3021,1,0,0,0,3023,3024,1,0,0,0,3024,3026,1,0,0,0,3025,
  	3023,1,0,0,0,3026,3027,3,382,191,0,3027,3028,5,204,0,0,3028,3081,1,0,
  	0,0,3029,3031,3,720,360,0,3030,3029,1,0,0,0,3031,3034,1,0,0,0,3032,3030,
  	1,0,0,0,3032,3033,1,0,0,0,3033,3035,1,0,0,0,3034,3032,1,0,0,0,3035,3081,
  	3,388,194,0,3036,3038,3,720,360,0,3037,3036,1,0,0,0,3038,3041,1,0,0,0,
  	3039,3037,1,0,0,0,3039,3040,1,0,0,0,3040,3042,1,0,0,0,3041,3039,1,0,0,
  	0,3042,3043,3,384,192,0,3043,3044,5,204,0,0,3044,3081,1,0,0,0,3045,3047,
  	3,720,360,0,3046,3045,1,0,0,0,3047,3050,1,0,0,0,3048,3046,1,0,0,0,3048,
  	3049,1,0,0,0,3049,3051,1,0,0,0,3050,3048,1,0,0,0,3051,3081,3,414,207,
  	0,3052,3054,3,720,360,0,3053,3052,1,0,0,0,3054,3057,1,0,0,0,3055,3053,
  	1,0,0,0,3055,3056,1,0,0,0,3056,3058,1,0,0,0,3057,3055,1,0,0,0,3058,3081,
  	3,392,196,0,3059,3061,3,720,360,0,3060,3059,1,0,0,0,3061,3064,1,0,0,0,
  	3062,3060,1,0,0,0,3062,3063,1,0,0,0,3063,3065,1,0,0,0,3064,3062,1,0,0,
  	0,3065,3081,3,426,213,0,3066,3068,3,720,360,0,3067,3066,1,0,0,0,3068,
  	3071,1,0,0,0,3069,3067,1,0,0,0,3069,3070,1,0,0,0,3070,3072,1,0,0,0,3071,
  	3069,1,0,0,0,3072,3081,3,432,216,0,3073,3075,3,720,360,0,3074,3073,1,
  	0,0,0,3075,3078,1,0,0,0,3076,3074,1,0,0,0,3076,3077,1,0,0,0,3077,3079,
  	1,0,0,0,3078,3076,1,0,0,0,3079,3081,3,416,208,0,3080,2970,1,0,0,0,3080,
  	2979,1,0,0,0,3080,2986,1,0,0,0,3080,2993,1,0,0,0,3080,3000,1,0,0,0,3080,
  	3007,1,0,0,0,3080,3014,1,0,0,0,3080,3023,1,0,0,0,3080,3032,1,0,0,0,3080,
  	3039,1,0,0,0,3080,3048,1,0,0,0,3080,3055,1,0,0,0,3080,3062,1,0,0,0,3080,
  	3069,1,0,0,0,3080,3076,1,0,0,0,3081,395,1,0,0,0,3082,3091,3,394,197,0,
  	3083,3085,3,720,360,0,3084,3083,1,0,0,0,3085,3088,1,0,0,0,3086,3084,1,
  	0,0,0,3086,3087,1,0,0,0,3087,3089,1,0,0,0,3088,3086,1,0,0,0,3089,3091,
  	5,204,0,0,3090,3082,1,0,0,0,3090,3086,1,0,0,0,3091,397,1,0,0,0,3092,3093,
  	3,394,197,0,3093,399,1,0,0,0,3094,3095,5,191,0,0,3095,3102,3,132,66,0,
  	3096,3097,5,191,0,0,3097,3098,5,194,0,0,3098,3099,3,646,323,0,3099,3100,
  	5,203,0,0,3100,3102,1,0,0,0,3101,3094,1,0,0,0,3101,3096,1,0,0,0,3102,
  	401,1,0,0,0,3103,3112,3,400,200,0,3104,3112,3,406,203,0,3105,3106,5,97,
  	0,0,3106,3107,5,194,0,0,3107,3108,3,642,321,0,3108,3109,5,203,0,0,3109,
  	3110,3,406,203,0,3110,3112,1,0,0,0,3111,3103,1,0,0,0,3111,3104,1,0,0,
  	0,3111,3105,1,0,0,0,3112,403,1,0,0,0,3113,3114,5,19,0,0,3114,3115,3,744,
  	372,0,3115,3116,5,204,0,0,3116,405,1,0,0,0,3117,3118,5,180,0,0,3118,3131,
  	3,744,372,0,3119,3120,5,180,0,0,3120,3121,5,194,0,0,3121,3122,3,410,205,
  	0,3122,3123,5,203,0,0,3123,3131,1,0,0,0,3124,3125,5,180,0,0,3125,3131,
  	5,179,0,0,3126,3127,5,180,0,0,3127,3128,5,194,0,0,3128,3129,5,179,0,0,
  	3129,3131,5,203,0,0,3130,3117,1,0,0,0,3130,3119,1,0,0,0,3130,3124,1,0,
  	0,0,3130,3126,1,0,0,0,3131,407,1,0,0,0,3132,3133,5,161,0,0,3133,3135,
  	3,744,372,0,3134,3136,3,666,333,0,3135,3134,1,0,0,0,3135,3136,1,0,0,0,
  	3136,3137,1,0,0,0,3137,3138,5,204,0,0,3138,409,1,0,0,0,3139,3140,6,205,
  	-1,0,3140,3146,3,642,321,0,3141,3142,5,84,0,0,3142,3146,3,642,321,0,3143,
  	3144,5,72,0,0,3144,3146,3,642,321,0,3145,3139,1,0,0,0,3145,3141,1,0,0,
  	0,3145,3143,1,0,0,0,3146,3155,1,0,0,0,3147,3148,10,2,0,0,3148,3149,5,
  	79,0,0,3149,3154,3,410,205,3,3150,3151,10,1,0,0,3151,3152,5,183,0,0,3152,
  	3154,3,410,205,2,3153,3147,1,0,0,0,3153,3150,1,0,0,0,3154,3157,1,0,0,
  	0,3155,3153,1,0,0,0,3155,3156,1,0,0,0,3156,411,1,0,0,0,3157,3155,1,0,
  	0,0,3158,3161,3,400,200,0,3159,3161,3,406,203,0,3160,3158,1,0,0,0,3160,
  	3159,1,0,0,0,3161,413,1,0,0,0,3162,3163,3,412,206,0,3163,3164,3,396,198,
  	0,3164,415,1,0,0,0,3165,3166,5,128,0,0,3166,3167,5,194,0,0,3167,3168,
  	3,642,321,0,3168,3169,5,203,0,0,3169,3170,3,396,198,0,3170,417,1,0,0,
  	0,3171,3172,5,54,0,0,3172,3173,5,194,0,0,3173,3174,3,642,321,0,3174,3175,
  	5,203,0,0,3175,3178,3,396,198,0,3176,3177,5,33,0,0,3177,3179,3,396,198,
  	0,3178,3176,1,0,0,0,3178,3179,1,0,0,0,3179,419,1,0,0,0,3180,3181,5,9,
  	0,0,3181,3182,5,194,0,0,3182,3183,3,642,321,0,3183,3185,5,203,0,0,3184,
  	3186,3,422,211,0,3185,3184,1,0,0,0,3186,3187,1,0,0,0,3187,3185,1,0,0,
  	0,3187,3188,1,0,0,0,3188,3189,1,0,0,0,3189,3190,5,35,0,0,3190,3214,1,
  	0,0,0,3191,3192,5,11,0,0,3192,3193,5,194,0,0,3193,3194,3,642,321,0,3194,
  	3196,5,203,0,0,3195,3197,3,422,211,0,3196,3195,1,0,0,0,3197,3198,1,0,
  	0,0,3198,3196,1,0,0,0,3198,3199,1,0,0,0,3199,3200,1,0,0,0,3200,3201,5,
  	35,0,0,3201,3214,1,0,0,0,3202,3203,5,10,0,0,3203,3204,5,194,0,0,3204,
  	3205,3,642,321,0,3205,3207,5,203,0,0,3206,3208,3,422,211,0,3207,3206,
  	1,0,0,0,3208,3209,1,0,0,0,3209,3207,1,0,0,0,3209,3210,1,0,0,0,3210,3211,
  	1,0,0,0,3211,3212,5,35,0,0,3212,3214,1,0,0,0,3213,3180,1,0,0,0,3213,3191,
  	1,0,0,0,3213,3202,1,0,0,0,3214,421,1,0,0,0,3215,3220,3,642,321,0,3216,
  	3217,5,183,0,0,3217,3219,3,642,321,0,3218,3216,1,0,0,0,3219,3222,1,0,
  	0,0,3220,3218,1,0,0,0,3220,3221,1,0,0,0,3221,3223,1,0,0,0,3222,3220,1,
  	0,0,0,3223,3224,5,182,0,0,3224,3225,3,396,198,0,3225,3232,1,0,0,0,3226,
  	3228,5,16,0,0,3227,3229,5,182,0,0,3228,3227,1,0,0,0,3228,3229,1,0,0,0,
  	3229,3230,1,0,0,0,3230,3232,3,396,198,0,3231,3215,1,0,0,0,3231,3226,1,
  	0,0,0,3232,423,1,0,0,0,3233,3234,5,47,0,0,3234,3258,3,394,197,0,3235,
  	3236,5,97,0,0,3236,3237,5,194,0,0,3237,3238,3,642,321,0,3238,3239,5,203,
  	0,0,3239,3240,3,394,197,0,3240,3258,1,0,0,0,3241,3242,5,132,0,0,3242,
  	3243,5,194,0,0,3243,3244,3,642,321,0,3244,3245,5,203,0,0,3245,3246,3,
  	394,197,0,3246,3258,1,0,0,0,3247,3248,5,45,0,0,3248,3249,5,194,0,0,3249,
  	3250,3,386,193,0,3250,3251,5,204,0,0,3251,3252,3,642,321,0,3252,3253,
  	5,204,0,0,3253,3254,3,386,193,0,3254,3255,5,203,0,0,3255,3256,3,394,197,
  	0,3256,3258,1,0,0,0,3257,3233,1,0,0,0,3257,3235,1,0,0,0,3257,3241,1,0,
  	0,0,3257,3247,1,0,0,0,3258,425,1,0,0,0,3259,3261,3,776,388,0,3260,3262,
  	3,428,214,0,3261,3260,1,0,0,0,3261,3262,1,0,0,0,3262,3263,1,0,0,0,3263,
  	3264,5,204,0,0,3264,427,1,0,0,0,3265,3266,5,194,0,0,3266,3271,3,430,215,
  	0,3267,3268,5,183,0,0,3268,3270,3,430,215,0,3269,3267,1,0,0,0,3270,3273,
  	1,0,0,0,3271,3269,1,0,0,0,3271,3272,1,0,0,0,3272,3274,1,0,0,0,3273,3271,
  	1,0,0,0,3274,3275,5,203,0,0,3275,429,1,0,0,0,3276,3278,3,642,321,0,3277,
  	3276,1,0,0,0,3277,3278,1,0,0,0,3278,431,1,0,0,0,3279,3281,3,744,372,0,
  	3280,3282,3,434,217,0,3281,3280,1,0,0,0,3281,3282,1,0,0,0,3282,3283,1,
  	0,0,0,3283,3284,5,204,0,0,3284,433,1,0,0,0,3285,3286,5,194,0,0,3286,3291,
  	3,642,321,0,3287,3288,5,183,0,0,3288,3290,3,642,321,0,3289,3287,1,0,0,
  	0,3290,3293,1,0,0,0,3291,3289,1,0,0,0,3291,3292,1,0,0,0,3292,3294,1,0,
  	0,0,3293,3291,1,0,0,0,3294,3295,5,203,0,0,3295,435,1,0,0,0,3296,3300,
  	5,107,0,0,3297,3299,3,438,219,0,3298,3297,1,0,0,0,3299,3302,1,0,0,0,3300,
  	3298,1,0,0,0,3300,3301,1,0,0,0,3301,3303,1,0,0,0,3302,3300,1,0,0,0,3303,
  	3304,5,41,0,0,3304,437,1,0,0,0,3305,3311,3,86,43,0,3306,3311,3,440,220,
  	0,3307,3311,3,442,221,0,3308,3311,3,444,222,0,3309,3311,3,516,258,0,3310,
  	3305,1,0,0,0,3310,3306,1,0,0,0,3310,3307,1,0,0,0,3310,3308,1,0,0,0,3310,
  	3309,1,0,0,0,3311,439,1,0,0,0,3312,3313,5,91,0,0,3313,3314,3,454,227,
  	0,3314,3315,5,204,0,0,3315,3321,1,0,0,0,3316,3317,5,90,0,0,3317,3318,
  	3,454,227,0,3318,3319,5,204,0,0,3319,3321,1,0,0,0,3320,3312,1,0,0,0,3320,
  	3316,1,0,0,0,3321,441,1,0,0,0,3322,3323,5,104,0,0,3323,3324,3,454,227,
  	0,3324,3325,5,204,0,0,3325,3331,1,0,0,0,3326,3327,5,75,0,0,3327,3328,
  	3,454,227,0,3328,3329,5,204,0,0,3329,3331,1,0,0,0,3330,3322,1,0,0,0,3330,
  	3326,1,0,0,0,3331,443,1,0,0,0,3332,3333,3,446,223,0,3333,3334,5,204,0,
  	0,3334,3342,1,0,0,0,3335,3336,3,502,251,0,3336,3337,5,204,0,0,3337,3342,
  	1,0,0,0,3338,3339,3,512,256,0,3339,3340,5,204,0,0,3340,3342,1,0,0,0,3341,
  	3332,1,0,0,0,3341,3335,1,0,0,0,3341,3338,1,0,0,0,3342,445,1,0,0,0,3343,
  	3344,3,448,224,0,3344,3345,5,188,0,0,3345,3346,3,464,232,0,3346,3352,
  	1,0,0,0,3347,3348,3,450,225,0,3348,3349,5,188,0,0,3349,3350,3,464,232,
  	0,3350,3352,1,0,0,0,3351,3343,1,0,0,0,3351,3347,1,0,0,0,3352,447,1,0,
  	0,0,3353,3354,5,194,0,0,3354,3356,3,456,228,0,3355,3357,3,514,257,0,3356,
  	3355,1,0,0,0,3356,3357,1,0,0,0,3357,3358,1,0,0,0,3358,3359,5,172,0,0,
  	3359,3360,3,458,229,0,3360,3361,5,203,0,0,3361,449,1,0,0,0,3362,3363,
  	5,194,0,0,3363,3365,3,452,226,0,3364,3366,3,514,257,0,3365,3364,1,0,0,
  	0,3365,3366,1,0,0,0,3366,3367,1,0,0,0,3367,3368,5,165,0,0,3368,3369,3,
  	454,227,0,3369,3370,5,203,0,0,3370,451,1,0,0,0,3371,3376,3,456,228,0,
  	3372,3373,5,183,0,0,3373,3375,3,456,228,0,3374,3372,1,0,0,0,3375,3378,
  	1,0,0,0,3376,3374,1,0,0,0,3376,3377,1,0,0,0,3377,453,1,0,0,0,3378,3376,
  	1,0,0,0,3379,3384,3,458,229,0,3380,3381,5,183,0,0,3381,3383,3,458,229,
  	0,3382,3380,1,0,0,0,3383,3386,1,0,0,0,3384,3382,1,0,0,0,3384,3385,1,0,
  	0,0,3385,455,1,0,0,0,3386,3384,1,0,0,0,3387,3392,3,460,230,0,3388,3389,
  	5,192,0,0,3389,3390,3,638,319,0,3390,3391,5,201,0,0,3391,3393,1,0,0,0,
  	3392,3388,1,0,0,0,3392,3393,1,0,0,0,3393,457,1,0,0,0,3394,3399,3,462,
  	231,0,3395,3396,5,192,0,0,3396,3397,3,638,319,0,3397,3398,5,201,0,0,3398,
  	3400,1,0,0,0,3399,3395,1,0,0,0,3399,3400,1,0,0,0,3400,459,1,0,0,0,3401,
  	3402,3,766,383,0,3402,461,1,0,0,0,3403,3404,3,766,383,0,3404,463,1,0,
  	0,0,3405,3411,3,466,233,0,3406,3407,5,194,0,0,3407,3408,3,466,233,0,3408,
  	3409,5,203,0,0,3409,3411,1,0,0,0,3410,3405,1,0,0,0,3410,3406,1,0,0,0,
  	3411,465,1,0,0,0,3412,3447,3,468,234,0,3413,3414,3,470,235,0,3414,3415,
  	5,183,0,0,3415,3418,3,472,236,0,3416,3417,5,183,0,0,3417,3419,3,474,237,
  	0,3418,3416,1,0,0,0,3418,3419,1,0,0,0,3419,3447,1,0,0,0,3420,3421,3,476,
  	238,0,3421,3422,5,183,0,0,3422,3423,3,478,239,0,3423,3424,5,183,0,0,3424,
  	3425,3,480,240,0,3425,3426,5,183,0,0,3426,3427,3,482,241,0,3427,3428,
  	5,183,0,0,3428,3429,3,484,242,0,3429,3430,5,183,0,0,3430,3444,3,486,243,
  	0,3431,3432,5,183,0,0,3432,3433,3,488,244,0,3433,3434,5,183,0,0,3434,
  	3435,3,490,245,0,3435,3436,5,183,0,0,3436,3437,3,492,246,0,3437,3438,
  	5,183,0,0,3438,3439,3,494,247,0,3439,3440,5,183,0,0,3440,3441,3,496,248,
  	0,3441,3442,5,183,0,0,3442,3443,3,498,249,0,3443,3445,1,0,0,0,3444,3431,
  	1,0,0,0,3444,3445,1,0,0,0,3445,3447,1,0,0,0,3446,3412,1,0,0,0,3446,3413,
  	1,0,0,0,3446,3420,1,0,0,0,3447,467,1,0,0,0,3448,3449,3,500,250,0,3449,
  	469,1,0,0,0,3450,3451,3,500,250,0,3451,471,1,0,0,0,3452,3453,3,500,250,
  	0,3453,473,1,0,0,0,3454,3455,3,500,250,0,3455,475,1,0,0,0,3456,3457,3,
  	500,250,0,3457,477,1,0,0,0,3458,3459,3,500,250,0,3459,479,1,0,0,0,3460,
  	3461,3,500,250,0,3461,481,1,0,0,0,3462,3463,3,500,250,0,3463,483,1,0,
  	0,0,3464,3465,3,500,250,0,3465,485,1,0,0,0,3466,3467,3,500,250,0,3467,
  	487,1,0,0,0,3468,3469,3,500,250,0,3469,489,1,0,0,0,3470,3471,3,500,250,
  	0,3471,491,1,0,0,0,3472,3473,3,500,250,0,3473,493,1,0,0,0,3474,3475,3,
  	500,250,0,3475,495,1,0,0,0,3476,3477,3,500,250,0,3477,497,1,0,0,0,3478,
  	3479,3,500,250,0,3479,499,1,0,0,0,3480,3481,3,636,318,0,3481,501,1,0,
  	0,0,3482,3483,3,504,252,0,3483,3484,5,188,0,0,3484,3485,3,464,232,0,3485,
  	3491,1,0,0,0,3486,3487,3,506,253,0,3487,3488,5,188,0,0,3488,3489,3,464,
  	232,0,3489,3491,1,0,0,0,3490,3482,1,0,0,0,3490,3486,1,0,0,0,3491,503,
  	1,0,0,0,3492,3494,5,194,0,0,3493,3495,3,510,255,0,3494,3493,1,0,0,0,3494,
  	3495,1,0,0,0,3495,3496,1,0,0,0,3496,3497,3,456,228,0,3497,3498,5,172,
  	0,0,3498,3499,5,194,0,0,3499,3501,3,458,229,0,3500,3502,3,514,257,0,3501,
  	3500,1,0,0,0,3501,3502,1,0,0,0,3502,3503,1,0,0,0,3503,3504,5,182,0,0,
  	3504,3505,3,508,254,0,3505,3506,5,203,0,0,3506,3507,5,203,0,0,3507,505,
  	1,0,0,0,3508,3510,5,194,0,0,3509,3511,3,510,255,0,3510,3509,1,0,0,0,3510,
  	3511,1,0,0,0,3511,3512,1,0,0,0,3512,3513,3,452,226,0,3513,3514,5,165,
  	0,0,3514,3515,5,194,0,0,3515,3517,3,454,227,0,3516,3518,3,514,257,0,3517,
  	3516,1,0,0,0,3517,3518,1,0,0,0,3518,3519,1,0,0,0,3519,3520,5,182,0,0,
  	3520,3521,3,508,254,0,3521,3522,5,203,0,0,3522,3523,5,203,0,0,3523,507,
  	1,0,0,0,3524,3525,3,642,321,0,3525,509,1,0,0,0,3526,3527,7,15,0,0,3527,
  	511,1,0,0,0,3528,3529,5,54,0,0,3529,3530,5,194,0,0,3530,3531,3,648,324,
  	0,3531,3532,5,203,0,0,3532,3533,3,446,223,0,3533,3543,1,0,0,0,3534,3535,
  	5,54,0,0,3535,3536,5,194,0,0,3536,3537,3,648,324,0,3537,3538,5,203,0,
  	0,3538,3539,3,502,251,0,3539,3543,1,0,0,0,3540,3541,5,55,0,0,3541,3543,
  	3,446,223,0,3542,3528,1,0,0,0,3542,3534,1,0,0,0,3542,3540,1,0,0,0,3543,
  	513,1,0,0,0,3544,3545,7,16,0,0,3545,515,1,0,0,0,3546,3559,3,518,259,0,
  	3547,3559,3,522,261,0,3548,3559,3,524,262,0,3549,3559,3,536,268,0,3550,
  	3559,3,538,269,0,3551,3559,3,540,270,0,3552,3559,3,542,271,0,3553,3559,
  	3,544,272,0,3554,3559,3,552,276,0,3555,3559,3,554,277,0,3556,3559,3,556,
  	278,0,3557,3559,3,560,280,0,3558,3546,1,0,0,0,3558,3547,1,0,0,0,3558,
  	3548,1,0,0,0,3558,3549,1,0,0,0,3558,3550,1,0,0,0,3558,3551,1,0,0,0,3558,
  	3552,1,0,0,0,3558,3553,1,0,0,0,3558,3554,1,0,0,0,3558,3555,1,0,0,0,3558,
  	3556,1,0,0,0,3558,3557,1,0,0,0,3559,517,1,0,0,0,3560,3561,5,27,0,0,3561,
  	3562,5,194,0,0,3562,3563,3,566,283,0,3563,3564,5,183,0,0,3564,3565,3,
  	578,289,0,3565,3566,5,183,0,0,3566,3568,3,588,294,0,3567,3569,3,520,260,
  	0,3568,3567,1,0,0,0,3568,3569,1,0,0,0,3569,3570,1,0,0,0,3570,3571,5,203,
  	0,0,3571,3572,5,204,0,0,3572,519,1,0,0,0,3573,3575,5,183,0,0,3574,3576,
  	3,576,288,0,3575,3574,1,0,0,0,3575,3576,1,0,0,0,3576,521,1,0,0,0,3577,
  	3578,5,21,0,0,3578,3579,5,194,0,0,3579,3580,3,578,289,0,3580,3581,5,183,
  	0,0,3581,3582,3,566,283,0,3582,3583,5,183,0,0,3583,3585,3,588,294,0,3584,
  	3586,3,520,260,0,3585,3584,1,0,0,0,3585,3586,1,0,0,0,3586,3587,1,0,0,
  	0,3587,3588,5,203,0,0,3588,3589,5,204,0,0,3589,523,1,0,0,0,3590,3591,
  	5,28,0,0,3591,3592,5,194,0,0,3592,3593,3,578,289,0,3593,3594,5,183,0,
  	0,3594,3595,3,566,283,0,3595,3596,5,183,0,0,3596,3597,3,588,294,0,3597,
  	3598,5,183,0,0,3598,3600,3,588,294,0,3599,3601,3,526,263,0,3600,3599,
  	1,0,0,0,3600,3601,1,0,0,0,3601,3602,1,0,0,0,3602,3603,5,203,0,0,3603,
  	3604,5,204,0,0,3604,525,1,0,0,0,3605,3607,5,183,0,0,3606,3608,3,576,288,
  	0,3607,3606,1,0,0,0,3607,3608,1,0,0,0,3608,3610,1,0,0,0,3609,3611,3,528,
  	264,0,3610,3609,1,0,0,0,3610,3611,1,0,0,0,3611,527,1,0,0,0,3612,3614,
  	5,183,0,0,3613,3615,3,582,291,0,3614,3613,1,0,0,0,3614,3615,1,0,0,0,3615,
  	3617,1,0,0,0,3616,3618,3,530,265,0,3617,3616,1,0,0,0,3617,3618,1,0,0,
  	0,3618,529,1,0,0,0,3619,3621,5,183,0,0,3620,3622,3,562,281,0,3621,3620,
  	1,0,0,0,3621,3622,1,0,0,0,3622,3624,1,0,0,0,3623,3625,3,532,266,0,3624,
  	3623,1,0,0,0,3624,3625,1,0,0,0,3625,531,1,0,0,0,3626,3628,5,183,0,0,3627,
  	3629,3,570,285,0,3628,3627,1,0,0,0,3628,3629,1,0,0,0,3629,3631,1,0,0,
  	0,3630,3632,3,534,267,0,3631,3630,1,0,0,0,3631,3632,1,0,0,0,3632,533,
  	1,0,0,0,3633,3635,5,183,0,0,3634,3636,3,568,284,0,3635,3634,1,0,0,0,3635,
  	3636,1,0,0,0,3636,535,1,0,0,0,3637,3638,5,24,0,0,3638,3639,5,194,0,0,
  	3639,3640,3,578,289,0,3640,3641,5,183,0,0,3641,3642,3,566,283,0,3642,
  	3643,5,183,0,0,3643,3645,3,588,294,0,3644,3646,3,520,260,0,3645,3644,
  	1,0,0,0,3645,3646,1,0,0,0,3646,3647,1,0,0,0,3647,3648,5,203,0,0,3648,
  	3649,5,204,0,0,3649,537,1,0,0,0,3650,3651,5,26,0,0,3651,3652,5,194,0,
  	0,3652,3653,3,578,289,0,3653,3654,5,183,0,0,3654,3655,3,566,283,0,3655,
  	3656,5,183,0,0,3656,3658,3,588,294,0,3657,3659,3,520,260,0,3658,3657,
  	1,0,0,0,3658,3659,1,0,0,0,3659,3660,1,0,0,0,3660,3661,5,203,0,0,3661,
  	3662,5,204,0,0,3662,539,1,0,0,0,3663,3664,5,25,0,0,3664,3665,5,194,0,
  	0,3665,3666,3,578,289,0,3666,3667,5,183,0,0,3667,3668,3,566,283,0,3668,
  	3669,5,183,0,0,3669,3670,3,588,294,0,3670,3671,5,183,0,0,3671,3673,3,
  	588,294,0,3672,3674,3,526,263,0,3673,3672,1,0,0,0,3673,3674,1,0,0,0,3674,
  	3675,1,0,0,0,3675,3676,5,203,0,0,3676,3677,5,204,0,0,3677,541,1,0,0,0,
  	3678,3679,5,29,0,0,3679,3680,5,194,0,0,3680,3681,3,578,289,0,3681,3682,
  	5,183,0,0,3682,3683,3,566,283,0,3683,3684,5,183,0,0,3684,3686,3,588,294,
  	0,3685,3687,3,520,260,0,3686,3685,1,0,0,0,3686,3687,1,0,0,0,3687,3688,
  	1,0,0,0,3688,3689,5,203,0,0,3689,3690,5,204,0,0,3690,543,1,0,0,0,3691,
  	3692,5,30,0,0,3692,3693,5,194,0,0,3693,3694,3,578,289,0,3694,3695,5,183,
  	0,0,3695,3696,3,566,283,0,3696,3697,5,183,0,0,3697,3699,3,588,294,0,3698,
  	3700,3,546,273,0,3699,3698,1,0,0,0,3699,3700,1,0,0,0,3700,3701,1,0,0,
  	0,3701,3702,5,203,0,0,3702,3703,5,204,0,0,3703,545,1,0,0,0,3704,3706,
  	5,183,0,0,3705,3707,3,576,288,0,3706,3705,1,0,0,0,3706,3707,1,0,0,0,3707,
  	3709,1,0,0,0,3708,3710,3,548,274,0,3709,3708,1,0,0,0,3709,3710,1,0,0,
  	0,3710,547,1,0,0,0,3711,3713,5,183,0,0,3712,3714,3,574,287,0,3713,3712,
  	1,0,0,0,3713,3714,1,0,0,0,3714,3716,1,0,0,0,3715,3717,3,550,275,0,3716,
  	3715,1,0,0,0,3716,3717,1,0,0,0,3717,549,1,0,0,0,3718,3720,5,183,0,0,3719,
  	3721,3,580,290,0,3720,3719,1,0,0,0,3720,3721,1,0,0,0,3721,551,1,0,0,0,
  	3722,3723,5,20,0,0,3723,3724,5,194,0,0,3724,3725,3,578,289,0,3725,3726,
  	5,183,0,0,3726,3727,3,566,283,0,3727,3728,5,183,0,0,3728,3729,3,588,294,
  	0,3729,3730,5,183,0,0,3730,3732,3,588,294,0,3731,3733,3,546,273,0,3732,
  	3731,1,0,0,0,3732,3733,1,0,0,0,3733,3734,1,0,0,0,3734,3735,5,203,0,0,
  	3735,3736,5,204,0,0,3736,553,1,0,0,0,3737,3738,5,23,0,0,3738,3739,5,194,
  	0,0,3739,3740,3,564,282,0,3740,3741,5,183,0,0,3741,3743,3,588,294,0,3742,
  	3744,3,520,260,0,3743,3742,1,0,0,0,3743,3744,1,0,0,0,3744,3745,1,0,0,
  	0,3745,3746,5,203,0,0,3746,3747,5,204,0,0,3747,555,1,0,0,0,3748,3749,
  	5,31,0,0,3749,3750,5,194,0,0,3750,3751,3,564,282,0,3751,3752,5,183,0,
  	0,3752,3754,3,588,294,0,3753,3755,3,558,279,0,3754,3753,1,0,0,0,3754,
  	3755,1,0,0,0,3755,3756,1,0,0,0,3756,3757,5,203,0,0,3757,3758,5,204,0,
  	0,3758,557,1,0,0,0,3759,3760,5,183,0,0,3760,3763,3,586,293,0,3761,3762,
  	5,183,0,0,3762,3764,3,576,288,0,3763,3761,1,0,0,0,3763,3764,1,0,0,0,3764,
  	559,1,0,0,0,3765,3766,5,22,0,0,3766,3767,5,194,0,0,3767,3768,3,578,289,
  	0,3768,3769,5,183,0,0,3769,3770,3,566,283,0,3770,3771,5,183,0,0,3771,
  	3772,3,584,292,0,3772,3773,5,183,0,0,3773,3775,3,572,286,0,3774,3776,
  	3,520,260,0,3775,3774,1,0,0,0,3775,3776,1,0,0,0,3776,3777,1,0,0,0,3777,
  	3778,5,203,0,0,3778,3779,5,204,0,0,3779,561,1,0,0,0,3780,3781,3,646,323,
  	0,3781,563,1,0,0,0,3782,3783,3,592,296,0,3783,565,1,0,0,0,3784,3785,3,
  	590,295,0,3785,567,1,0,0,0,3786,3791,3,780,390,0,3787,3788,5,192,0,0,
  	3788,3789,3,636,318,0,3789,3790,5,201,0,0,3790,3792,1,0,0,0,3791,3787,
  	1,0,0,0,3791,3792,1,0,0,0,3792,569,1,0,0,0,3793,3798,3,780,390,0,3794,
  	3795,5,192,0,0,3795,3796,3,636,318,0,3796,3797,5,201,0,0,3797,3799,1,
  	0,0,0,3798,3794,1,0,0,0,3798,3799,1,0,0,0,3799,571,1,0,0,0,3800,3801,
  	3,646,323,0,3801,573,1,0,0,0,3802,3803,3,634,317,0,3803,575,1,0,0,0,3804,
  	3805,3,788,394,0,3805,577,1,0,0,0,3806,3807,3,590,295,0,3807,579,1,0,
  	0,0,3808,3809,3,634,317,0,3809,581,1,0,0,0,3810,3811,3,646,323,0,3811,
  	583,1,0,0,0,3812,3813,3,646,323,0,3813,585,1,0,0,0,3814,3815,3,634,317,
  	0,3815,587,1,0,0,0,3816,3817,3,642,321,0,3817,589,1,0,0,0,3818,3820,3,
  	594,297,0,3819,3818,1,0,0,0,3819,3820,1,0,0,0,3820,3821,1,0,0,0,3821,
  	3824,3,596,298,0,3822,3823,5,155,0,0,3823,3825,3,602,301,0,3824,3822,
  	1,0,0,0,3824,3825,1,0,0,0,3825,591,1,0,0,0,3826,3827,3,594,297,0,3827,
  	3830,3,596,298,0,3828,3829,5,155,0,0,3829,3831,3,602,301,0,3830,3828,
  	1,0,0,0,3830,3831,1,0,0,0,3831,593,1,0,0,0,3832,3836,5,84,0,0,3833,3836,
  	5,72,0,0,3834,3836,3,598,299,0,3835,3832,1,0,0,0,3835,3833,1,0,0,0,3835,
  	3834,1,0,0,0,3836,595,1,0,0,0,3837,3840,3,456,228,0,3838,3840,3,458,229,
  	0,3839,3837,1,0,0,0,3839,3838,1,0,0,0,3840,597,1,0,0,0,3841,3842,5,32,
  	0,0,3842,3843,5,192,0,0,3843,3848,3,600,300,0,3844,3845,5,183,0,0,3845,
  	3847,3,600,300,0,3846,3844,1,0,0,0,3847,3850,1,0,0,0,3848,3846,1,0,0,
  	0,3848,3849,1,0,0,0,3849,3851,1,0,0,0,3850,3848,1,0,0,0,3851,3852,5,201,
  	0,0,3852,599,1,0,0,0,3853,3854,5,224,0,0,3854,601,1,0,0,0,3855,3861,3,
  	604,302,0,3856,3857,5,194,0,0,3857,3858,3,604,302,0,3858,3859,5,203,0,
  	0,3859,3861,1,0,0,0,3860,3855,1,0,0,0,3860,3856,1,0,0,0,3861,603,1,0,
  	0,0,3862,3882,3,642,321,0,3863,3864,5,206,0,0,3864,3882,3,642,321,0,3865,
  	3866,3,642,321,0,3866,3867,5,166,0,0,3867,3868,3,606,303,0,3868,3882,
  	1,0,0,0,3869,3870,3,642,321,0,3870,3871,5,157,0,0,3871,3872,3,606,303,
  	0,3872,3882,1,0,0,0,3873,3874,3,642,321,0,3874,3875,5,169,0,0,3875,3876,
  	3,606,303,0,3876,3882,1,0,0,0,3877,3878,3,642,321,0,3878,3879,5,156,0,
  	0,3879,3880,3,606,303,0,3880,3882,1,0,0,0,3881,3862,1,0,0,0,3881,3863,
  	1,0,0,0,3881,3865,1,0,0,0,3881,3869,1,0,0,0,3881,3873,1,0,0,0,3881,3877,
  	1,0,0,0,3882,605,1,0,0,0,3883,3886,3,686,343,0,3884,3886,3,700,350,0,
  	3885,3883,1,0,0,0,3885,3884,1,0,0,0,3886,607,1,0,0,0,3887,3888,5,193,
  	0,0,3888,3893,3,642,321,0,3889,3890,5,183,0,0,3890,3892,3,642,321,0,3891,
  	3889,1,0,0,0,3892,3895,1,0,0,0,3893,3891,1,0,0,0,3893,3894,1,0,0,0,3894,
  	3896,1,0,0,0,3895,3893,1,0,0,0,3896,3897,5,202,0,0,3897,609,1,0,0,0,3898,
  	3899,5,193,0,0,3899,3904,3,634,317,0,3900,3901,5,183,0,0,3901,3903,3,
  	634,317,0,3902,3900,1,0,0,0,3903,3906,1,0,0,0,3904,3902,1,0,0,0,3904,
  	3905,1,0,0,0,3905,3907,1,0,0,0,3906,3904,1,0,0,0,3907,3908,5,202,0,0,
  	3908,611,1,0,0,0,3909,3910,5,193,0,0,3910,3911,3,634,317,0,3911,3912,
  	3,610,305,0,3912,3913,5,202,0,0,3913,613,1,0,0,0,3914,3915,5,193,0,0,
  	3915,3920,3,648,324,0,3916,3917,5,183,0,0,3917,3919,3,648,324,0,3918,
  	3916,1,0,0,0,3919,3922,1,0,0,0,3920,3918,1,0,0,0,3920,3921,1,0,0,0,3921,
  	3923,1,0,0,0,3922,3920,1,0,0,0,3923,3924,5,202,0,0,3924,615,1,0,0,0,3925,
  	3926,5,193,0,0,3926,3927,3,634,317,0,3927,3928,3,614,307,0,3928,3929,
  	5,202,0,0,3929,617,1,0,0,0,3930,3931,5,193,0,0,3931,3932,3,634,317,0,
  	3932,3933,3,608,304,0,3933,3934,5,202,0,0,3934,619,1,0,0,0,3935,3939,
  	3,736,368,0,3936,3938,3,720,360,0,3937,3936,1,0,0,0,3938,3941,1,0,0,0,
  	3939,3937,1,0,0,0,3939,3940,1,0,0,0,3940,3942,1,0,0,0,3941,3939,1,0,0,
  	0,3942,3943,5,194,0,0,3943,3948,3,634,317,0,3944,3945,5,183,0,0,3945,
  	3947,3,634,317,0,3946,3944,1,0,0,0,3947,3950,1,0,0,0,3948,3946,1,0,0,
  	0,3948,3949,1,0,0,0,3949,3951,1,0,0,0,3950,3948,1,0,0,0,3951,3952,5,203,
  	0,0,3952,621,1,0,0,0,3953,3954,3,774,387,0,3954,3955,5,194,0,0,3955,3960,
  	3,634,317,0,3956,3957,5,183,0,0,3957,3959,3,634,317,0,3958,3956,1,0,0,
  	0,3959,3962,1,0,0,0,3960,3958,1,0,0,0,3960,3961,1,0,0,0,3961,3963,1,0,
  	0,0,3962,3960,1,0,0,0,3963,3964,5,203,0,0,3964,623,1,0,0,0,3965,3969,
  	3,744,372,0,3966,3968,3,720,360,0,3967,3966,1,0,0,0,3968,3971,1,0,0,0,
  	3969,3967,1,0,0,0,3969,3970,1,0,0,0,3970,3972,1,0,0,0,3971,3969,1,0,0,
  	0,3972,3973,5,194,0,0,3973,3978,3,642,321,0,3974,3975,5,183,0,0,3975,
  	3977,3,642,321,0,3976,3974,1,0,0,0,3977,3980,1,0,0,0,3978,3976,1,0,0,
  	0,3978,3979,1,0,0,0,3979,3981,1,0,0,0,3980,3978,1,0,0,0,3981,3982,5,203,
  	0,0,3982,625,1,0,0,0,3983,3985,3,774,387,0,3984,3986,3,628,314,0,3985,
  	3984,1,0,0,0,3985,3986,1,0,0,0,3986,627,1,0,0,0,3987,3988,5,194,0,0,3988,
  	3993,3,642,321,0,3989,3990,5,183,0,0,3990,3992,3,642,321,0,3991,3989,
  	1,0,0,0,3992,3995,1,0,0,0,3993,3991,1,0,0,0,3993,3994,1,0,0,0,3994,3996,
  	1,0,0,0,3995,3993,1,0,0,0,3996,3997,5,203,0,0,3997,629,1,0,0,0,3998,3999,
  	3,642,321,0,3999,631,1,0,0,0,4000,4001,3,634,317,0,4001,633,1,0,0,0,4002,
  	4003,6,317,-1,0,4003,4014,3,658,329,0,4004,4008,3,676,338,0,4005,4007,
  	3,720,360,0,4006,4005,1,0,0,0,4007,4010,1,0,0,0,4008,4006,1,0,0,0,4008,
  	4009,1,0,0,0,4009,4011,1,0,0,0,4010,4008,1,0,0,0,4011,4012,3,658,329,
  	0,4012,4014,1,0,0,0,4013,4002,1,0,0,0,4013,4004,1,0,0,0,4014,4128,1,0,
  	0,0,4015,4016,10,12,0,0,4016,4020,5,167,0,0,4017,4019,3,720,360,0,4018,
  	4017,1,0,0,0,4019,4022,1,0,0,0,4020,4018,1,0,0,0,4020,4021,1,0,0,0,4021,
  	4023,1,0,0,0,4022,4020,1,0,0,0,4023,4127,3,634,317,13,4024,4025,10,11,
  	0,0,4025,4029,7,17,0,0,4026,4028,3,720,360,0,4027,4026,1,0,0,0,4028,4031,
  	1,0,0,0,4029,4027,1,0,0,0,4029,4030,1,0,0,0,4030,4032,1,0,0,0,4031,4029,
  	1,0,0,0,4032,4127,3,634,317,12,4033,4034,10,10,0,0,4034,4038,7,16,0,0,
  	4035,4037,3,720,360,0,4036,4035,1,0,0,0,4037,4040,1,0,0,0,4038,4036,1,
  	0,0,0,4038,4039,1,0,0,0,4039,4041,1,0,0,0,4040,4038,1,0,0,0,4041,4127,
  	3,634,317,11,4042,4043,10,9,0,0,4043,4047,7,18,0,0,4044,4046,3,720,360,
  	0,4045,4044,1,0,0,0,4046,4049,1,0,0,0,4047,4045,1,0,0,0,4047,4048,1,0,
  	0,0,4048,4050,1,0,0,0,4049,4047,1,0,0,0,4050,4127,3,634,317,10,4051,4052,
  	10,8,0,0,4052,4056,7,19,0,0,4053,4055,3,720,360,0,4054,4053,1,0,0,0,4055,
  	4058,1,0,0,0,4056,4054,1,0,0,0,4056,4057,1,0,0,0,4057,4059,1,0,0,0,4058,
  	4056,1,0,0,0,4059,4127,3,634,317,9,4060,4061,10,7,0,0,4061,4065,7,20,
  	0,0,4062,4064,3,720,360,0,4063,4062,1,0,0,0,4064,4067,1,0,0,0,4065,4063,
  	1,0,0,0,4065,4066,1,0,0,0,4066,4068,1,0,0,0,4067,4065,1,0,0,0,4068,4127,
  	3,634,317,8,4069,4070,10,6,0,0,4070,4074,5,178,0,0,4071,4073,3,720,360,
  	0,4072,4071,1,0,0,0,4073,4076,1,0,0,0,4074,4072,1,0,0,0,4074,4075,1,0,
  	0,0,4075,4077,1,0,0,0,4076,4074,1,0,0,0,4077,4127,3,634,317,7,4078,4079,
  	10,5,0,0,4079,4083,7,21,0,0,4080,4082,3,720,360,0,4081,4080,1,0,0,0,4082,
  	4085,1,0,0,0,4083,4081,1,0,0,0,4083,4084,1,0,0,0,4084,4086,1,0,0,0,4085,
  	4083,1,0,0,0,4086,4127,3,634,317,6,4087,4088,10,4,0,0,4088,4092,5,177,
  	0,0,4089,4091,3,720,360,0,4090,4089,1,0,0,0,4091,4094,1,0,0,0,4092,4090,
  	1,0,0,0,4092,4093,1,0,0,0,4093,4095,1,0,0,0,4094,4092,1,0,0,0,4095,4127,
  	3,634,317,5,4096,4097,10,3,0,0,4097,4101,5,164,0,0,4098,4100,3,720,360,
  	0,4099,4098,1,0,0,0,4100,4103,1,0,0,0,4101,4099,1,0,0,0,4101,4102,1,0,
  	0,0,4102,4104,1,0,0,0,4103,4101,1,0,0,0,4104,4127,3,634,317,4,4105,4106,
  	10,2,0,0,4106,4110,5,176,0,0,4107,4109,3,720,360,0,4108,4107,1,0,0,0,
  	4109,4112,1,0,0,0,4110,4108,1,0,0,0,4110,4111,1,0,0,0,4111,4113,1,0,0,
  	0,4112,4110,1,0,0,0,4113,4127,3,634,317,3,4114,4115,10,1,0,0,4115,4119,
  	5,200,0,0,4116,4118,3,720,360,0,4117,4116,1,0,0,0,4118,4121,1,0,0,0,4119,
  	4117,1,0,0,0,4119,4120,1,0,0,0,4120,4122,1,0,0,0,4121,4119,1,0,0,0,4122,
  	4123,3,634,317,0,4123,4124,5,182,0,0,4124,4125,3,634,317,1,4125,4127,
  	1,0,0,0,4126,4015,1,0,0,0,4126,4024,1,0,0,0,4126,4033,1,0,0,0,4126,4042,
  	1,0,0,0,4126,4051,1,0,0,0,4126,4060,1,0,0,0,4126,4069,1,0,0,0,4126,4078,
  	1,0,0,0,4126,4087,1,0,0,0,4126,4096,1,0,0,0,4126,4105,1,0,0,0,4126,4114,
  	1,0,0,0,4127,4130,1,0,0,0,4128,4126,1,0,0,0,4128,4129,1,0,0,0,4129,635,
  	1,0,0,0,4130,4128,1,0,0,0,4131,4137,3,634,317,0,4132,4133,5,182,0,0,4133,
  	4134,3,634,317,0,4134,4135,5,182,0,0,4135,4136,3,634,317,0,4136,4138,
  	1,0,0,0,4137,4132,1,0,0,0,4137,4138,1,0,0,0,4138,637,1,0,0,0,4139,4153,
  	3,634,317,0,4140,4141,3,652,326,0,4141,4142,5,182,0,0,4142,4143,3,644,
  	322,0,4143,4153,1,0,0,0,4144,4145,3,632,316,0,4145,4146,5,199,0,0,4146,
  	4147,3,656,328,0,4147,4153,1,0,0,0,4148,4149,3,632,316,0,4149,4150,5,
  	160,0,0,4150,4151,3,656,328,0,4151,4153,1,0,0,0,4152,4139,1,0,0,0,4152,
  	4140,1,0,0,0,4152,4144,1,0,0,0,4152,4148,1,0,0,0,4153,639,1,0,0,0,4154,
  	4155,3,634,317,0,4155,641,1,0,0,0,4156,4157,6,321,-1,0,4157,4168,3,662,
  	331,0,4158,4162,3,676,338,0,4159,4161,3,720,360,0,4160,4159,1,0,0,0,4161,
  	4164,1,0,0,0,4162,4160,1,0,0,0,4162,4163,1,0,0,0,4163,4165,1,0,0,0,4164,
  	4162,1,0,0,0,4165,4166,3,662,331,0,4166,4168,1,0,0,0,4167,4156,1,0,0,
  	0,4167,4158,1,0,0,0,4168,4282,1,0,0,0,4169,4170,10,12,0,0,4170,4174,5,
  	167,0,0,4171,4173,3,720,360,0,4172,4171,1,0,0,0,4173,4176,1,0,0,0,4174,
  	4172,1,0,0,0,4174,4175,1,0,0,0,4175,4177,1,0,0,0,4176,4174,1,0,0,0,4177,
  	4281,3,642,321,13,4178,4179,10,11,0,0,4179,4183,7,17,0,0,4180,4182,3,
  	720,360,0,4181,4180,1,0,0,0,4182,4185,1,0,0,0,4183,4181,1,0,0,0,4183,
  	4184,1,0,0,0,4184,4186,1,0,0,0,4185,4183,1,0,0,0,4186,4281,3,642,321,
  	12,4187,4188,10,10,0,0,4188,4192,7,16,0,0,4189,4191,3,720,360,0,4190,
  	4189,1,0,0,0,4191,4194,1,0,0,0,4192,4190,1,0,0,0,4192,4193,1,0,0,0,4193,
  	4195,1,0,0,0,4194,4192,1,0,0,0,4195,4281,3,642,321,11,4196,4197,10,9,
  	0,0,4197,4201,7,18,0,0,4198,4200,3,720,360,0,4199,4198,1,0,0,0,4200,4203,
  	1,0,0,0,4201,4199,1,0,0,0,4201,4202,1,0,0,0,4202,4204,1,0,0,0,4203,4201,
  	1,0,0,0,4204,4281,3,642,321,10,4205,4206,10,8,0,0,4206,4210,7,19,0,0,
  	4207,4209,3,720,360,0,4208,4207,1,0,0,0,4209,4212,1,0,0,0,4210,4208,1,
  	0,0,0,4210,4211,1,0,0,0,4211,4213,1,0,0,0,4212,4210,1,0,0,0,4213,4281,
  	3,642,321,9,4214,4215,10,7,0,0,4215,4219,7,20,0,0,4216,4218,3,720,360,
  	0,4217,4216,1,0,0,0,4218,4221,1,0,0,0,4219,4217,1,0,0,0,4219,4220,1,0,
  	0,0,4220,4222,1,0,0,0,4221,4219,1,0,0,0,4222,4281,3,642,321,8,4223,4224,
  	10,6,0,0,4224,4228,5,178,0,0,4225,4227,3,720,360,0,4226,4225,1,0,0,0,
  	4227,4230,1,0,0,0,4228,4226,1,0,0,0,4228,4229,1,0,0,0,4229,4231,1,0,0,
  	0,4230,4228,1,0,0,0,4231,4281,3,642,321,7,4232,4233,10,5,0,0,4233,4237,
  	7,21,0,0,4234,4236,3,720,360,0,4235,4234,1,0,0,0,4236,4239,1,0,0,0,4237,
  	4235,1,0,0,0,4237,4238,1,0,0,0,4238,4240,1,0,0,0,4239,4237,1,0,0,0,4240,
  	4281,3,642,321,6,4241,4242,10,4,0,0,4242,4246,5,177,0,0,4243,4245,3,720,
  	360,0,4244,4243,1,0,0,0,4245,4248,1,0,0,0,4246,4244,1,0,0,0,4246,4247,
  	1,0,0,0,4247,4249,1,0,0,0,4248,4246,1,0,0,0,4249,4281,3,642,321,5,4250,
  	4251,10,3,0,0,4251,4255,5,164,0,0,4252,4254,3,720,360,0,4253,4252,1,0,
  	0,0,4254,4257,1,0,0,0,4255,4253,1,0,0,0,4255,4256,1,0,0,0,4256,4258,1,
  	0,0,0,4257,4255,1,0,0,0,4258,4281,3,642,321,4,4259,4260,10,2,0,0,4260,
  	4264,5,176,0,0,4261,4263,3,720,360,0,4262,4261,1,0,0,0,4263,4266,1,0,
  	0,0,4264,4262,1,0,0,0,4264,4265,1,0,0,0,4265,4267,1,0,0,0,4266,4264,1,
  	0,0,0,4267,4281,3,642,321,3,4268,4269,10,1,0,0,4269,4273,5,200,0,0,4270,
  	4272,3,720,360,0,4271,4270,1,0,0,0,4272,4275,1,0,0,0,4273,4271,1,0,0,
  	0,4273,4274,1,0,0,0,4274,4276,1,0,0,0,4275,4273,1,0,0,0,4276,4277,3,642,
  	321,0,4277,4278,5,182,0,0,4278,4279,3,642,321,1,4279,4281,1,0,0,0,4280,
  	4169,1,0,0,0,4280,4178,1,0,0,0,4280,4187,1,0,0,0,4280,4196,1,0,0,0,4280,
  	4205,1,0,0,0,4280,4214,1,0,0,0,4280,4223,1,0,0,0,4280,4232,1,0,0,0,4280,
  	4241,1,0,0,0,4280,4250,1,0,0,0,4280,4259,1,0,0,0,4280,4268,1,0,0,0,4281,
  	4284,1,0,0,0,4282,4280,1,0,0,0,4282,4283,1,0,0,0,4283,643,1,0,0,0,4284,
  	4282,1,0,0,0,4285,4286,3,634,317,0,4286,645,1,0,0,0,4287,4293,3,642,321,
  	0,4288,4289,5,182,0,0,4289,4290,3,642,321,0,4290,4291,5,182,0,0,4291,
  	4292,3,642,321,0,4292,4294,1,0,0,0,4293,4288,1,0,0,0,4293,4294,1,0,0,
  	0,4294,647,1,0,0,0,4295,4296,6,324,-1,0,4296,4307,3,660,330,0,4297,4301,
  	3,678,339,0,4298,4300,3,720,360,0,4299,4298,1,0,0,0,4300,4303,1,0,0,0,
  	4301,4299,1,0,0,0,4301,4302,1,0,0,0,4302,4304,1,0,0,0,4303,4301,1,0,0,
  	0,4304,4305,3,660,330,0,4305,4307,1,0,0,0,4306,4295,1,0,0,0,4306,4297,
  	1,0,0,0,4307,4376,1,0,0,0,4308,4309,10,7,0,0,4309,4313,7,22,0,0,4310,
  	4312,3,720,360,0,4311,4310,1,0,0,0,4312,4315,1,0,0,0,4313,4311,1,0,0,
  	0,4313,4314,1,0,0,0,4314,4316,1,0,0,0,4315,4313,1,0,0,0,4316,4375,3,648,
  	324,8,4317,4318,10,6,0,0,4318,4322,5,178,0,0,4319,4321,3,720,360,0,4320,
  	4319,1,0,0,0,4321,4324,1,0,0,0,4322,4320,1,0,0,0,4322,4323,1,0,0,0,4323,
  	4325,1,0,0,0,4324,4322,1,0,0,0,4325,4375,3,648,324,7,4326,4327,10,5,0,
  	0,4327,4331,7,21,0,0,4328,4330,3,720,360,0,4329,4328,1,0,0,0,4330,4333,
  	1,0,0,0,4331,4329,1,0,0,0,4331,4332,1,0,0,0,4332,4334,1,0,0,0,4333,4331,
  	1,0,0,0,4334,4375,3,648,324,6,4335,4336,10,4,0,0,4336,4340,5,177,0,0,
  	4337,4339,3,720,360,0,4338,4337,1,0,0,0,4339,4342,1,0,0,0,4340,4338,1,
  	0,0,0,4340,4341,1,0,0,0,4341,4343,1,0,0,0,4342,4340,1,0,0,0,4343,4375,
  	3,648,324,5,4344,4345,10,3,0,0,4345,4349,5,164,0,0,4346,4348,3,720,360,
  	0,4347,4346,1,0,0,0,4348,4351,1,0,0,0,4349,4347,1,0,0,0,4349,4350,1,0,
  	0,0,4350,4352,1,0,0,0,4351,4349,1,0,0,0,4352,4375,3,648,324,4,4353,4354,
  	10,2,0,0,4354,4358,5,176,0,0,4355,4357,3,720,360,0,4356,4355,1,0,0,0,
  	4357,4360,1,0,0,0,4358,4356,1,0,0,0,4358,4359,1,0,0,0,4359,4361,1,0,0,
  	0,4360,4358,1,0,0,0,4361,4375,3,648,324,3,4362,4363,10,1,0,0,4363,4367,
  	5,200,0,0,4364,4366,3,720,360,0,4365,4364,1,0,0,0,4366,4369,1,0,0,0,4367,
  	4365,1,0,0,0,4367,4368,1,0,0,0,4368,4370,1,0,0,0,4369,4367,1,0,0,0,4370,
  	4371,3,648,324,0,4371,4372,5,182,0,0,4372,4373,3,648,324,1,4373,4375,
  	1,0,0,0,4374,4308,1,0,0,0,4374,4317,1,0,0,0,4374,4326,1,0,0,0,4374,4335,
  	1,0,0,0,4374,4344,1,0,0,0,4374,4353,1,0,0,0,4374,4362,1,0,0,0,4375,4378,
  	1,0,0,0,4376,4374,1,0,0,0,4376,4377,1,0,0,0,4377,649,1,0,0,0,4378,4376,
  	1,0,0,0,4379,4385,3,648,324,0,4380,4381,5,182,0,0,4381,4382,3,648,324,
  	0,4382,4383,5,182,0,0,4383,4384,3,648,324,0,4384,4386,1,0,0,0,4385,4380,
  	1,0,0,0,4385,4386,1,0,0,0,4386,651,1,0,0,0,4387,4388,3,634,317,0,4388,
  	653,1,0,0,0,4389,4403,3,642,321,0,4390,4391,3,652,326,0,4391,4392,5,182,
  	0,0,4392,4393,3,644,322,0,4393,4403,1,0,0,0,4394,4395,3,630,315,0,4395,
  	4396,5,199,0,0,4396,4397,3,656,328,0,4397,4403,1,0,0,0,4398,4399,3,630,
  	315,0,4399,4400,5,160,0,0,4400,4401,3,656,328,0,4401,4403,1,0,0,0,4402,
  	4389,1,0,0,0,4402,4390,1,0,0,0,4402,4394,1,0,0,0,4402,4398,1,0,0,0,4403,
  	655,1,0,0,0,4404,4405,3,634,317,0,4405,657,1,0,0,0,4406,4424,3,680,340,
  	0,4407,4412,3,748,374,0,4408,4409,5,192,0,0,4409,4410,3,638,319,0,4410,
  	4411,5,201,0,0,4411,4413,1,0,0,0,4412,4408,1,0,0,0,4412,4413,1,0,0,0,
  	4413,4424,1,0,0,0,4414,4424,3,610,305,0,4415,4424,3,612,306,0,4416,4424,
  	3,620,310,0,4417,4424,3,622,311,0,4418,4419,5,194,0,0,4419,4420,3,636,
  	318,0,4420,4421,5,203,0,0,4421,4424,1,0,0,0,4422,4424,3,718,359,0,4423,
  	4406,1,0,0,0,4423,4407,1,0,0,0,4423,4414,1,0,0,0,4423,4415,1,0,0,0,4423,
  	4416,1,0,0,0,4423,4417,1,0,0,0,4423,4418,1,0,0,0,4423,4422,1,0,0,0,4424,
  	659,1,0,0,0,4425,4436,3,680,340,0,4426,4436,3,748,374,0,4427,4436,3,614,
  	307,0,4428,4436,3,616,308,0,4429,4436,3,624,312,0,4430,4436,3,626,313,
  	0,4431,4432,5,194,0,0,4432,4433,3,650,325,0,4433,4434,5,203,0,0,4434,
  	4436,1,0,0,0,4435,4425,1,0,0,0,4435,4426,1,0,0,0,4435,4427,1,0,0,0,4435,
  	4428,1,0,0,0,4435,4429,1,0,0,0,4435,4430,1,0,0,0,4435,4431,1,0,0,0,4436,
  	661,1,0,0,0,4437,4452,3,680,340,0,4438,4440,3,744,372,0,4439,4441,3,664,
  	332,0,4440,4439,1,0,0,0,4440,4441,1,0,0,0,4441,4452,1,0,0,0,4442,4452,
  	3,608,304,0,4443,4452,3,618,309,0,4444,4452,3,624,312,0,4445,4452,3,626,
  	313,0,4446,4447,5,194,0,0,4447,4448,3,646,323,0,4448,4449,5,203,0,0,4449,
  	4452,1,0,0,0,4450,4452,3,718,359,0,4451,4437,1,0,0,0,4451,4438,1,0,0,
  	0,4451,4442,1,0,0,0,4451,4443,1,0,0,0,4451,4444,1,0,0,0,4451,4445,1,0,
  	0,0,4451,4446,1,0,0,0,4451,4450,1,0,0,0,4452,663,1,0,0,0,4453,4455,3,
  	666,333,0,4454,4453,1,0,0,0,4454,4455,1,0,0,0,4455,4456,1,0,0,0,4456,
  	4457,5,192,0,0,4457,4458,3,654,327,0,4458,4459,5,201,0,0,4459,665,1,0,
  	0,0,4460,4461,5,192,0,0,4461,4462,3,642,321,0,4462,4463,5,201,0,0,4463,
  	4465,1,0,0,0,4464,4460,1,0,0,0,4465,4466,1,0,0,0,4466,4464,1,0,0,0,4466,
  	4467,1,0,0,0,4467,667,1,0,0,0,4468,4470,3,744,372,0,4469,4471,3,670,335,
  	0,4470,4469,1,0,0,0,4470,4471,1,0,0,0,4471,4484,1,0,0,0,4472,4473,5,193,
  	0,0,4473,4478,3,668,334,0,4474,4475,5,183,0,0,4475,4477,3,668,334,0,4476,
  	4474,1,0,0,0,4477,4480,1,0,0,0,4478,4476,1,0,0,0,4478,4479,1,0,0,0,4479,
  	4481,1,0,0,0,4480,4478,1,0,0,0,4481,4482,5,202,0,0,4482,4484,1,0,0,0,
  	4483,4468,1,0,0,0,4483,4472,1,0,0,0,4484,669,1,0,0,0,4485,4487,3,672,
  	336,0,4486,4485,1,0,0,0,4486,4487,1,0,0,0,4487,4488,1,0,0,0,4488,4489,
  	5,192,0,0,4489,4490,3,638,319,0,4490,4491,5,201,0,0,4491,671,1,0,0,0,
  	4492,4493,5,192,0,0,4493,4494,3,634,317,0,4494,4495,5,201,0,0,4495,4497,
  	1,0,0,0,4496,4492,1,0,0,0,4497,4498,1,0,0,0,4498,4496,1,0,0,0,4498,4499,
  	1,0,0,0,4499,673,1,0,0,0,4500,4502,3,744,372,0,4501,4503,3,664,332,0,
  	4502,4501,1,0,0,0,4502,4503,1,0,0,0,4503,4516,1,0,0,0,4504,4505,5,193,
  	0,0,4505,4510,3,674,337,0,4506,4507,5,183,0,0,4507,4509,3,674,337,0,4508,
  	4506,1,0,0,0,4509,4512,1,0,0,0,4510,4508,1,0,0,0,4510,4511,1,0,0,0,4511,
  	4513,1,0,0,0,4512,4510,1,0,0,0,4513,4514,5,202,0,0,4514,4516,1,0,0,0,
  	4515,4500,1,0,0,0,4515,4504,1,0,0,0,4516,675,1,0,0,0,4517,4518,7,23,0,
  	0,4518,677,1,0,0,0,4519,4520,7,24,0,0,4520,679,1,0,0,0,4521,4527,3,684,
  	342,0,4522,4527,3,688,344,0,4523,4527,3,686,343,0,4524,4527,3,690,345,
  	0,4525,4527,3,682,341,0,4526,4521,1,0,0,0,4526,4522,1,0,0,0,4526,4523,
  	1,0,0,0,4526,4524,1,0,0,0,4526,4525,1,0,0,0,4527,681,1,0,0,0,4528,4532,
  	3,694,347,0,4529,4532,3,698,349,0,4530,4532,3,696,348,0,4531,4528,1,0,
  	0,0,4531,4529,1,0,0,0,4531,4530,1,0,0,0,4532,683,1,0,0,0,4533,4541,3,
  	700,350,0,4534,4536,3,692,346,0,4535,4534,1,0,0,0,4535,4536,1,0,0,0,4536,
  	4537,1,0,0,0,4537,4538,3,710,355,0,4538,4539,3,702,351,0,4539,4541,1,
  	0,0,0,4540,4533,1,0,0,0,4540,4535,1,0,0,0,4541,685,1,0,0,0,4542,4544,
  	3,692,346,0,4543,4542,1,0,0,0,4543,4544,1,0,0,0,4544,4545,1,0,0,0,4545,
  	4546,3,712,356,0,4546,4547,3,704,352,0,4547,687,1,0,0,0,4548,4550,3,692,
  	346,0,4549,4548,1,0,0,0,4549,4550,1,0,0,0,4550,4551,1,0,0,0,4551,4552,
  	3,714,357,0,4552,4553,3,706,353,0,4553,689,1,0,0,0,4554,4556,3,692,346,
  	0,4555,4554,1,0,0,0,4555,4556,1,0,0,0,4556,4557,1,0,0,0,4557,4558,3,716,
  	358,0,4558,4559,3,708,354,0,4559,691,1,0,0,0,4560,4561,5,219,0,0,4561,
  	693,1,0,0,0,4562,4563,5,212,0,0,4563,695,1,0,0,0,4564,4565,5,220,0,0,
  	4565,697,1,0,0,0,4566,4567,5,211,0,0,4567,699,1,0,0,0,4568,4569,5,219,
  	0,0,4569,701,1,0,0,0,4570,4571,7,25,0,0,4571,703,1,0,0,0,4572,4573,5,
  	222,0,0,4573,705,1,0,0,0,4574,4575,5,227,0,0,4575,707,1,0,0,0,4576,4577,
  	5,225,0,0,4577,709,1,0,0,0,4578,4579,5,209,0,0,4579,711,1,0,0,0,4580,
  	4581,5,207,0,0,4581,713,1,0,0,0,4582,4583,5,215,0,0,4583,715,1,0,0,0,
  	4584,4585,5,213,0,0,4585,717,1,0,0,0,4586,4587,5,217,0,0,4587,719,1,0,
  	0,0,4588,4589,5,194,0,0,4589,4590,5,179,0,0,4590,4595,3,722,361,0,4591,
  	4592,5,183,0,0,4592,4594,3,722,361,0,4593,4591,1,0,0,0,4594,4597,1,0,
  	0,0,4595,4593,1,0,0,0,4595,4596,1,0,0,0,4596,4598,1,0,0,0,4597,4595,1,
  	0,0,0,4598,4599,5,179,0,0,4599,4600,5,203,0,0,4600,721,1,0,0,0,4601,4604,
  	3,724,362,0,4602,4603,5,188,0,0,4603,4605,3,634,317,0,4604,4602,1,0,0,
  	0,4604,4605,1,0,0,0,4605,723,1,0,0,0,4606,4607,3,748,374,0,4607,725,1,
  	0,0,0,4608,4609,3,748,374,0,4609,727,1,0,0,0,4610,4611,3,748,374,0,4611,
  	729,1,0,0,0,4612,4613,3,748,374,0,4613,731,1,0,0,0,4614,4615,5,210,0,
  	0,4615,733,1,0,0,0,4616,4617,3,748,374,0,4617,735,1,0,0,0,4618,4619,3,
  	748,374,0,4619,737,1,0,0,0,4620,4621,3,748,374,0,4621,739,1,0,0,0,4622,
  	4623,3,748,374,0,4623,741,1,0,0,0,4624,4625,3,748,374,0,4625,743,1,0,
  	0,0,4626,4628,3,746,373,0,4627,4626,1,0,0,0,4628,4631,1,0,0,0,4629,4627,
  	1,0,0,0,4629,4630,1,0,0,0,4630,4632,1,0,0,0,4631,4629,1,0,0,0,4632,4633,
  	3,748,374,0,4633,745,1,0,0,0,4634,4636,3,748,374,0,4635,4637,3,672,336,
  	0,4636,4635,1,0,0,0,4636,4637,1,0,0,0,4637,4638,1,0,0,0,4638,4639,5,186,
  	0,0,4639,747,1,0,0,0,4640,4644,3,732,366,0,4641,4644,3,770,385,0,4642,
  	4644,5,265,0,0,4643,4640,1,0,0,0,4643,4641,1,0,0,0,4643,4642,1,0,0,0,
  	4644,749,1,0,0,0,4645,4646,3,748,374,0,4646,751,1,0,0,0,4647,4648,3,748,
  	374,0,4648,753,1,0,0,0,4649,4650,3,748,374,0,4650,755,1,0,0,0,4651,4652,
  	3,748,374,0,4652,757,1,0,0,0,4653,4654,3,748,374,0,4654,759,1,0,0,0,4655,
  	4656,3,748,374,0,4656,761,1,0,0,0,4657,4658,3,748,374,0,4658,763,1,0,
  	0,0,4659,4660,3,748,374,0,4660,765,1,0,0,0,4661,4662,3,748,374,0,4662,
  	767,1,0,0,0,4663,4664,3,748,374,0,4664,769,1,0,0,0,4665,4666,5,216,0,
  	0,4666,771,1,0,0,0,4667,4668,3,748,374,0,4668,773,1,0,0,0,4669,4670,5,
  	218,0,0,4670,775,1,0,0,0,4671,4672,5,218,0,0,4672,777,1,0,0,0,4673,4674,
  	3,748,374,0,4674,779,1,0,0,0,4675,4676,3,748,374,0,4676,781,1,0,0,0,4677,
  	4678,3,748,374,0,4678,783,1,0,0,0,4679,4680,3,748,374,0,4680,785,1,0,
  	0,0,4681,4682,3,748,374,0,4682,787,1,0,0,0,4683,4684,3,748,374,0,4684,
  	789,1,0,0,0,478,793,801,810,814,824,836,846,851,857,860,866,879,888,894,
  	914,948,959,970,981,995,998,1001,1009,1020,1025,1032,1037,1044,1051,1055,
  	1066,1075,1080,1085,1092,1101,1108,1115,1122,1129,1136,1143,1150,1157,
  	1164,1168,1180,1193,1202,1210,1234,1246,1253,1261,1268,1273,1277,1280,
  	1287,1291,1294,1301,1305,1314,1317,1320,1326,1329,1332,1338,1341,1344,
  	1350,1353,1360,1372,1375,1382,1385,1388,1395,1398,1402,1409,1412,1415,
  	1419,1426,1429,1432,1439,1442,1445,1452,1455,1458,1462,1469,1472,1475,
  	1479,1484,1496,1499,1520,1527,1533,1540,1578,1593,1604,1606,1610,1619,
  	1623,1628,1635,1643,1650,1658,1666,1673,1681,1689,1697,1705,1713,1721,
  	1727,1746,1754,1767,1771,1793,1796,1803,1810,1813,1823,1829,1835,1841,
  	1848,1854,1862,1868,1872,1879,1887,1892,1899,1905,1911,1920,1929,1935,
  	1942,1948,1955,1962,1966,1970,1973,1976,1983,1987,1990,1993,2000,2004,
  	2007,2010,2017,2024,2029,2032,2040,2050,2060,2070,2080,2087,2096,2102,
  	2109,2117,2124,2131,2136,2143,2150,2153,2160,2167,2174,2181,2184,2191,
  	2198,2201,2208,2215,2222,2233,2240,2247,2254,2261,2266,2269,2282,2293,
  	2304,2314,2320,2328,2336,2345,2356,2364,2382,2400,2430,2437,2452,2460,
  	2463,2471,2482,2489,2497,2500,2505,2509,2514,2521,2529,2543,2568,2577,
  	2586,2595,2603,2606,2611,2616,2620,2627,2632,2644,2652,2664,2673,2683,
  	2695,2700,2708,2716,2718,2723,2732,2740,2746,2756,2762,2774,2785,2790,
  	2795,2802,2811,2817,2827,2830,2837,2843,2853,2860,2864,2867,2877,2896,
  	2903,2910,2922,2933,2936,2941,2954,2957,2962,2970,2979,2986,2993,3000,
  	3007,3014,3023,3032,3039,3048,3055,3062,3069,3076,3080,3086,3090,3101,
  	3111,3130,3135,3145,3153,3155,3160,3178,3187,3198,3209,3213,3220,3228,
  	3231,3257,3261,3271,3277,3281,3291,3300,3310,3320,3330,3341,3351,3356,
  	3365,3376,3384,3392,3399,3410,3418,3444,3446,3490,3494,3501,3510,3517,
  	3542,3558,3568,3575,3585,3600,3607,3610,3614,3617,3621,3624,3628,3631,
  	3635,3645,3658,3673,3686,3699,3706,3709,3713,3716,3720,3732,3743,3754,
  	3763,3775,3791,3798,3819,3824,3830,3835,3839,3848,3860,3881,3885,3893,
  	3904,3920,3939,3948,3960,3969,3978,3985,3993,4008,4013,4020,4029,4038,
  	4047,4056,4065,4074,4083,4092,4101,4110,4119,4126,4128,4137,4152,4162,
  	4167,4174,4183,4192,4201,4210,4219,4228,4237,4246,4255,4264,4273,4280,
  	4282,4293,4301,4306,4313,4322,4331,4340,4349,4358,4367,4374,4376,4385,
  	4402,4412,4423,4435,4440,4451,4454,4466,4470,4478,4483,4486,4498,4502,
  	4510,4515,4526,4531,4535,4540,4543,4549,4555,4595,4604,4629,4636,4643
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  verilogparserParserStaticData = std::move(staticData);
}

}

VerilogParser::VerilogParser(TokenStream *input) : VerilogParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

VerilogParser::VerilogParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  VerilogParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *verilogparserParserStaticData->atn, verilogparserParserStaticData->decisionToDFA, verilogparserParserStaticData->sharedContextCache, options);
}

VerilogParser::~VerilogParser() {
  delete _interpreter;
}

const atn::ATN& VerilogParser::getATN() const {
  return *verilogparserParserStaticData->atn;
}

std::string VerilogParser::getGrammarFileName() const {
  return "VerilogParser.g4";
}

const std::vector<std::string>& VerilogParser::getRuleNames() const {
  return verilogparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& VerilogParser::getVocabulary() const {
  return verilogparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView VerilogParser::getSerializedATN() const {
  return verilogparserParserStaticData->serializedATN;
}


//----------------- Library_textContext ------------------------------------------------------------------

VerilogParser::Library_textContext::Library_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::Library_descriptionContext *> VerilogParser::Library_textContext::library_description() {
  return getRuleContexts<VerilogParser::Library_descriptionContext>();
}

VerilogParser::Library_descriptionContext* VerilogParser::Library_textContext::library_description(size_t i) {
  return getRuleContext<VerilogParser::Library_descriptionContext>(i);
}


size_t VerilogParser::Library_textContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_text;
}


std::any VerilogParser::Library_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_textContext* VerilogParser::library_text() {
  Library_textContext *_localctx = _tracker.createInstance<Library_textContext>(_ctx, getState());
  enterRule(_localctx, 0, VerilogParser::RuleLibrary_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(793);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 14) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 14)) & 2256197860196353) != 0)) {
      setState(790);
      library_description();
      setState(795);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(796);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_descriptionContext ------------------------------------------------------------------

VerilogParser::Library_descriptionContext::Library_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Library_declarationContext* VerilogParser::Library_descriptionContext::library_declaration() {
  return getRuleContext<VerilogParser::Library_declarationContext>(0);
}

VerilogParser::Include_statementContext* VerilogParser::Library_descriptionContext::include_statement() {
  return getRuleContext<VerilogParser::Include_statementContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::Library_descriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}


size_t VerilogParser::Library_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_description;
}


std::any VerilogParser::Library_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_descriptionContext* VerilogParser::library_description() {
  Library_descriptionContext *_localctx = _tracker.createInstance<Library_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 2, VerilogParser::RuleLibrary_description);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LIBRARY: {
        enterOuterAlt(_localctx, 1);
        setState(798);
        library_declaration();
        break;
      }

      case VerilogParser::INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(799);
        include_statement();
        break;
      }

      case VerilogParser::CONFIG: {
        enterOuterAlt(_localctx, 3);
        setState(800);
        config_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_declarationContext ------------------------------------------------------------------

VerilogParser::Library_declarationContext::Library_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_declarationContext::LIBRARY() {
  return getToken(VerilogParser::LIBRARY, 0);
}

VerilogParser::Library_identifierContext* VerilogParser::Library_declarationContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_declarationContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_declarationContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_declarationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Library_incdirContext* VerilogParser::Library_declarationContext::library_incdir() {
  return getRuleContext<VerilogParser::Library_incdirContext>(0);
}


size_t VerilogParser::Library_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_declaration;
}


std::any VerilogParser::Library_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_declarationContext* VerilogParser::library_declaration() {
  Library_declarationContext *_localctx = _tracker.createInstance<Library_declarationContext>(_ctx, getState());
  enterRule(_localctx, 4, VerilogParser::RuleLibrary_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(803);
    match(VerilogParser::LIBRARY);
    setState(804);
    library_identifier();
    setState(805);
    file_path_spec();
    setState(810);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(806);
      match(VerilogParser::CO);
      setState(807);
      file_path_spec();
      setState(812);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(814);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MIINCDIR) {
      setState(813);
      library_incdir();
    }
    setState(816);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_incdirContext ------------------------------------------------------------------

VerilogParser::Library_incdirContext::Library_incdirContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_incdirContext::MIINCDIR() {
  return getToken(VerilogParser::MIINCDIR, 0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_incdirContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_incdirContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_incdirContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_incdirContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Library_incdirContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_incdir;
}


std::any VerilogParser::Library_incdirContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_incdir(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_incdirContext* VerilogParser::library_incdir() {
  Library_incdirContext *_localctx = _tracker.createInstance<Library_incdirContext>(_ctx, getState());
  enterRule(_localctx, 6, VerilogParser::RuleLibrary_incdir);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(818);
    match(VerilogParser::MIINCDIR);
    setState(819);
    file_path_spec();
    setState(824);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(820);
      match(VerilogParser::CO);
      setState(821);
      file_path_spec();
      setState(826);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_statementContext ------------------------------------------------------------------

VerilogParser::Include_statementContext::Include_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Include_statementContext::INCLUDE() {
  return getToken(VerilogParser::INCLUDE, 0);
}

VerilogParser::File_path_specContext* VerilogParser::Include_statementContext::file_path_spec() {
  return getRuleContext<VerilogParser::File_path_specContext>(0);
}

tree::TerminalNode* VerilogParser::Include_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Include_statementContext::getRuleIndex() const {
  return VerilogParser::RuleInclude_statement;
}


std::any VerilogParser::Include_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInclude_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Include_statementContext* VerilogParser::include_statement() {
  Include_statementContext *_localctx = _tracker.createInstance<Include_statementContext>(_ctx, getState());
  enterRule(_localctx, 8, VerilogParser::RuleInclude_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(827);
    match(VerilogParser::INCLUDE);
    setState(828);
    file_path_spec();
    setState(829);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_path_specContext ------------------------------------------------------------------

VerilogParser::File_path_specContext::File_path_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::File_path_specContext::FILE_PATH_SPEC() {
  return getToken(VerilogParser::FILE_PATH_SPEC, 0);
}


size_t VerilogParser::File_path_specContext::getRuleIndex() const {
  return VerilogParser::RuleFile_path_spec;
}


std::any VerilogParser::File_path_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFile_path_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::File_path_specContext* VerilogParser::file_path_spec() {
  File_path_specContext *_localctx = _tracker.createInstance<File_path_specContext>(_ctx, getState());
  enterRule(_localctx, 10, VerilogParser::RuleFile_path_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(831);
    match(VerilogParser::FILE_PATH_SPEC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_textContext ------------------------------------------------------------------

VerilogParser::Source_textContext::Source_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Source_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::DescriptionContext *> VerilogParser::Source_textContext::description() {
  return getRuleContexts<VerilogParser::DescriptionContext>();
}

VerilogParser::DescriptionContext* VerilogParser::Source_textContext::description(size_t i) {
  return getRuleContext<VerilogParser::DescriptionContext>(i);
}


size_t VerilogParser::Source_textContext::getRuleIndex() const {
  return VerilogParser::RuleSource_text;
}


std::any VerilogParser::Source_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSource_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Source_textContext* VerilogParser::source_text() {
  Source_textContext *_localctx = _tracker.createInstance<Source_textContext>(_ctx, getState());
  enterRule(_localctx, 12, VerilogParser::RuleSource_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(836);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CONFIG || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 262153) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 140)) & 18014398509481989) != 0)) {
      setState(833);
      description();
      setState(838);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(839);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescriptionContext ------------------------------------------------------------------

VerilogParser::DescriptionContext::DescriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_declarationContext* VerilogParser::DescriptionContext::module_declaration() {
  return getRuleContext<VerilogParser::Module_declarationContext>(0);
}

VerilogParser::Udp_declarationContext* VerilogParser::DescriptionContext::udp_declaration() {
  return getRuleContext<VerilogParser::Udp_declarationContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::DescriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}

VerilogParser::Nature_declarationContext* VerilogParser::DescriptionContext::nature_declaration() {
  return getRuleContext<VerilogParser::Nature_declarationContext>(0);
}

VerilogParser::Discipline_declarationContext* VerilogParser::DescriptionContext::discipline_declaration() {
  return getRuleContext<VerilogParser::Discipline_declarationContext>(0);
}


size_t VerilogParser::DescriptionContext::getRuleIndex() const {
  return VerilogParser::RuleDescription;
}


std::any VerilogParser::DescriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDescription(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DescriptionContext* VerilogParser::description() {
  DescriptionContext *_localctx = _tracker.createInstance<DescriptionContext>(_ctx, getState());
  enterRule(_localctx, 14, VerilogParser::RuleDescription);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(846);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(841);
      module_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(842);
      udp_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(843);
      config_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(844);
      nature_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(845);
      discipline_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_declarationContext ------------------------------------------------------------------

VerilogParser::Module_declarationContext::Module_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_keywordContext* VerilogParser::Module_declarationContext::module_keyword() {
  return getRuleContext<VerilogParser::Module_keywordContext>(0);
}

VerilogParser::Module_identifierContext* VerilogParser::Module_declarationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::ENDMODULE() {
  return getToken(VerilogParser::ENDMODULE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::Module_declarationContext::module_parameter_port_list() {
  return getRuleContext<VerilogParser::Module_parameter_port_listContext>(0);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::Module_declarationContext::list_of_port_declarations() {
  return getRuleContext<VerilogParser::List_of_port_declarationsContext>(0);
}

std::vector<VerilogParser::Module_itemContext *> VerilogParser::Module_declarationContext::module_item() {
  return getRuleContexts<VerilogParser::Module_itemContext>();
}

VerilogParser::Module_itemContext* VerilogParser::Module_declarationContext::module_item(size_t i) {
  return getRuleContext<VerilogParser::Module_itemContext>(i);
}


size_t VerilogParser::Module_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_declaration;
}


std::any VerilogParser::Module_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_declarationContext* VerilogParser::module_declaration() {
  Module_declarationContext *_localctx = _tracker.createInstance<Module_declarationContext>(_ctx, getState());
  enterRule(_localctx, 16, VerilogParser::RuleModule_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(851);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(848);
      attribute_instance();
      setState(853);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(854);
    module_keyword();
    setState(855);
    module_identifier();
    setState(857);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(856);
      module_parameter_port_list();
    }
    setState(860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(859);
      list_of_port_declarations();
    }
    setState(862);
    match(VerilogParser::SC);
    setState(866);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3336657150486389710) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7494158970579124831) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 2305843009213694015) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(863);
      module_item();
      setState(868);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(869);
    match(VerilogParser::ENDMODULE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_keywordContext ------------------------------------------------------------------

VerilogParser::Module_keywordContext::Module_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MODULE() {
  return getToken(VerilogParser::MODULE, 0);
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MACROMODULE() {
  return getToken(VerilogParser::MACROMODULE, 0);
}


size_t VerilogParser::Module_keywordContext::getRuleIndex() const {
  return VerilogParser::RuleModule_keyword;
}


std::any VerilogParser::Module_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_keyword(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_keywordContext* VerilogParser::module_keyword() {
  Module_keywordContext *_localctx = _tracker.createInstance<Module_keywordContext>(_ctx, getState());
  enterRule(_localctx, 18, VerilogParser::RuleModule_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(871);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MACROMODULE

    || _la == VerilogParser::MODULE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Discipline_declarationContext ------------------------------------------------------------------

VerilogParser::Discipline_declarationContext::Discipline_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Discipline_declarationContext::DISCIPLINE() {
  return getToken(VerilogParser::DISCIPLINE, 0);
}

VerilogParser::Discipline_nameContext* VerilogParser::Discipline_declarationContext::discipline_name() {
  return getRuleContext<VerilogParser::Discipline_nameContext>(0);
}

tree::TerminalNode* VerilogParser::Discipline_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Discipline_declarationContext::ENDDISCIPLINE() {
  return getToken(VerilogParser::ENDDISCIPLINE, 0);
}

std::vector<VerilogParser::Discipline_itemContext *> VerilogParser::Discipline_declarationContext::discipline_item() {
  return getRuleContexts<VerilogParser::Discipline_itemContext>();
}

VerilogParser::Discipline_itemContext* VerilogParser::Discipline_declarationContext::discipline_item(size_t i) {
  return getRuleContext<VerilogParser::Discipline_itemContext>(i);
}


size_t VerilogParser::Discipline_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleDiscipline_declaration;
}


std::any VerilogParser::Discipline_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDiscipline_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Discipline_declarationContext* VerilogParser::discipline_declaration() {
  Discipline_declarationContext *_localctx = _tracker.createInstance<Discipline_declarationContext>(_ctx, getState());
  enterRule(_localctx, 20, VerilogParser::RuleDiscipline_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(873);
    match(VerilogParser::DISCIPLINE);
    setState(874);
    discipline_name();
    setState(875);
    match(VerilogParser::SC);
    setState(879);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 146) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 146)) & 288230376151711751) != 0)) {
      setState(876);
      discipline_item();
      setState(881);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(882);
    match(VerilogParser::ENDDISCIPLINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Discipline_nameContext ------------------------------------------------------------------

VerilogParser::Discipline_nameContext::Discipline_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Discipline_nameContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Discipline_nameContext::ELECTRICAL() {
  return getToken(VerilogParser::ELECTRICAL, 0);
}

tree::TerminalNode* VerilogParser::Discipline_nameContext::VOLTAGE() {
  return getToken(VerilogParser::VOLTAGE, 0);
}

tree::TerminalNode* VerilogParser::Discipline_nameContext::CURRENT() {
  return getToken(VerilogParser::CURRENT, 0);
}


size_t VerilogParser::Discipline_nameContext::getRuleIndex() const {
  return VerilogParser::RuleDiscipline_name;
}


std::any VerilogParser::Discipline_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDiscipline_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Discipline_nameContext* VerilogParser::discipline_name() {
  Discipline_nameContext *_localctx = _tracker.createInstance<Discipline_nameContext>(_ctx, getState());
  enterRule(_localctx, 22, VerilogParser::RuleDiscipline_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(888);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(884);
        identifier();
        break;
      }

      case VerilogParser::ELECTRICAL: {
        enterOuterAlt(_localctx, 2);
        setState(885);
        match(VerilogParser::ELECTRICAL);
        break;
      }

      case VerilogParser::VOLTAGE: {
        enterOuterAlt(_localctx, 3);
        setState(886);
        match(VerilogParser::VOLTAGE);
        break;
      }

      case VerilogParser::CURRENT: {
        enterOuterAlt(_localctx, 4);
        setState(887);
        match(VerilogParser::CURRENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Discipline_itemContext ------------------------------------------------------------------

VerilogParser::Discipline_itemContext::Discipline_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Domain_statementContext* VerilogParser::Discipline_itemContext::domain_statement() {
  return getRuleContext<VerilogParser::Domain_statementContext>(0);
}

VerilogParser::Potential_declarationContext* VerilogParser::Discipline_itemContext::potential_declaration() {
  return getRuleContext<VerilogParser::Potential_declarationContext>(0);
}

VerilogParser::Flow_declarationContext* VerilogParser::Discipline_itemContext::flow_declaration() {
  return getRuleContext<VerilogParser::Flow_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Discipline_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Discipline_itemContext::getRuleIndex() const {
  return VerilogParser::RuleDiscipline_item;
}


std::any VerilogParser::Discipline_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDiscipline_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Discipline_itemContext* VerilogParser::discipline_item() {
  Discipline_itemContext *_localctx = _tracker.createInstance<Discipline_itemContext>(_ctx, getState());
  enterRule(_localctx, 24, VerilogParser::RuleDiscipline_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(894);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::DOMAIN: {
        enterOuterAlt(_localctx, 1);
        setState(890);
        domain_statement();
        break;
      }

      case VerilogParser::POTENTIAL: {
        enterOuterAlt(_localctx, 2);
        setState(891);
        potential_declaration();
        break;
      }

      case VerilogParser::FLOW: {
        enterOuterAlt(_localctx, 3);
        setState(892);
        flow_declaration();
        break;
      }

      case VerilogParser::SC: {
        enterOuterAlt(_localctx, 4);
        setState(893);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Domain_statementContext ------------------------------------------------------------------

VerilogParser::Domain_statementContext::Domain_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Domain_statementContext::DOMAIN() {
  return getToken(VerilogParser::DOMAIN, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Domain_statementContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Domain_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Domain_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDomain_statement;
}


std::any VerilogParser::Domain_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDomain_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Domain_statementContext* VerilogParser::domain_statement() {
  Domain_statementContext *_localctx = _tracker.createInstance<Domain_statementContext>(_ctx, getState());
  enterRule(_localctx, 26, VerilogParser::RuleDomain_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(896);
    match(VerilogParser::DOMAIN);
    setState(897);
    identifier();
    setState(898);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Potential_declarationContext ------------------------------------------------------------------

VerilogParser::Potential_declarationContext::Potential_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Potential_declarationContext::POTENTIAL() {
  return getToken(VerilogParser::POTENTIAL, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Potential_declarationContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Potential_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Potential_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePotential_declaration;
}


std::any VerilogParser::Potential_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPotential_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Potential_declarationContext* VerilogParser::potential_declaration() {
  Potential_declarationContext *_localctx = _tracker.createInstance<Potential_declarationContext>(_ctx, getState());
  enterRule(_localctx, 28, VerilogParser::RulePotential_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(900);
    match(VerilogParser::POTENTIAL);
    setState(901);
    identifier();
    setState(902);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Flow_declarationContext ------------------------------------------------------------------

VerilogParser::Flow_declarationContext::Flow_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Flow_declarationContext::FLOW() {
  return getToken(VerilogParser::FLOW, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Flow_declarationContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Flow_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Flow_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFlow_declaration;
}


std::any VerilogParser::Flow_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFlow_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Flow_declarationContext* VerilogParser::flow_declaration() {
  Flow_declarationContext *_localctx = _tracker.createInstance<Flow_declarationContext>(_ctx, getState());
  enterRule(_localctx, 30, VerilogParser::RuleFlow_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(904);
    match(VerilogParser::FLOW);
    setState(905);
    identifier();
    setState(906);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nature_declarationContext ------------------------------------------------------------------

VerilogParser::Nature_declarationContext::Nature_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nature_declarationContext::NATURE() {
  return getToken(VerilogParser::NATURE, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Nature_declarationContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Nature_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Nature_declarationContext::ENDNATURE() {
  return getToken(VerilogParser::ENDNATURE, 0);
}

std::vector<VerilogParser::Nature_itemContext *> VerilogParser::Nature_declarationContext::nature_item() {
  return getRuleContexts<VerilogParser::Nature_itemContext>();
}

VerilogParser::Nature_itemContext* VerilogParser::Nature_declarationContext::nature_item(size_t i) {
  return getRuleContext<VerilogParser::Nature_itemContext>(i);
}


size_t VerilogParser::Nature_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleNature_declaration;
}


std::any VerilogParser::Nature_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNature_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nature_declarationContext* VerilogParser::nature_declaration() {
  Nature_declarationContext *_localctx = _tracker.createInstance<Nature_declarationContext>(_ctx, getState());
  enterRule(_localctx, 32, VerilogParser::RuleNature_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    match(VerilogParser::NATURE);
    setState(909);
    identifier();
    setState(910);
    match(VerilogParser::SC);
    setState(914);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 149) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 149)) & 31) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(911);
      nature_item();
      setState(916);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(917);
    match(VerilogParser::ENDNATURE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nature_itemContext ------------------------------------------------------------------

VerilogParser::Nature_itemContext::Nature_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nature_itemContext::UNITS() {
  return getToken(VerilogParser::UNITS, 0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::STRING() {
  return getToken(VerilogParser::STRING, 0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::ACCESS() {
  return getToken(VerilogParser::ACCESS, 0);
}

VerilogParser::Access_specContext* VerilogParser::Nature_itemContext::access_spec() {
  return getRuleContext<VerilogParser::Access_specContext>(0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::IDT_NATURE() {
  return getToken(VerilogParser::IDT_NATURE, 0);
}

VerilogParser::IdentifierContext* VerilogParser::Nature_itemContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::DDT_NATURE() {
  return getToken(VerilogParser::DDT_NATURE, 0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::ABSTOL() {
  return getToken(VerilogParser::ABSTOL, 0);
}

VerilogParser::NumberContext* VerilogParser::Nature_itemContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

tree::TerminalNode* VerilogParser::Nature_itemContext::IDENTIFIER() {
  return getToken(VerilogParser::IDENTIFIER, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Nature_itemContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Nature_itemContext::getRuleIndex() const {
  return VerilogParser::RuleNature_item;
}


std::any VerilogParser::Nature_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNature_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nature_itemContext* VerilogParser::nature_item() {
  Nature_itemContext *_localctx = _tracker.createInstance<Nature_itemContext>(_ctx, getState());
  enterRule(_localctx, 34, VerilogParser::RuleNature_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(948);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::UNITS: {
        enterOuterAlt(_localctx, 1);
        setState(919);
        match(VerilogParser::UNITS);
        setState(920);
        match(VerilogParser::EQ);
        setState(921);
        match(VerilogParser::STRING);
        setState(922);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::ACCESS: {
        enterOuterAlt(_localctx, 2);
        setState(923);
        match(VerilogParser::ACCESS);
        setState(924);
        match(VerilogParser::EQ);
        setState(925);
        access_spec();
        setState(926);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::IDT_NATURE: {
        enterOuterAlt(_localctx, 3);
        setState(928);
        match(VerilogParser::IDT_NATURE);
        setState(929);
        match(VerilogParser::EQ);
        setState(930);
        identifier();
        setState(931);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::DDT_NATURE: {
        enterOuterAlt(_localctx, 4);
        setState(933);
        match(VerilogParser::DDT_NATURE);
        setState(934);
        match(VerilogParser::EQ);
        setState(935);
        identifier();
        setState(936);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::ABSTOL: {
        enterOuterAlt(_localctx, 5);
        setState(938);
        match(VerilogParser::ABSTOL);
        setState(939);
        match(VerilogParser::EQ);
        setState(940);
        number();
        setState(941);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 6);
        setState(943);
        match(VerilogParser::IDENTIFIER);
        setState(944);
        match(VerilogParser::EQ);
        setState(945);
        expression(0);
        setState(946);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Access_specContext ------------------------------------------------------------------

VerilogParser::Access_specContext::Access_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Access_specContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Access_specContext::getRuleIndex() const {
  return VerilogParser::RuleAccess_spec;
}


std::any VerilogParser::Access_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAccess_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Access_specContext* VerilogParser::access_spec() {
  Access_specContext *_localctx = _tracker.createInstance<Access_specContext>(_ctx, getState());
  enterRule(_localctx, 36, VerilogParser::RuleAccess_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_parameter_port_listContext ------------------------------------------------------------------

VerilogParser::Module_parameter_port_listContext::Module_parameter_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Parameter_declarationContext *> VerilogParser::Module_parameter_port_listContext::parameter_declaration() {
  return getRuleContexts<VerilogParser::Parameter_declarationContext>();
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_parameter_port_listContext::parameter_declaration(size_t i) {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_parameter_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_parameter_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleModule_parameter_port_list;
}


std::any VerilogParser::Module_parameter_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_parameter_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::module_parameter_port_list() {
  Module_parameter_port_listContext *_localctx = _tracker.createInstance<Module_parameter_port_listContext>(_ctx, getState());
  enterRule(_localctx, 38, VerilogParser::RuleModule_parameter_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    match(VerilogParser::HA);
    setState(953);
    match(VerilogParser::LP);
    setState(954);
    parameter_declaration();
    setState(959);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(955);
      match(VerilogParser::CO);
      setState(956);
      parameter_declaration();
      setState(961);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(962);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_declarationsContext ------------------------------------------------------------------

VerilogParser::List_of_port_declarationsContext::List_of_port_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Port_declarationContext *> VerilogParser::List_of_port_declarationsContext::port_declaration() {
  return getRuleContexts<VerilogParser::Port_declarationContext>();
}

VerilogParser::Port_declarationContext* VerilogParser::List_of_port_declarationsContext::port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Port_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_declarationsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::PortContext *> VerilogParser::List_of_port_declarationsContext::port() {
  return getRuleContexts<VerilogParser::PortContext>();
}

VerilogParser::PortContext* VerilogParser::List_of_port_declarationsContext::port(size_t i) {
  return getRuleContext<VerilogParser::PortContext>(i);
}

VerilogParser::Port_implicitContext* VerilogParser::List_of_port_declarationsContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::List_of_port_declarationsContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::List_of_port_declarationsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_declarations;
}


std::any VerilogParser::List_of_port_declarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_declarations(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::list_of_port_declarations() {
  List_of_port_declarationsContext *_localctx = _tracker.createInstance<List_of_port_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 40, VerilogParser::RuleList_of_port_declarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(995);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(964);
      match(VerilogParser::LP);
      setState(965);
      port_declaration();
      setState(970);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(966);
        match(VerilogParser::CO);
        setState(967);
        port_declaration();
        setState(972);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(973);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(975);
      match(VerilogParser::LP);
      setState(976);
      port();
      setState(979); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(977);
        match(VerilogParser::CO);
        setState(978);
        port();
        setState(981); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == VerilogParser::CO);
      setState(983);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(985);
      match(VerilogParser::LP);
      setState(986);
      port_implicit();
      setState(987);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(989);
      match(VerilogParser::LP);
      setState(990);
      port_explicit();
      setState(991);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(993);
      match(VerilogParser::LP);
      setState(994);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

VerilogParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_implicitContext* VerilogParser::PortContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::PortContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::PortContext::getRuleIndex() const {
  return VerilogParser::RulePort;
}


std::any VerilogParser::PortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PortContext* VerilogParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 42, VerilogParser::RulePort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1001);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CO:
      case VerilogParser::LC:
      case VerilogParser::RP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(998);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 8519681) != 0) || _la == VerilogParser::IDENTIFIER) {
          setState(997);
          port_implicit();
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(1000);
        port_explicit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_implicitContext ------------------------------------------------------------------

VerilogParser::Port_implicitContext::Port_implicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_expressionContext* VerilogParser::Port_implicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_implicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_implicit;
}


std::any VerilogParser::Port_implicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_implicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_implicitContext* VerilogParser::port_implicit() {
  Port_implicitContext *_localctx = _tracker.createInstance<Port_implicitContext>(_ctx, getState());
  enterRule(_localctx, 44, VerilogParser::RulePort_implicit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    port_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_explicitContext ------------------------------------------------------------------

VerilogParser::Port_explicitContext::Port_explicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Port_explicitContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Port_explicitContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Port_expressionContext* VerilogParser::Port_explicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_explicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_explicit;
}


std::any VerilogParser::Port_explicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_explicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_explicitContext* VerilogParser::port_explicit() {
  Port_explicitContext *_localctx = _tracker.createInstance<Port_explicitContext>(_ctx, getState());
  enterRule(_localctx, 46, VerilogParser::RulePort_explicit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1005);
    match(VerilogParser::DT);
    setState(1006);
    port_identifier();
    setState(1007);
    match(VerilogParser::LP);
    setState(1009);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 8519681) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(1008);
      port_expression();
    }
    setState(1011);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_expressionContext ------------------------------------------------------------------

VerilogParser::Port_expressionContext::Port_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_referenceContext *> VerilogParser::Port_expressionContext::port_reference() {
  return getRuleContexts<VerilogParser::Port_referenceContext>();
}

VerilogParser::Port_referenceContext* VerilogParser::Port_expressionContext::port_reference(size_t i) {
  return getRuleContext<VerilogParser::Port_referenceContext>(i);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Port_expressionContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Port_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePort_expression;
}


std::any VerilogParser::Port_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_expressionContext* VerilogParser::port_expression() {
  Port_expressionContext *_localctx = _tracker.createInstance<Port_expressionContext>(_ctx, getState());
  enterRule(_localctx, 48, VerilogParser::RulePort_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1025);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1013);
        port_reference();
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(1014);
        match(VerilogParser::LC);
        setState(1015);
        port_reference();
        setState(1020);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(1016);
          match(VerilogParser::CO);
          setState(1017);
          port_reference();
          setState(1022);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1023);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_referenceContext ------------------------------------------------------------------

VerilogParser::Port_referenceContext::Port_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Port_referenceContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Port_referenceContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Port_referenceContext::getRuleIndex() const {
  return VerilogParser::RulePort_reference;
}


std::any VerilogParser::Port_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_referenceContext* VerilogParser::port_reference() {
  Port_referenceContext *_localctx = _tracker.createInstance<Port_referenceContext>(_ctx, getState());
  enterRule(_localctx, 50, VerilogParser::RulePort_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    port_identifier();
    setState(1032);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1028);
      match(VerilogParser::LB);
      setState(1029);
      constant_range_expression();
      setState(1030);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_declarationContext ------------------------------------------------------------------

VerilogParser::Port_declarationContext::Port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Inout_declarationContext* VerilogParser::Port_declarationContext::inout_declaration() {
  return getRuleContext<VerilogParser::Inout_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Port_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Port_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Input_declarationContext* VerilogParser::Port_declarationContext::input_declaration() {
  return getRuleContext<VerilogParser::Input_declarationContext>(0);
}

VerilogParser::Output_declarationContext* VerilogParser::Port_declarationContext::output_declaration() {
  return getRuleContext<VerilogParser::Output_declarationContext>(0);
}


size_t VerilogParser::Port_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePort_declaration;
}


std::any VerilogParser::Port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_declarationContext* VerilogParser::port_declaration() {
  Port_declarationContext *_localctx = _tracker.createInstance<Port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 52, VerilogParser::RulePort_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1055);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1037);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1034);
        attribute_instance();
        setState(1039);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1040);
      inout_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1044);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1041);
        attribute_instance();
        setState(1046);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1047);
      input_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1051);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1048);
        attribute_instance();
        setState(1053);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1054);
      output_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_itemContext ------------------------------------------------------------------

VerilogParser::Module_itemContext::Module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_declarationContext* VerilogParser::Module_itemContext::port_declaration() {
  return getRuleContext<VerilogParser::Port_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Module_itemContext::module_or_generate_item() {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(0);
}

VerilogParser::Generate_regionContext* VerilogParser::Module_itemContext::generate_region() {
  return getRuleContext<VerilogParser::Generate_regionContext>(0);
}

VerilogParser::Specify_blockContext* VerilogParser::Module_itemContext::specify_block() {
  return getRuleContext<VerilogParser::Specify_blockContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_itemContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Specparam_declarationContext* VerilogParser::Module_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}

VerilogParser::Electrical_declarationContext* VerilogParser::Module_itemContext::electrical_declaration() {
  return getRuleContext<VerilogParser::Electrical_declarationContext>(0);
}


size_t VerilogParser::Module_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_item;
}


std::any VerilogParser::Module_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_itemContext* VerilogParser::module_item() {
  Module_itemContext *_localctx = _tracker.createInstance<Module_itemContext>(_ctx, getState());
  enterRule(_localctx, 54, VerilogParser::RuleModule_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1080);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1057);
      port_declaration();
      setState(1058);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1060);
      module_or_generate_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1061);
      generate_region();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1062);
      specify_block();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1066);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1063);
        attribute_instance();
        setState(1068);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1069);
      parameter_declaration();
      setState(1070);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1075);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1072);
        attribute_instance();
        setState(1077);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1078);
      specparam_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1079);
      electrical_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_itemContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_itemContext::Module_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::Module_or_generate_itemContext::module_or_generate_item_declaration() {
  return getRuleContext<VerilogParser::Module_or_generate_item_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_or_generate_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_or_generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Module_or_generate_itemContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_or_generate_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_overrideContext* VerilogParser::Module_or_generate_itemContext::parameter_override() {
  return getRuleContext<VerilogParser::Parameter_overrideContext>(0);
}

VerilogParser::Continuous_assignContext* VerilogParser::Module_or_generate_itemContext::continuous_assign() {
  return getRuleContext<VerilogParser::Continuous_assignContext>(0);
}

VerilogParser::Gate_instantiationContext* VerilogParser::Module_or_generate_itemContext::gate_instantiation() {
  return getRuleContext<VerilogParser::Gate_instantiationContext>(0);
}

VerilogParser::Module_instantiationContext* VerilogParser::Module_or_generate_itemContext::module_instantiation() {
  return getRuleContext<VerilogParser::Module_instantiationContext>(0);
}

VerilogParser::Udp_instantiationContext* VerilogParser::Module_or_generate_itemContext::udp_instantiation() {
  return getRuleContext<VerilogParser::Udp_instantiationContext>(0);
}

VerilogParser::Initial_constructContext* VerilogParser::Module_or_generate_itemContext::initial_construct() {
  return getRuleContext<VerilogParser::Initial_constructContext>(0);
}

VerilogParser::Always_constructContext* VerilogParser::Module_or_generate_itemContext::always_construct() {
  return getRuleContext<VerilogParser::Always_constructContext>(0);
}

VerilogParser::Analog_constructContext* VerilogParser::Module_or_generate_itemContext::analog_construct() {
  return getRuleContext<VerilogParser::Analog_constructContext>(0);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::Module_or_generate_itemContext::loop_generate_construct() {
  return getRuleContext<VerilogParser::Loop_generate_constructContext>(0);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::Module_or_generate_itemContext::conditional_generate_construct() {
  return getRuleContext<VerilogParser::Conditional_generate_constructContext>(0);
}


size_t VerilogParser::Module_or_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item;
}


std::any VerilogParser::Module_or_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::module_or_generate_item() {
  Module_or_generate_itemContext *_localctx = _tracker.createInstance<Module_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 56, VerilogParser::RuleModule_or_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1168);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1085);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1082);
        attribute_instance();
        setState(1087);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1088);
      module_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1092);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1089);
        attribute_instance();
        setState(1094);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1095);
      local_parameter_declaration();
      setState(1096);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1101);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1098);
        attribute_instance();
        setState(1103);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1104);
      parameter_override();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1108);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1105);
        attribute_instance();
        setState(1110);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1111);
      continuous_assign();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1115);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1112);
        attribute_instance();
        setState(1117);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1118);
      gate_instantiation();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1122);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1119);
        attribute_instance();
        setState(1124);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1125);
      module_instantiation();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1129);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1126);
        attribute_instance();
        setState(1131);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1132);
      udp_instantiation();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1136);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1133);
        attribute_instance();
        setState(1138);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1139);
      initial_construct();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1143);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1140);
        attribute_instance();
        setState(1145);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1146);
      always_construct();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1150);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1147);
        attribute_instance();
        setState(1152);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1153);
      analog_construct();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1157);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1154);
        attribute_instance();
        setState(1159);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1160);
      loop_generate_construct();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1164);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1161);
        attribute_instance();
        setState(1166);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1167);
      conditional_generate_construct();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_item_declarationContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_item_declarationContext::Module_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::net_declaration() {
  return getRuleContext<VerilogParser::Net_declarationContext>(0);
}

VerilogParser::Reg_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::reg_declaration() {
  return getRuleContext<VerilogParser::Reg_declarationContext>(0);
}

VerilogParser::Integer_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::integer_declaration() {
  return getRuleContext<VerilogParser::Integer_declarationContext>(0);
}

VerilogParser::Real_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::real_declaration() {
  return getRuleContext<VerilogParser::Real_declarationContext>(0);
}

VerilogParser::Time_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::time_declaration() {
  return getRuleContext<VerilogParser::Time_declarationContext>(0);
}

VerilogParser::Realtime_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::realtime_declaration() {
  return getRuleContext<VerilogParser::Realtime_declarationContext>(0);
}

VerilogParser::Event_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Genvar_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::genvar_declaration() {
  return getRuleContext<VerilogParser::Genvar_declarationContext>(0);
}

VerilogParser::Task_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::task_declaration() {
  return getRuleContext<VerilogParser::Task_declarationContext>(0);
}

VerilogParser::Function_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::function_declaration() {
  return getRuleContext<VerilogParser::Function_declarationContext>(0);
}


size_t VerilogParser::Module_or_generate_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item_declaration;
}


std::any VerilogParser::Module_or_generate_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::module_or_generate_item_declaration() {
  Module_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Module_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 58, VerilogParser::RuleModule_or_generate_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1180);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR: {
        enterOuterAlt(_localctx, 1);
        setState(1170);
        net_declaration();
        break;
      }

      case VerilogParser::REG: {
        enterOuterAlt(_localctx, 2);
        setState(1171);
        reg_declaration();
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1172);
        integer_declaration();
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1173);
        real_declaration();
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 5);
        setState(1174);
        time_declaration();
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 6);
        setState(1175);
        realtime_declaration();
        break;
      }

      case VerilogParser::EVENT: {
        enterOuterAlt(_localctx, 7);
        setState(1176);
        event_declaration();
        break;
      }

      case VerilogParser::GENVAR: {
        enterOuterAlt(_localctx, 8);
        setState(1177);
        genvar_declaration();
        break;
      }

      case VerilogParser::TASK: {
        enterOuterAlt(_localctx, 9);
        setState(1178);
        task_declaration();
        break;
      }

      case VerilogParser::FUNCTION: {
        enterOuterAlt(_localctx, 10);
        setState(1179);
        function_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_overrideContext ------------------------------------------------------------------

VerilogParser::Parameter_overrideContext::Parameter_overrideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::DEFPARAM() {
  return getToken(VerilogParser::DEFPARAM, 0);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::Parameter_overrideContext::list_of_defparam_assignments() {
  return getRuleContext<VerilogParser::List_of_defparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Parameter_overrideContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_override;
}


std::any VerilogParser::Parameter_overrideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_override(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_overrideContext* VerilogParser::parameter_override() {
  Parameter_overrideContext *_localctx = _tracker.createInstance<Parameter_overrideContext>(_ctx, getState());
  enterRule(_localctx, 60, VerilogParser::RuleParameter_override);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1182);
    match(VerilogParser::DEFPARAM);
    setState(1183);
    list_of_defparam_assignments();
    setState(1184);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_declarationContext ------------------------------------------------------------------

VerilogParser::Config_declarationContext::Config_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Config_declarationContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}

VerilogParser::Config_identifierContext* VerilogParser::Config_declarationContext::config_identifier() {
  return getRuleContext<VerilogParser::Config_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Design_statementContext* VerilogParser::Config_declarationContext::design_statement() {
  return getRuleContext<VerilogParser::Design_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::ENDCONFIG() {
  return getToken(VerilogParser::ENDCONFIG, 0);
}

std::vector<VerilogParser::Config_rule_statementContext *> VerilogParser::Config_declarationContext::config_rule_statement() {
  return getRuleContexts<VerilogParser::Config_rule_statementContext>();
}

VerilogParser::Config_rule_statementContext* VerilogParser::Config_declarationContext::config_rule_statement(size_t i) {
  return getRuleContext<VerilogParser::Config_rule_statementContext>(i);
}


size_t VerilogParser::Config_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_declaration;
}


std::any VerilogParser::Config_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_declarationContext* VerilogParser::config_declaration() {
  Config_declarationContext *_localctx = _tracker.createInstance<Config_declarationContext>(_ctx, getState());
  enterRule(_localctx, 62, VerilogParser::RuleConfig_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1186);
    match(VerilogParser::CONFIG);
    setState(1187);
    config_identifier();
    setState(1188);
    match(VerilogParser::SC);
    setState(1189);
    design_statement();
    setState(1193);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1152921504606916608) != 0)) {
      setState(1190);
      config_rule_statement();
      setState(1195);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1196);
    match(VerilogParser::ENDCONFIG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statementContext ------------------------------------------------------------------

VerilogParser::Design_statementContext::Design_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Design_statementContext::DESIGN() {
  return getToken(VerilogParser::DESIGN, 0);
}

tree::TerminalNode* VerilogParser::Design_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Design_statement_itemContext *> VerilogParser::Design_statementContext::design_statement_item() {
  return getRuleContexts<VerilogParser::Design_statement_itemContext>();
}

VerilogParser::Design_statement_itemContext* VerilogParser::Design_statementContext::design_statement_item(size_t i) {
  return getRuleContext<VerilogParser::Design_statement_itemContext>(i);
}


size_t VerilogParser::Design_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement;
}


std::any VerilogParser::Design_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statementContext* VerilogParser::design_statement() {
  Design_statementContext *_localctx = _tracker.createInstance<Design_statementContext>(_ctx, getState());
  enterRule(_localctx, 64, VerilogParser::RuleDesign_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1198);
    match(VerilogParser::DESIGN);
    setState(1202);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(1199);
      design_statement_item();
      setState(1204);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1205);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statement_itemContext ------------------------------------------------------------------

VerilogParser::Design_statement_itemContext::Design_statement_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cell_identifierContext* VerilogParser::Design_statement_itemContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Design_statement_itemContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Design_statement_itemContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Design_statement_itemContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement_item;
}


std::any VerilogParser::Design_statement_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statement_itemContext* VerilogParser::design_statement_item() {
  Design_statement_itemContext *_localctx = _tracker.createInstance<Design_statement_itemContext>(_ctx, getState());
  enterRule(_localctx, 66, VerilogParser::RuleDesign_statement_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1210);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(1207);
      library_identifier();
      setState(1208);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1212);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_rule_statementContext ------------------------------------------------------------------

VerilogParser::Config_rule_statementContext::Config_rule_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Default_clauseContext* VerilogParser::Config_rule_statementContext::default_clause() {
  return getRuleContext<VerilogParser::Default_clauseContext>(0);
}

VerilogParser::Liblist_clauseContext* VerilogParser::Config_rule_statementContext::liblist_clause() {
  return getRuleContext<VerilogParser::Liblist_clauseContext>(0);
}

tree::TerminalNode* VerilogParser::Config_rule_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Inst_clauseContext* VerilogParser::Config_rule_statementContext::inst_clause() {
  return getRuleContext<VerilogParser::Inst_clauseContext>(0);
}

VerilogParser::Use_clauseContext* VerilogParser::Config_rule_statementContext::use_clause() {
  return getRuleContext<VerilogParser::Use_clauseContext>(0);
}

VerilogParser::Cell_clauseContext* VerilogParser::Config_rule_statementContext::cell_clause() {
  return getRuleContext<VerilogParser::Cell_clauseContext>(0);
}


size_t VerilogParser::Config_rule_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_rule_statement;
}


std::any VerilogParser::Config_rule_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_rule_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_rule_statementContext* VerilogParser::config_rule_statement() {
  Config_rule_statementContext *_localctx = _tracker.createInstance<Config_rule_statementContext>(_ctx, getState());
  enterRule(_localctx, 68, VerilogParser::RuleConfig_rule_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1234);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1214);
      default_clause();
      setState(1215);
      liblist_clause();
      setState(1216);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1218);
      inst_clause();
      setState(1219);
      liblist_clause();
      setState(1220);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1222);
      inst_clause();
      setState(1223);
      use_clause();
      setState(1224);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1226);
      cell_clause();
      setState(1227);
      liblist_clause();
      setState(1228);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1230);
      cell_clause();
      setState(1231);
      use_clause();
      setState(1232);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_clauseContext ------------------------------------------------------------------

VerilogParser::Default_clauseContext::Default_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Default_clauseContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Default_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleDefault_clause;
}


std::any VerilogParser::Default_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefault_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Default_clauseContext* VerilogParser::default_clause() {
  Default_clauseContext *_localctx = _tracker.createInstance<Default_clauseContext>(_ctx, getState());
  enterRule(_localctx, 70, VerilogParser::RuleDefault_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1236);
    match(VerilogParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_clauseContext ------------------------------------------------------------------

VerilogParser::Inst_clauseContext::Inst_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inst_clauseContext::INSTANCE() {
  return getToken(VerilogParser::INSTANCE, 0);
}

VerilogParser::Inst_nameContext* VerilogParser::Inst_clauseContext::inst_name() {
  return getRuleContext<VerilogParser::Inst_nameContext>(0);
}


size_t VerilogParser::Inst_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleInst_clause;
}


std::any VerilogParser::Inst_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_clauseContext* VerilogParser::inst_clause() {
  Inst_clauseContext *_localctx = _tracker.createInstance<Inst_clauseContext>(_ctx, getState());
  enterRule(_localctx, 72, VerilogParser::RuleInst_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1238);
    match(VerilogParser::INSTANCE);
    setState(1239);
    inst_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_nameContext ------------------------------------------------------------------

VerilogParser::Inst_nameContext::Inst_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Topmodule_identifierContext* VerilogParser::Inst_nameContext::topmodule_identifier() {
  return getRuleContext<VerilogParser::Topmodule_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Inst_nameContext::DT() {
  return getTokens(VerilogParser::DT);
}

tree::TerminalNode* VerilogParser::Inst_nameContext::DT(size_t i) {
  return getToken(VerilogParser::DT, i);
}

std::vector<VerilogParser::Instance_identifierContext *> VerilogParser::Inst_nameContext::instance_identifier() {
  return getRuleContexts<VerilogParser::Instance_identifierContext>();
}

VerilogParser::Instance_identifierContext* VerilogParser::Inst_nameContext::instance_identifier(size_t i) {
  return getRuleContext<VerilogParser::Instance_identifierContext>(i);
}


size_t VerilogParser::Inst_nameContext::getRuleIndex() const {
  return VerilogParser::RuleInst_name;
}


std::any VerilogParser::Inst_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_nameContext* VerilogParser::inst_name() {
  Inst_nameContext *_localctx = _tracker.createInstance<Inst_nameContext>(_ctx, getState());
  enterRule(_localctx, 74, VerilogParser::RuleInst_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1241);
    topmodule_identifier();
    setState(1246);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::DT) {
      setState(1242);
      match(VerilogParser::DT);
      setState(1243);
      instance_identifier();
      setState(1248);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_clauseContext ------------------------------------------------------------------

VerilogParser::Cell_clauseContext::Cell_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::CELL() {
  return getToken(VerilogParser::CELL, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Cell_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Cell_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Cell_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleCell_clause;
}


std::any VerilogParser::Cell_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_clauseContext* VerilogParser::cell_clause() {
  Cell_clauseContext *_localctx = _tracker.createInstance<Cell_clauseContext>(_ctx, getState());
  enterRule(_localctx, 76, VerilogParser::RuleCell_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1249);
    match(VerilogParser::CELL);
    setState(1253);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(1250);
      library_identifier();
      setState(1251);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1255);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Liblist_clauseContext ------------------------------------------------------------------

VerilogParser::Liblist_clauseContext::Liblist_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Liblist_clauseContext::LIBLIST() {
  return getToken(VerilogParser::LIBLIST, 0);
}

std::vector<VerilogParser::Library_identifierContext *> VerilogParser::Liblist_clauseContext::library_identifier() {
  return getRuleContexts<VerilogParser::Library_identifierContext>();
}

VerilogParser::Library_identifierContext* VerilogParser::Liblist_clauseContext::library_identifier(size_t i) {
  return getRuleContext<VerilogParser::Library_identifierContext>(i);
}


size_t VerilogParser::Liblist_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleLiblist_clause;
}


std::any VerilogParser::Liblist_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLiblist_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Liblist_clauseContext* VerilogParser::liblist_clause() {
  Liblist_clauseContext *_localctx = _tracker.createInstance<Liblist_clauseContext>(_ctx, getState());
  enterRule(_localctx, 78, VerilogParser::RuleLiblist_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1257);
    match(VerilogParser::LIBLIST);
    setState(1261);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(1258);
      library_identifier();
      setState(1263);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_clauseContext ------------------------------------------------------------------

VerilogParser::Use_clauseContext::Use_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Use_clauseContext::USE() {
  return getToken(VerilogParser::USE, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Use_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Use_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}


size_t VerilogParser::Use_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleUse_clause;
}


std::any VerilogParser::Use_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUse_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Use_clauseContext* VerilogParser::use_clause() {
  Use_clauseContext *_localctx = _tracker.createInstance<Use_clauseContext>(_ctx, getState());
  enterRule(_localctx, 80, VerilogParser::RuleUse_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1264);
    match(VerilogParser::USE);
    setState(1268);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(1265);
      library_identifier();
      setState(1266);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1270);
    cell_identifier();
    setState(1273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(1271);
      match(VerilogParser::CL);
      setState(1272);
      match(VerilogParser::CONFIG);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Local_parameter_declarationContext::Local_parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::LOCALPARAM() {
  return getToken(VerilogParser::LOCALPARAM, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Local_parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Local_parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Local_parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Local_parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLocal_parameter_declaration;
}


std::any VerilogParser::Local_parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLocal_parameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::local_parameter_declaration() {
  Local_parameter_declarationContext *_localctx = _tracker.createInstance<Local_parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 82, VerilogParser::RuleLocal_parameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1287);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1275);
      match(VerilogParser::LOCALPARAM);
      setState(1277);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1276);
        match(VerilogParser::SIGNED);
      }
      setState(1280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1279);
        range_();
      }
      setState(1282);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1283);
      match(VerilogParser::LOCALPARAM);
      setState(1284);
      parameter_type();
      setState(1285);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Parameter_declarationContext::Parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::PARAMETER() {
  return getToken(VerilogParser::PARAMETER, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_declaration;
}


std::any VerilogParser::Parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_declarationContext* VerilogParser::parameter_declaration() {
  Parameter_declarationContext *_localctx = _tracker.createInstance<Parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 84, VerilogParser::RuleParameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1301);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1289);
      match(VerilogParser::PARAMETER);
      setState(1291);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1290);
        match(VerilogParser::SIGNED);
      }
      setState(1294);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1293);
        range_();
      }
      setState(1296);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1297);
      match(VerilogParser::PARAMETER);
      setState(1298);
      parameter_type();
      setState(1299);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_declarationContext ------------------------------------------------------------------

VerilogParser::Specparam_declarationContext::Specparam_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SPECPARAM() {
  return getToken(VerilogParser::SPECPARAM, 0);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::Specparam_declarationContext::list_of_specparam_assignments() {
  return getRuleContext<VerilogParser::List_of_specparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Range_Context* VerilogParser::Specparam_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Specparam_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_declaration;
}


std::any VerilogParser::Specparam_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_declarationContext* VerilogParser::specparam_declaration() {
  Specparam_declarationContext *_localctx = _tracker.createInstance<Specparam_declarationContext>(_ctx, getState());
  enterRule(_localctx, 86, VerilogParser::RuleSpecparam_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1303);
    match(VerilogParser::SPECPARAM);
    setState(1305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1304);
      range_();
    }
    setState(1307);
    list_of_specparam_assignments();
    setState(1308);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_typeContext ------------------------------------------------------------------

VerilogParser::Parameter_typeContext::Parameter_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Parameter_typeContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_type;
}


std::any VerilogParser::Parameter_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_typeContext* VerilogParser::parameter_type() {
  Parameter_typeContext *_localctx = _tracker.createInstance<Parameter_typeContext>(_ctx, getState());
  enterRule(_localctx, 88, VerilogParser::RuleParameter_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1310);
    _la = _input->LA(1);
    if (!(((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 18014411394383873) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_declarationContext ------------------------------------------------------------------

VerilogParser::Inout_declarationContext::Inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Inout_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInout_declaration;
}


std::any VerilogParser::Inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_declarationContext* VerilogParser::inout_declaration() {
  Inout_declarationContext *_localctx = _tracker.createInstance<Inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 90, VerilogParser::RuleInout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1312);
    match(VerilogParser::INOUT);
    setState(1314);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0)) {
      setState(1313);
      net_type();
    }
    setState(1317);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1316);
      match(VerilogParser::SIGNED);
    }
    setState(1320);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1319);
      range_();
    }
    setState(1322);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_declarationContext ------------------------------------------------------------------

VerilogParser::Input_declarationContext::Input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Input_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInput_declaration;
}


std::any VerilogParser::Input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_declarationContext* VerilogParser::input_declaration() {
  Input_declarationContext *_localctx = _tracker.createInstance<Input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 92, VerilogParser::RuleInput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1324);
    match(VerilogParser::INPUT);
    setState(1326);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0)) {
      setState(1325);
      net_type();
    }
    setState(1329);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1328);
      match(VerilogParser::SIGNED);
    }
    setState(1332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1331);
      range_();
    }
    setState(1334);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_declarationContext ------------------------------------------------------------------

VerilogParser::Output_declarationContext::Output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Output_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_variable_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_port_identifiersContext>(0);
}

VerilogParser::Output_variable_typeContext* VerilogParser::Output_declarationContext::output_variable_type() {
  return getRuleContext<VerilogParser::Output_variable_typeContext>(0);
}


size_t VerilogParser::Output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_declaration;
}


std::any VerilogParser::Output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_declarationContext* VerilogParser::output_declaration() {
  Output_declarationContext *_localctx = _tracker.createInstance<Output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 94, VerilogParser::RuleOutput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1360);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1336);
      match(VerilogParser::OUTPUT);
      setState(1338);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 111) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 111)) & 12889859) != 0)) {
        setState(1337);
        net_type();
      }
      setState(1341);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1340);
        match(VerilogParser::SIGNED);
      }
      setState(1344);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1343);
        range_();
      }
      setState(1346);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1347);
      match(VerilogParser::OUTPUT);
      setState(1348);
      match(VerilogParser::REG);
      setState(1350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1349);
        match(VerilogParser::SIGNED);
      }
      setState(1353);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1352);
        range_();
      }
      setState(1355);
      list_of_variable_port_identifiers();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1356);
      match(VerilogParser::OUTPUT);
      setState(1357);
      output_variable_type();
      setState(1358);
      list_of_variable_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_declarationContext ------------------------------------------------------------------

VerilogParser::Event_declarationContext::Event_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_declarationContext::EVENT() {
  return getToken(VerilogParser::EVENT, 0);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::Event_declarationContext::list_of_event_identifiers() {
  return getRuleContext<VerilogParser::List_of_event_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Event_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Event_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_declaration;
}


std::any VerilogParser::Event_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_declarationContext* VerilogParser::event_declaration() {
  Event_declarationContext *_localctx = _tracker.createInstance<Event_declarationContext>(_ctx, getState());
  enterRule(_localctx, 96, VerilogParser::RuleEvent_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1362);
    match(VerilogParser::EVENT);
    setState(1363);
    list_of_event_identifiers();
    setState(1364);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_declarationContext ------------------------------------------------------------------

VerilogParser::Integer_declarationContext::Integer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Integer_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Integer_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInteger_declaration;
}


std::any VerilogParser::Integer_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInteger_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Integer_declarationContext* VerilogParser::integer_declaration() {
  Integer_declarationContext *_localctx = _tracker.createInstance<Integer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 98, VerilogParser::RuleInteger_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1366);
    match(VerilogParser::INTEGER);
    setState(1367);
    list_of_variable_identifiers();
    setState(1368);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_declarationContext ------------------------------------------------------------------

VerilogParser::Net_declarationContext::Net_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_typeContext* VerilogParser::Net_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::Net_declarationContext::list_of_net_identifiers() {
  return getRuleContext<VerilogParser::List_of_net_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Delay3Context* VerilogParser::Net_declarationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::Net_declarationContext::list_of_net_decl_assignments() {
  return getRuleContext<VerilogParser::List_of_net_decl_assignmentsContext>(0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Net_declarationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Net_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::VECTORED() {
  return getToken(VerilogParser::VECTORED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SCALARED() {
  return getToken(VerilogParser::SCALARED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::TRIREG() {
  return getToken(VerilogParser::TRIREG, 0);
}

VerilogParser::Charge_strengthContext* VerilogParser::Net_declarationContext::charge_strength() {
  return getRuleContext<VerilogParser::Charge_strengthContext>(0);
}


size_t VerilogParser::Net_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleNet_declaration;
}


std::any VerilogParser::Net_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_declarationContext* VerilogParser::net_declaration() {
  Net_declarationContext *_localctx = _tracker.createInstance<Net_declarationContext>(_ctx, getState());
  enterRule(_localctx, 100, VerilogParser::RuleNet_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1370);
      net_type();
      setState(1372);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1371);
        match(VerilogParser::SIGNED);
      }
      setState(1375);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1374);
        delay3();
      }
      setState(1377);
      list_of_net_identifiers();
      setState(1378);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1380);
      net_type();
      setState(1382);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1381);
        drive_strength();
      }
      setState(1385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1384);
        match(VerilogParser::SIGNED);
      }
      setState(1388);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1387);
        delay3();
      }
      setState(1390);
      list_of_net_decl_assignments();
      setState(1391);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1393);
      net_type();
      setState(1395);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1394);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1398);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1397);
        match(VerilogParser::SIGNED);
      }
      setState(1400);
      range_();
      setState(1402);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1401);
        delay3();
      }
      setState(1404);
      list_of_net_identifiers();
      setState(1405);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1407);
      net_type();
      setState(1409);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1408);
        drive_strength();
      }
      setState(1412);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1411);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1415);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1414);
        match(VerilogParser::SIGNED);
      }
      setState(1417);
      range_();
      setState(1419);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1418);
        delay3();
      }
      setState(1421);
      list_of_net_decl_assignments();
      setState(1422);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1424);
      match(VerilogParser::TRIREG);
      setState(1426);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1425);
        charge_strength();
      }
      setState(1429);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1428);
        match(VerilogParser::SIGNED);
      }
      setState(1432);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1431);
        delay3();
      }
      setState(1434);
      list_of_net_identifiers();
      setState(1435);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1437);
      match(VerilogParser::TRIREG);
      setState(1439);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1438);
        drive_strength();
      }
      setState(1442);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1441);
        match(VerilogParser::SIGNED);
      }
      setState(1445);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1444);
        delay3();
      }
      setState(1447);
      list_of_net_decl_assignments();
      setState(1448);
      match(VerilogParser::SC);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1450);
      match(VerilogParser::TRIREG);
      setState(1452);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1451);
        charge_strength();
      }
      setState(1455);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1454);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1458);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1457);
        match(VerilogParser::SIGNED);
      }
      setState(1460);
      range_();
      setState(1462);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1461);
        delay3();
      }
      setState(1464);
      list_of_net_identifiers();
      setState(1465);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1467);
      match(VerilogParser::TRIREG);
      setState(1469);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1468);
        drive_strength();
      }
      setState(1472);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1471);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1475);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1474);
        match(VerilogParser::SIGNED);
      }
      setState(1477);
      range_();
      setState(1479);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1478);
        delay3();
      }
      setState(1481);
      list_of_net_decl_assignments();
      setState(1482);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_declarationContext ------------------------------------------------------------------

VerilogParser::Real_declarationContext::Real_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Real_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Real_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Real_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Real_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReal_declaration;
}


std::any VerilogParser::Real_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_declarationContext* VerilogParser::real_declaration() {
  Real_declarationContext *_localctx = _tracker.createInstance<Real_declarationContext>(_ctx, getState());
  enterRule(_localctx, 102, VerilogParser::RuleReal_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1486);
    match(VerilogParser::REAL);
    setState(1487);
    list_of_real_identifiers();
    setState(1488);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Realtime_declarationContext ------------------------------------------------------------------

VerilogParser::Realtime_declarationContext::Realtime_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Realtime_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Realtime_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleRealtime_declaration;
}


std::any VerilogParser::Realtime_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRealtime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Realtime_declarationContext* VerilogParser::realtime_declaration() {
  Realtime_declarationContext *_localctx = _tracker.createInstance<Realtime_declarationContext>(_ctx, getState());
  enterRule(_localctx, 104, VerilogParser::RuleRealtime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1490);
    match(VerilogParser::REALTIME);
    setState(1491);
    list_of_real_identifiers();
    setState(1492);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reg_declarationContext ------------------------------------------------------------------

VerilogParser::Reg_declarationContext::Reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Reg_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Reg_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReg_declaration;
}


std::any VerilogParser::Reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reg_declarationContext* VerilogParser::reg_declaration() {
  Reg_declarationContext *_localctx = _tracker.createInstance<Reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 106, VerilogParser::RuleReg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1494);
    match(VerilogParser::REG);
    setState(1496);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1495);
      match(VerilogParser::SIGNED);
    }
    setState(1499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1498);
      range_();
    }
    setState(1501);
    list_of_variable_identifiers();
    setState(1502);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_declarationContext ------------------------------------------------------------------

VerilogParser::Time_declarationContext::Time_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Time_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Time_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Time_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Time_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTime_declaration;
}


std::any VerilogParser::Time_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Time_declarationContext* VerilogParser::time_declaration() {
  Time_declarationContext *_localctx = _tracker.createInstance<Time_declarationContext>(_ctx, getState());
  enterRule(_localctx, 108, VerilogParser::RuleTime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1504);
    match(VerilogParser::TIME);
    setState(1505);
    list_of_variable_identifiers();
    setState(1506);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_typeContext ------------------------------------------------------------------

VerilogParser::Net_typeContext::Net_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRI() {
  return getToken(VerilogParser::TRI, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIAND() {
  return getToken(VerilogParser::TRIAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIOR() {
  return getToken(VerilogParser::TRIOR, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIZERO() {
  return getToken(VerilogParser::TRIZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIONE() {
  return getToken(VerilogParser::TRIONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::UWIRE() {
  return getToken(VerilogParser::UWIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WIRE() {
  return getToken(VerilogParser::WIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WAND() {
  return getToken(VerilogParser::WAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WOR() {
  return getToken(VerilogParser::WOR, 0);
}


size_t VerilogParser::Net_typeContext::getRuleIndex() const {
  return VerilogParser::RuleNet_type;
}


std::any VerilogParser::Net_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_typeContext* VerilogParser::net_type() {
  Net_typeContext *_localctx = _tracker.createInstance<Net_typeContext>(_ctx, getState());
  enterRule(_localctx, 110, VerilogParser::RuleNet_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1508);
    _la = _input->LA(1);
    if (!(((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 12889859) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Electrical_declarationContext ------------------------------------------------------------------

VerilogParser::Electrical_declarationContext::Electrical_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Electrical_declarationContext::ELECTRICAL() {
  return getToken(VerilogParser::ELECTRICAL, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Electrical_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Electrical_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Electrical_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleElectrical_declaration;
}


std::any VerilogParser::Electrical_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitElectrical_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Electrical_declarationContext* VerilogParser::electrical_declaration() {
  Electrical_declarationContext *_localctx = _tracker.createInstance<Electrical_declarationContext>(_ctx, getState());
  enterRule(_localctx, 112, VerilogParser::RuleElectrical_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1510);
    match(VerilogParser::ELECTRICAL);
    setState(1511);
    list_of_port_identifiers();
    setState(1512);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_variable_typeContext ------------------------------------------------------------------

VerilogParser::Output_variable_typeContext::Output_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Output_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_variable_type;
}


std::any VerilogParser::Output_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_variable_typeContext* VerilogParser::output_variable_type() {
  Output_variable_typeContext *_localctx = _tracker.createInstance<Output_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 114, VerilogParser::RuleOutput_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1514);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::INTEGER

    || _la == VerilogParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_typeContext ------------------------------------------------------------------

VerilogParser::Real_typeContext::Real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Real_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Real_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleReal_type;
}


std::any VerilogParser::Real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_typeContext* VerilogParser::real_type() {
  Real_typeContext *_localctx = _tracker.createInstance<Real_typeContext>(_ctx, getState());
  enterRule(_localctx, 116, VerilogParser::RuleReal_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1527);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1516);
      real_identifier();
      setState(1520);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1517);
        dimension();
        setState(1522);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1523);
      real_identifier();
      setState(1524);
      match(VerilogParser::EQ);
      setState(1525);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_typeContext ------------------------------------------------------------------

VerilogParser::Variable_typeContext::Variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Variable_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_type;
}


std::any VerilogParser::Variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_typeContext* VerilogParser::variable_type() {
  Variable_typeContext *_localctx = _tracker.createInstance<Variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 118, VerilogParser::RuleVariable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1540);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1529);
      variable_identifier();
      setState(1533);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1530);
        dimension();
        setState(1535);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1536);
      variable_identifier();
      setState(1537);
      match(VerilogParser::EQ);
      setState(1538);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drive_strengthContext ------------------------------------------------------------------

VerilogParser::Drive_strengthContext::Drive_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Drive_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Drive_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZONE() {
  return getToken(VerilogParser::HIGHZONE, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZZERO() {
  return getToken(VerilogParser::HIGHZZERO, 0);
}


size_t VerilogParser::Drive_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleDrive_strength;
}


std::any VerilogParser::Drive_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDrive_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Drive_strengthContext* VerilogParser::drive_strength() {
  Drive_strengthContext *_localctx = _tracker.createInstance<Drive_strengthContext>(_ctx, getState());
  enterRule(_localctx, 120, VerilogParser::RuleDrive_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1578);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1542);
      match(VerilogParser::LP);
      setState(1543);
      strength0();
      setState(1544);
      match(VerilogParser::CO);
      setState(1545);
      strength1();
      setState(1546);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1548);
      match(VerilogParser::LP);
      setState(1549);
      strength1();
      setState(1550);
      match(VerilogParser::CO);
      setState(1551);
      strength0();
      setState(1552);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1554);
      match(VerilogParser::LP);
      setState(1555);
      strength0();
      setState(1556);
      match(VerilogParser::CO);
      setState(1557);
      match(VerilogParser::HIGHZONE);
      setState(1558);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1560);
      match(VerilogParser::LP);
      setState(1561);
      strength1();
      setState(1562);
      match(VerilogParser::CO);
      setState(1563);
      match(VerilogParser::HIGHZZERO);
      setState(1564);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1566);
      match(VerilogParser::LP);
      setState(1567);
      match(VerilogParser::HIGHZZERO);
      setState(1568);
      match(VerilogParser::CO);
      setState(1569);
      strength1();
      setState(1570);
      match(VerilogParser::RP);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1572);
      match(VerilogParser::LP);
      setState(1573);
      match(VerilogParser::HIGHZONE);
      setState(1574);
      match(VerilogParser::CO);
      setState(1575);
      strength0();
      setState(1576);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength0Context ------------------------------------------------------------------

VerilogParser::Strength0Context::Strength0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength0Context::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::STRONGZERO() {
  return getToken(VerilogParser::STRONGZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::PULLZERO() {
  return getToken(VerilogParser::PULLZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::WEAKZERO() {
  return getToken(VerilogParser::WEAKZERO, 0);
}


size_t VerilogParser::Strength0Context::getRuleIndex() const {
  return VerilogParser::RuleStrength0;
}


std::any VerilogParser::Strength0Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength0(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength0Context* VerilogParser::strength0() {
  Strength0Context *_localctx = _tracker.createInstance<Strength0Context>(_ctx, getState());
  enterRule(_localctx, 122, VerilogParser::RuleStrength0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1580);
    _la = _input->LA(1);
    if (!(((((_la - 89) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 89)) & 4398056996865) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength1Context ------------------------------------------------------------------

VerilogParser::Strength1Context::Strength1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength1Context::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::STRONGONE() {
  return getToken(VerilogParser::STRONGONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::PULLONE() {
  return getToken(VerilogParser::PULLONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::WEAKONE() {
  return getToken(VerilogParser::WEAKONE, 0);
}


size_t VerilogParser::Strength1Context::getRuleIndex() const {
  return VerilogParser::RuleStrength1;
}


std::any VerilogParser::Strength1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength1(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength1Context* VerilogParser::strength1() {
  Strength1Context *_localctx = _tracker.createInstance<Strength1Context>(_ctx, getState());
  enterRule(_localctx, 124, VerilogParser::RuleStrength1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1582);
    _la = _input->LA(1);
    if (!(((((_la - 87) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 87)) & 8796113993729) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Charge_strengthContext ------------------------------------------------------------------

VerilogParser::Charge_strengthContext::Charge_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::SMALL() {
  return getToken(VerilogParser::SMALL, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::MEDIUM() {
  return getToken(VerilogParser::MEDIUM, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LARGE() {
  return getToken(VerilogParser::LARGE, 0);
}


size_t VerilogParser::Charge_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleCharge_strength;
}


std::any VerilogParser::Charge_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCharge_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Charge_strengthContext* VerilogParser::charge_strength() {
  Charge_strengthContext *_localctx = _tracker.createInstance<Charge_strengthContext>(_ctx, getState());
  enterRule(_localctx, 126, VerilogParser::RuleCharge_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1593);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1584);
      match(VerilogParser::LP);
      setState(1585);
      match(VerilogParser::SMALL);
      setState(1586);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1587);
      match(VerilogParser::LP);
      setState(1588);
      match(VerilogParser::MEDIUM);
      setState(1589);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1590);
      match(VerilogParser::LP);
      setState(1591);
      match(VerilogParser::LARGE);
      setState(1592);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay3Context ------------------------------------------------------------------

VerilogParser::Delay3Context::Delay3Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay3Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay3Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay3Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay3Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay3Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay3Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Delay3Context::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Delay3Context::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Delay3Context::getRuleIndex() const {
  return VerilogParser::RuleDelay3;
}


std::any VerilogParser::Delay3Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay3(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay3Context* VerilogParser::delay3() {
  Delay3Context *_localctx = _tracker.createInstance<Delay3Context>(_ctx, getState());
  enterRule(_localctx, 128, VerilogParser::RuleDelay3);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1595);
      match(VerilogParser::HA);
      setState(1596);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1597);
      match(VerilogParser::HA);
      setState(1598);
      match(VerilogParser::LP);
      setState(1599);
      mintypmax_expression();
      setState(1606);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1600);
        match(VerilogParser::CO);
        setState(1601);
        mintypmax_expression();
        setState(1604);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CO) {
          setState(1602);
          match(VerilogParser::CO);
          setState(1603);
          mintypmax_expression();
        }
      }
      setState(1608);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay2Context ------------------------------------------------------------------

VerilogParser::Delay2Context::Delay2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay2Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay2Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay2Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay2Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay2Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay2Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Delay2Context::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Delay2Context::getRuleIndex() const {
  return VerilogParser::RuleDelay2;
}


std::any VerilogParser::Delay2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay2(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay2Context* VerilogParser::delay2() {
  Delay2Context *_localctx = _tracker.createInstance<Delay2Context>(_ctx, getState());
  enterRule(_localctx, 130, VerilogParser::RuleDelay2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1623);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1612);
      match(VerilogParser::HA);
      setState(1613);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1614);
      match(VerilogParser::HA);
      setState(1615);
      match(VerilogParser::LP);
      setState(1616);
      mintypmax_expression();
      setState(1619);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1617);
        match(VerilogParser::CO);
        setState(1618);
        mintypmax_expression();
      }
      setState(1621);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_valueContext ------------------------------------------------------------------

VerilogParser::Delay_valueContext::Delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Delay_valueContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::Delay_valueContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Delay_valueContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Delay_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_value;
}


std::any VerilogParser::Delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_valueContext* VerilogParser::delay_value() {
  Delay_valueContext *_localctx = _tracker.createInstance<Delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 132, VerilogParser::RuleDelay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1628);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(1625);
        unsigned_number();
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::UNIT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(1626);
        real_number();
        break;
      }

      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 3);
        setState(1627);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_defparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_defparam_assignmentsContext::List_of_defparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Defparam_assignmentContext *> VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment() {
  return getRuleContexts<VerilogParser::Defparam_assignmentContext>();
}

VerilogParser::Defparam_assignmentContext* VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Defparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_defparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_defparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_defparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_defparam_assignments;
}


std::any VerilogParser::List_of_defparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_defparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::list_of_defparam_assignments() {
  List_of_defparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_defparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 134, VerilogParser::RuleList_of_defparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1630);
    defparam_assignment();
    setState(1635);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1631);
      match(VerilogParser::CO);
      setState(1632);
      defparam_assignment();
      setState(1637);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_event_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_event_identifiersContext::List_of_event_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Event_idContext *> VerilogParser::List_of_event_identifiersContext::event_id() {
  return getRuleContexts<VerilogParser::Event_idContext>();
}

VerilogParser::Event_idContext* VerilogParser::List_of_event_identifiersContext::event_id(size_t i) {
  return getRuleContext<VerilogParser::Event_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_event_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_event_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_event_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_event_identifiers;
}


std::any VerilogParser::List_of_event_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_event_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::list_of_event_identifiers() {
  List_of_event_identifiersContext *_localctx = _tracker.createInstance<List_of_event_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 136, VerilogParser::RuleList_of_event_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1638);
    event_id();
    setState(1643);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1639);
      match(VerilogParser::CO);
      setState(1640);
      event_id();
      setState(1645);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_idContext ------------------------------------------------------------------

VerilogParser::Event_idContext::Event_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Event_identifierContext* VerilogParser::Event_idContext::event_identifier() {
  return getRuleContext<VerilogParser::Event_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Event_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Event_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Event_idContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_id;
}


std::any VerilogParser::Event_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_idContext* VerilogParser::event_id() {
  Event_idContext *_localctx = _tracker.createInstance<Event_idContext>(_ctx, getState());
  enterRule(_localctx, 138, VerilogParser::RuleEvent_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1646);
    event_identifier();
    setState(1650);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1647);
      dimension();
      setState(1652);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_decl_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_decl_assignmentsContext::List_of_net_decl_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_decl_assignmentContext *> VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment() {
  return getRuleContexts<VerilogParser::Net_decl_assignmentContext>();
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_decl_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_decl_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_decl_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_decl_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_decl_assignments;
}


std::any VerilogParser::List_of_net_decl_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_decl_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::list_of_net_decl_assignments() {
  List_of_net_decl_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_decl_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 140, VerilogParser::RuleList_of_net_decl_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1653);
    net_decl_assignment();
    setState(1658);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1654);
      match(VerilogParser::CO);
      setState(1655);
      net_decl_assignment();
      setState(1660);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_net_identifiersContext::List_of_net_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_idContext *> VerilogParser::List_of_net_identifiersContext::net_id() {
  return getRuleContexts<VerilogParser::Net_idContext>();
}

VerilogParser::Net_idContext* VerilogParser::List_of_net_identifiersContext::net_id(size_t i) {
  return getRuleContext<VerilogParser::Net_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_identifiers;
}


std::any VerilogParser::List_of_net_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::list_of_net_identifiers() {
  List_of_net_identifiersContext *_localctx = _tracker.createInstance<List_of_net_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 142, VerilogParser::RuleList_of_net_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1661);
    net_id();
    setState(1666);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1662);
      match(VerilogParser::CO);
      setState(1663);
      net_id();
      setState(1668);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_idContext ------------------------------------------------------------------

VerilogParser::Net_idContext::Net_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_idContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Net_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Net_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Net_idContext::getRuleIndex() const {
  return VerilogParser::RuleNet_id;
}


std::any VerilogParser::Net_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_idContext* VerilogParser::net_id() {
  Net_idContext *_localctx = _tracker.createInstance<Net_idContext>(_ctx, getState());
  enterRule(_localctx, 144, VerilogParser::RuleNet_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1669);
    net_identifier();
    setState(1673);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1670);
      dimension();
      setState(1675);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_param_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_param_assignmentsContext::List_of_param_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Param_assignmentContext *> VerilogParser::List_of_param_assignmentsContext::param_assignment() {
  return getRuleContexts<VerilogParser::Param_assignmentContext>();
}

VerilogParser::Param_assignmentContext* VerilogParser::List_of_param_assignmentsContext::param_assignment(size_t i) {
  return getRuleContext<VerilogParser::Param_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_param_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_param_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_param_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_param_assignments;
}


std::any VerilogParser::List_of_param_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_param_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::list_of_param_assignments() {
  List_of_param_assignmentsContext *_localctx = _tracker.createInstance<List_of_param_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 146, VerilogParser::RuleList_of_param_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1676);
    param_assignment();
    setState(1681);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1677);
        match(VerilogParser::CO);
        setState(1678);
        param_assignment(); 
      }
      setState(1683);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_port_identifiersContext::List_of_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_identifierContext *> VerilogParser::List_of_port_identifiersContext::port_identifier() {
  return getRuleContexts<VerilogParser::Port_identifierContext>();
}

VerilogParser::Port_identifierContext* VerilogParser::List_of_port_identifiersContext::port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Port_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_identifiers;
}


std::any VerilogParser::List_of_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::list_of_port_identifiers() {
  List_of_port_identifiersContext *_localctx = _tracker.createInstance<List_of_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 148, VerilogParser::RuleList_of_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1684);
    port_identifier();
    setState(1689);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1685);
        match(VerilogParser::CO);
        setState(1686);
        port_identifier(); 
      }
      setState(1691);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_real_identifiersContext::List_of_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Real_typeContext *> VerilogParser::List_of_real_identifiersContext::real_type() {
  return getRuleContexts<VerilogParser::Real_typeContext>();
}

VerilogParser::Real_typeContext* VerilogParser::List_of_real_identifiersContext::real_type(size_t i) {
  return getRuleContext<VerilogParser::Real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_real_identifiers;
}


std::any VerilogParser::List_of_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::list_of_real_identifiers() {
  List_of_real_identifiersContext *_localctx = _tracker.createInstance<List_of_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 150, VerilogParser::RuleList_of_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1692);
    real_type();
    setState(1697);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1693);
      match(VerilogParser::CO);
      setState(1694);
      real_type();
      setState(1699);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_specparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_specparam_assignmentsContext::List_of_specparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specparam_assignmentContext *> VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment() {
  return getRuleContexts<VerilogParser::Specparam_assignmentContext>();
}

VerilogParser::Specparam_assignmentContext* VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Specparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_specparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_specparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_specparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_specparam_assignments;
}


std::any VerilogParser::List_of_specparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_specparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::list_of_specparam_assignments() {
  List_of_specparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_specparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 152, VerilogParser::RuleList_of_specparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1700);
    specparam_assignment();
    setState(1705);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1701);
      match(VerilogParser::CO);
      setState(1702);
      specparam_assignment();
      setState(1707);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_identifiersContext::List_of_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Variable_typeContext *> VerilogParser::List_of_variable_identifiersContext::variable_type() {
  return getRuleContexts<VerilogParser::Variable_typeContext>();
}

VerilogParser::Variable_typeContext* VerilogParser::List_of_variable_identifiersContext::variable_type(size_t i) {
  return getRuleContext<VerilogParser::Variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_identifiers;
}


std::any VerilogParser::List_of_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::list_of_variable_identifiers() {
  List_of_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 154, VerilogParser::RuleList_of_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1708);
    variable_type();
    setState(1713);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1709);
      match(VerilogParser::CO);
      setState(1710);
      variable_type();
      setState(1715);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_port_identifiersContext::List_of_variable_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Var_port_idContext *> VerilogParser::List_of_variable_port_identifiersContext::var_port_id() {
  return getRuleContexts<VerilogParser::Var_port_idContext>();
}

VerilogParser::Var_port_idContext* VerilogParser::List_of_variable_port_identifiersContext::var_port_id(size_t i) {
  return getRuleContext<VerilogParser::Var_port_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_port_identifiers;
}


std::any VerilogParser::List_of_variable_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::list_of_variable_port_identifiers() {
  List_of_variable_port_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 156, VerilogParser::RuleList_of_variable_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1716);
    var_port_id();
    setState(1721);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1717);
        match(VerilogParser::CO);
        setState(1718);
        var_port_id(); 
      }
      setState(1723);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_port_idContext ------------------------------------------------------------------

VerilogParser::Var_port_idContext::Var_port_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Var_port_idContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Var_port_idContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Var_port_idContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Var_port_idContext::getRuleIndex() const {
  return VerilogParser::RuleVar_port_id;
}


std::any VerilogParser::Var_port_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVar_port_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Var_port_idContext* VerilogParser::var_port_id() {
  Var_port_idContext *_localctx = _tracker.createInstance<Var_port_idContext>(_ctx, getState());
  enterRule(_localctx, 158, VerilogParser::RuleVar_port_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1724);
    port_identifier();
    setState(1727);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(1725);
      match(VerilogParser::EQ);
      setState(1726);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Defparam_assignmentContext::Defparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Defparam_assignmentContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Defparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Defparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Defparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleDefparam_assignment;
}


std::any VerilogParser::Defparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Defparam_assignmentContext* VerilogParser::defparam_assignment() {
  Defparam_assignmentContext *_localctx = _tracker.createInstance<Defparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 160, VerilogParser::RuleDefparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1729);
    hierarchical_identifier();
    setState(1730);
    match(VerilogParser::EQ);
    setState(1731);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_decl_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_decl_assignmentContext::Net_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_decl_assignmentContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Net_decl_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_decl_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_decl_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_decl_assignment;
}


std::any VerilogParser::Net_decl_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_decl_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::net_decl_assignment() {
  Net_decl_assignmentContext *_localctx = _tracker.createInstance<Net_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 162, VerilogParser::RuleNet_decl_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1733);
    net_identifier();
    setState(1734);
    match(VerilogParser::EQ);
    setState(1735);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_assignmentContext ------------------------------------------------------------------

VerilogParser::Param_assignmentContext::Param_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parameter_identifierContext* VerilogParser::Param_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Param_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Param_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Param_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParam_assignment;
}


std::any VerilogParser::Param_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Param_assignmentContext* VerilogParser::param_assignment() {
  Param_assignmentContext *_localctx = _tracker.createInstance<Param_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 164, VerilogParser::RuleParam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1737);
    parameter_identifier();
    setState(1738);
    match(VerilogParser::EQ);
    setState(1739);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Specparam_assignmentContext::Specparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_identifierContext* VerilogParser::Specparam_assignmentContext::specparam_identifier() {
  return getRuleContext<VerilogParser::Specparam_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Specparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::Specparam_assignmentContext::pulse_control_specparam() {
  return getRuleContext<VerilogParser::Pulse_control_specparamContext>(0);
}


size_t VerilogParser::Specparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_assignment;
}


std::any VerilogParser::Specparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_assignmentContext* VerilogParser::specparam_assignment() {
  Specparam_assignmentContext *_localctx = _tracker.createInstance<Specparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 166, VerilogParser::RuleSpecparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1746);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1741);
        specparam_identifier();
        setState(1742);
        match(VerilogParser::EQ);
        setState(1743);
        constant_mintypmax_expression();
        break;
      }

      case VerilogParser::PATHPULSEDL: {
        enterOuterAlt(_localctx, 2);
        setState(1745);
        pulse_control_specparam();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulse_control_specparamContext ------------------------------------------------------------------

VerilogParser::Pulse_control_specparamContext::Pulse_control_specparamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::PATHPULSEDL() {
  return getToken(VerilogParser::PATHPULSEDL, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::Pulse_control_specparamContext::reject_limit_value() {
  return getRuleContext<VerilogParser::Reject_limit_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Error_limit_valueContext* VerilogParser::Pulse_control_specparamContext::error_limit_value() {
  return getRuleContext<VerilogParser::Error_limit_valueContext>(0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::DL() {
  return getToken(VerilogParser::DL, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Pulse_control_specparamContext::getRuleIndex() const {
  return VerilogParser::RulePulse_control_specparam;
}


std::any VerilogParser::Pulse_control_specparamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulse_control_specparam(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::pulse_control_specparam() {
  Pulse_control_specparamContext *_localctx = _tracker.createInstance<Pulse_control_specparamContext>(_ctx, getState());
  enterRule(_localctx, 168, VerilogParser::RulePulse_control_specparam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1771);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1748);
      match(VerilogParser::PATHPULSEDL);
      setState(1749);
      match(VerilogParser::EQ);
      setState(1750);
      match(VerilogParser::LP);
      setState(1751);
      reject_limit_value();
      setState(1754);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1752);
        match(VerilogParser::CO);
        setState(1753);
        error_limit_value();
      }
      setState(1756);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1758);
      match(VerilogParser::PATHPULSEDL);
      setState(1759);
      specify_input_terminal_descriptor();
      setState(1760);
      match(VerilogParser::DL);
      setState(1761);
      specify_output_terminal_descriptor();
      setState(1762);
      match(VerilogParser::EQ);
      setState(1763);
      match(VerilogParser::LP);
      setState(1764);
      reject_limit_value();
      setState(1767);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1765);
        match(VerilogParser::CO);
        setState(1766);
        error_limit_value();
      }
      setState(1769);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_limit_valueContext ------------------------------------------------------------------

VerilogParser::Error_limit_valueContext::Error_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Error_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Error_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleError_limit_value;
}


std::any VerilogParser::Error_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitError_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Error_limit_valueContext* VerilogParser::error_limit_value() {
  Error_limit_valueContext *_localctx = _tracker.createInstance<Error_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 170, VerilogParser::RuleError_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1773);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reject_limit_valueContext ------------------------------------------------------------------

VerilogParser::Reject_limit_valueContext::Reject_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Reject_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Reject_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleReject_limit_value;
}


std::any VerilogParser::Reject_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReject_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::reject_limit_value() {
  Reject_limit_valueContext *_localctx = _tracker.createInstance<Reject_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 172, VerilogParser::RuleReject_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1775);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_valueContext ------------------------------------------------------------------

VerilogParser::Limit_valueContext::Limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Limit_valueContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleLimit_value;
}


std::any VerilogParser::Limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLimit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Limit_valueContext* VerilogParser::limit_value() {
  Limit_valueContext *_localctx = _tracker.createInstance<Limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 174, VerilogParser::RuleLimit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1777);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DimensionContext ------------------------------------------------------------------

VerilogParser::DimensionContext::DimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::DimensionContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Dimension_constant_expressionContext *> VerilogParser::DimensionContext::dimension_constant_expression() {
  return getRuleContexts<VerilogParser::Dimension_constant_expressionContext>();
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::DimensionContext::dimension_constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Dimension_constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::DimensionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::DimensionContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::DimensionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension;
}


std::any VerilogParser::DimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DimensionContext* VerilogParser::dimension() {
  DimensionContext *_localctx = _tracker.createInstance<DimensionContext>(_ctx, getState());
  enterRule(_localctx, 176, VerilogParser::RuleDimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1779);
    match(VerilogParser::LB);
    setState(1780);
    dimension_constant_expression();
    setState(1781);
    match(VerilogParser::CL);
    setState(1782);
    dimension_constant_expression();
    setState(1783);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_Context ------------------------------------------------------------------

VerilogParser::Range_Context::Range_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Range_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_Context::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_Context::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Range_Context::getRuleIndex() const {
  return VerilogParser::RuleRange_;
}


std::any VerilogParser::Range_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_Context* VerilogParser::range_() {
  Range_Context *_localctx = _tracker.createInstance<Range_Context>(_ctx, getState());
  enterRule(_localctx, 178, VerilogParser::RuleRange_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1785);
    match(VerilogParser::LB);
    setState(1786);
    msb_constant_expression();
    setState(1787);
    match(VerilogParser::CL);
    setState(1788);
    lsb_constant_expression();
    setState(1789);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_declarationContext ------------------------------------------------------------------

VerilogParser::Function_declarationContext::Function_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Function_declarationContext::FUNCTION() {
  return getToken(VerilogParser::FUNCTION, 0);
}

VerilogParser::Function_identifierContext* VerilogParser::Function_declarationContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Function_statementContext* VerilogParser::Function_declarationContext::function_statement() {
  return getRuleContext<VerilogParser::Function_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::ENDFUNCTION() {
  return getToken(VerilogParser::ENDFUNCTION, 0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::Function_declarationContext::function_range_or_type() {
  return getRuleContext<VerilogParser::Function_range_or_typeContext>(0);
}

std::vector<VerilogParser::Function_item_declarationContext *> VerilogParser::Function_declarationContext::function_item_declaration() {
  return getRuleContexts<VerilogParser::Function_item_declarationContext>();
}

VerilogParser::Function_item_declarationContext* VerilogParser::Function_declarationContext::function_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Function_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Function_port_listContext* VerilogParser::Function_declarationContext::function_port_list() {
  return getRuleContext<VerilogParser::Function_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Function_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Function_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_declaration;
}


std::any VerilogParser::Function_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_declarationContext* VerilogParser::function_declaration() {
  Function_declarationContext *_localctx = _tracker.createInstance<Function_declarationContext>(_ctx, getState());
  enterRule(_localctx, 180, VerilogParser::RuleFunction_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1829);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1791);
      match(VerilogParser::FUNCTION);
      setState(1793);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1792);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1796);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 61) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 61)) & 18032003580428289) != 0) || _la == VerilogParser::LB) {
        setState(1795);
        function_range_or_type();
      }
      setState(1798);
      function_identifier();
      setState(1799);
      match(VerilogParser::SC);
      setState(1801); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1800);
                function_item_declaration();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1803); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1805);
      function_statement();
      setState(1806);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1808);
      match(VerilogParser::FUNCTION);
      setState(1810);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1809);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1813);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 61) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 61)) & 18032003580428289) != 0) || _la == VerilogParser::LB) {
        setState(1812);
        function_range_or_type();
      }
      setState(1815);
      function_identifier();
      setState(1816);
      match(VerilogParser::LP);
      setState(1817);
      function_port_list();
      setState(1818);
      match(VerilogParser::RP);
      setState(1819);
      match(VerilogParser::SC);
      setState(1823);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1820);
          block_item_declaration(); 
        }
        setState(1825);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
      }
      setState(1826);
      function_statement();
      setState(1827);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_item_declarationContext ------------------------------------------------------------------

VerilogParser::Function_item_declarationContext::Function_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Function_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Function_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Function_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_item_declaration;
}


std::any VerilogParser::Function_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_item_declarationContext* VerilogParser::function_item_declaration() {
  Function_item_declarationContext *_localctx = _tracker.createInstance<Function_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 182, VerilogParser::RuleFunction_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1841);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1831);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1835);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1832);
        attribute_instance();
        setState(1837);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1838);
      tf_input_declaration();
      setState(1839);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_port_listContext ------------------------------------------------------------------

VerilogParser::Function_port_listContext::Function_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Func_port_itemContext *> VerilogParser::Function_port_listContext::func_port_item() {
  return getRuleContexts<VerilogParser::Func_port_itemContext>();
}

VerilogParser::Func_port_itemContext* VerilogParser::Function_port_listContext::func_port_item(size_t i) {
  return getRuleContext<VerilogParser::Func_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_port_list;
}


std::any VerilogParser::Function_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_port_listContext* VerilogParser::function_port_list() {
  Function_port_listContext *_localctx = _tracker.createInstance<Function_port_listContext>(_ctx, getState());
  enterRule(_localctx, 184, VerilogParser::RuleFunction_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1843);
    func_port_item();
    setState(1848);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1844);
      match(VerilogParser::CO);
      setState(1845);
      func_port_item();
      setState(1850);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_port_itemContext ------------------------------------------------------------------

VerilogParser::Func_port_itemContext::Func_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Func_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Func_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Func_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Func_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleFunc_port_item;
}


std::any VerilogParser::Func_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunc_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Func_port_itemContext* VerilogParser::func_port_item() {
  Func_port_itemContext *_localctx = _tracker.createInstance<Func_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 186, VerilogParser::RuleFunc_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1854);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(1851);
      attribute_instance();
      setState(1856);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1857);
    tf_input_declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_range_or_typeContext ------------------------------------------------------------------

VerilogParser::Function_range_or_typeContext::Function_range_or_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Range_Context* VerilogParser::Function_range_or_typeContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Function_range_or_typeContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_range_or_type;
}


std::any VerilogParser::Function_range_or_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_range_or_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::function_range_or_type() {
  Function_range_or_typeContext *_localctx = _tracker.createInstance<Function_range_or_typeContext>(_ctx, getState());
  enterRule(_localctx, 188, VerilogParser::RuleFunction_range_or_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1868);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LB: {
        enterOuterAlt(_localctx, 1);
        setState(1859);
        range_();
        break;
      }

      case VerilogParser::SIGNED: {
        enterOuterAlt(_localctx, 2);
        setState(1860);
        match(VerilogParser::SIGNED);
        setState(1862);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(1861);
          range_();
        }
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1864);
        match(VerilogParser::INTEGER);
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1865);
        match(VerilogParser::REAL);
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 5);
        setState(1866);
        match(VerilogParser::REALTIME);
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 6);
        setState(1867);
        match(VerilogParser::TIME);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_declarationContext ------------------------------------------------------------------

VerilogParser::Task_declarationContext::Task_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_declarationContext::TASK() {
  return getToken(VerilogParser::TASK, 0);
}

VerilogParser::Task_identifierContext* VerilogParser::Task_declarationContext::task_identifier() {
  return getRuleContext<VerilogParser::Task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Task_declarationContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::ENDTASK() {
  return getToken(VerilogParser::ENDTASK, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

std::vector<VerilogParser::Task_item_declarationContext *> VerilogParser::Task_declarationContext::task_item_declaration() {
  return getRuleContexts<VerilogParser::Task_item_declarationContext>();
}

VerilogParser::Task_item_declarationContext* VerilogParser::Task_declarationContext::task_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Task_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Task_port_listContext* VerilogParser::Task_declarationContext::task_port_list() {
  return getRuleContext<VerilogParser::Task_port_listContext>(0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Task_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Task_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_declaration;
}


std::any VerilogParser::Task_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_declarationContext* VerilogParser::task_declaration() {
  Task_declarationContext *_localctx = _tracker.createInstance<Task_declarationContext>(_ctx, getState());
  enterRule(_localctx, 190, VerilogParser::RuleTask_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1905);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1870);
      match(VerilogParser::TASK);
      setState(1872);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1871);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1874);
      task_identifier();
      setState(1875);
      match(VerilogParser::SC);
      setState(1879);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1876);
          task_item_declaration(); 
        }
        setState(1881);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
      }
      setState(1882);
      statement_or_null();
      setState(1883);
      match(VerilogParser::ENDTASK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1885);
      match(VerilogParser::TASK);
      setState(1887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1886);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1889);
      task_identifier();
      setState(1890);
      match(VerilogParser::LP);
      setState(1892);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 58) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 58)) & 4194307) != 0) || _la == VerilogParser::LP) {
        setState(1891);
        task_port_list();
      }
      setState(1894);
      match(VerilogParser::RP);
      setState(1895);
      match(VerilogParser::SC);
      setState(1899);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1896);
          block_item_declaration(); 
        }
        setState(1901);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
      }
      setState(1902);
      statement_or_null();
      setState(1903);
      match(VerilogParser::ENDTASK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_item_declarationContext ------------------------------------------------------------------

VerilogParser::Task_item_declarationContext::Task_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Task_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_item_declarationContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_item_declarationContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_item_declaration;
}


std::any VerilogParser::Task_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_item_declarationContext* VerilogParser::task_item_declaration() {
  Task_item_declarationContext *_localctx = _tracker.createInstance<Task_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 192, VerilogParser::RuleTask_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1935);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1907);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1911);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1908);
        attribute_instance();
        setState(1913);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1914);
      tf_input_declaration();
      setState(1915);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1920);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1917);
        attribute_instance();
        setState(1922);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1923);
      tf_output_declaration();
      setState(1924);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1929);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1926);
        attribute_instance();
        setState(1931);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1932);
      tf_inout_declaration();
      setState(1933);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_listContext ------------------------------------------------------------------

VerilogParser::Task_port_listContext::Task_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Task_port_itemContext *> VerilogParser::Task_port_listContext::task_port_item() {
  return getRuleContexts<VerilogParser::Task_port_itemContext>();
}

VerilogParser::Task_port_itemContext* VerilogParser::Task_port_listContext::task_port_item(size_t i) {
  return getRuleContext<VerilogParser::Task_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_list;
}


std::any VerilogParser::Task_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_listContext* VerilogParser::task_port_list() {
  Task_port_listContext *_localctx = _tracker.createInstance<Task_port_listContext>(_ctx, getState());
  enterRule(_localctx, 194, VerilogParser::RuleTask_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1937);
    task_port_item();
    setState(1942);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1938);
      match(VerilogParser::CO);
      setState(1939);
      task_port_item();
      setState(1944);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_itemContext ------------------------------------------------------------------

VerilogParser::Task_port_itemContext::Task_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_port_itemContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_port_itemContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_item;
}


std::any VerilogParser::Task_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_itemContext* VerilogParser::task_port_item() {
  Task_port_itemContext *_localctx = _tracker.createInstance<Task_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 196, VerilogParser::RuleTask_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1966);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1948);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1945);
        attribute_instance();
        setState(1950);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1951);
      tf_input_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1955);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1952);
        attribute_instance();
        setState(1957);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1958);
      tf_output_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1962);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1959);
        attribute_instance();
        setState(1964);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1965);
      tf_inout_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_input_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_input_declarationContext::Tf_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_input_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_input_declaration;
}


std::any VerilogParser::Tf_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::tf_input_declaration() {
  Tf_input_declarationContext *_localctx = _tracker.createInstance<Tf_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 198, VerilogParser::RuleTf_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1983);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1968);
      match(VerilogParser::INPUT);
      setState(1970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1969);
        match(VerilogParser::REG);
      }
      setState(1973);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1972);
        match(VerilogParser::SIGNED);
      }
      setState(1976);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1975);
        range_();
      }
      setState(1978);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1979);
      match(VerilogParser::INPUT);
      setState(1980);
      task_port_type();
      setState(1981);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_output_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_output_declarationContext::Tf_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_output_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_output_declaration;
}


std::any VerilogParser::Tf_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::tf_output_declaration() {
  Tf_output_declarationContext *_localctx = _tracker.createInstance<Tf_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 200, VerilogParser::RuleTf_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2000);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1985);
      match(VerilogParser::OUTPUT);
      setState(1987);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1986);
        match(VerilogParser::REG);
      }
      setState(1990);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1989);
        match(VerilogParser::SIGNED);
      }
      setState(1993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1992);
        range_();
      }
      setState(1995);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1996);
      match(VerilogParser::OUTPUT);
      setState(1997);
      task_port_type();
      setState(1998);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_inout_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_inout_declarationContext::Tf_inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_inout_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_inout_declaration;
}


std::any VerilogParser::Tf_inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_inout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::tf_inout_declaration() {
  Tf_inout_declarationContext *_localctx = _tracker.createInstance<Tf_inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 202, VerilogParser::RuleTf_inout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2017);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2002);
      match(VerilogParser::INOUT);
      setState(2004);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(2003);
        match(VerilogParser::REG);
      }
      setState(2007);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(2006);
        match(VerilogParser::SIGNED);
      }
      setState(2010);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(2009);
        range_();
      }
      setState(2012);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2013);
      match(VerilogParser::INOUT);
      setState(2014);
      task_port_type();
      setState(2015);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_typeContext ------------------------------------------------------------------

VerilogParser::Task_port_typeContext::Task_port_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Task_port_typeContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_type;
}


std::any VerilogParser::Task_port_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_typeContext* VerilogParser::task_port_type() {
  Task_port_typeContext *_localctx = _tracker.createInstance<Task_port_typeContext>(_ctx, getState());
  enterRule(_localctx, 204, VerilogParser::RuleTask_port_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2019);
    _la = _input->LA(1);
    if (!(((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & 18014411394383873) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_item_declarationContext ------------------------------------------------------------------

VerilogParser::Block_item_declarationContext::Block_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Block_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Block_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Block_item_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::Event_declarationContext* VerilogParser::Block_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Block_item_declarationContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Block_item_declarationContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}


size_t VerilogParser::Block_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_item_declaration;
}


std::any VerilogParser::Block_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_item_declarationContext* VerilogParser::block_item_declaration() {
  Block_item_declarationContext *_localctx = _tracker.createInstance<Block_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 206, VerilogParser::RuleBlock_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2102);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2024);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2021);
        attribute_instance();
        setState(2026);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2027);
      match(VerilogParser::REG);
      setState(2029);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(2028);
        match(VerilogParser::SIGNED);
      }
      setState(2032);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(2031);
        range_();
      }
      setState(2034);
      list_of_block_variable_identifiers();
      setState(2035);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2040);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2037);
        attribute_instance();
        setState(2042);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2043);
      match(VerilogParser::INTEGER);
      setState(2044);
      list_of_block_variable_identifiers();
      setState(2045);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2050);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2047);
        attribute_instance();
        setState(2052);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2053);
      match(VerilogParser::TIME);
      setState(2054);
      list_of_block_variable_identifiers();
      setState(2055);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2060);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2057);
        attribute_instance();
        setState(2062);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2063);
      match(VerilogParser::REAL);
      setState(2064);
      list_of_block_real_identifiers();
      setState(2065);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2070);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2067);
        attribute_instance();
        setState(2072);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2073);
      match(VerilogParser::REALTIME);
      setState(2074);
      list_of_block_real_identifiers();
      setState(2075);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2080);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2077);
        attribute_instance();
        setState(2082);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2083);
      event_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2087);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2084);
        attribute_instance();
        setState(2089);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2090);
      local_parameter_declaration();
      setState(2091);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2096);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2093);
        attribute_instance();
        setState(2098);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2099);
      parameter_declaration();
      setState(2100);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_variable_identifiersContext::List_of_block_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_variable_typeContext *> VerilogParser::List_of_block_variable_identifiersContext::block_variable_type() {
  return getRuleContexts<VerilogParser::Block_variable_typeContext>();
}

VerilogParser::Block_variable_typeContext* VerilogParser::List_of_block_variable_identifiersContext::block_variable_type(size_t i) {
  return getRuleContext<VerilogParser::Block_variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_variable_identifiers;
}


std::any VerilogParser::List_of_block_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::list_of_block_variable_identifiers() {
  List_of_block_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_block_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 208, VerilogParser::RuleList_of_block_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2104);
    block_variable_type();
    setState(2109);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2105);
      match(VerilogParser::CO);
      setState(2106);
      block_variable_type();
      setState(2111);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_real_identifiersContext::List_of_block_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_real_typeContext *> VerilogParser::List_of_block_real_identifiersContext::block_real_type() {
  return getRuleContexts<VerilogParser::Block_real_typeContext>();
}

VerilogParser::Block_real_typeContext* VerilogParser::List_of_block_real_identifiersContext::block_real_type(size_t i) {
  return getRuleContext<VerilogParser::Block_real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_real_identifiers;
}


std::any VerilogParser::List_of_block_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::list_of_block_real_identifiers() {
  List_of_block_real_identifiersContext *_localctx = _tracker.createInstance<List_of_block_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 210, VerilogParser::RuleList_of_block_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2112);
    block_real_type();
    setState(2117);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2113);
      match(VerilogParser::CO);
      setState(2114);
      block_real_type();
      setState(2119);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_variable_typeContext ------------------------------------------------------------------

VerilogParser::Block_variable_typeContext::Block_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Block_variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_variable_type;
}


std::any VerilogParser::Block_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_variable_typeContext* VerilogParser::block_variable_type() {
  Block_variable_typeContext *_localctx = _tracker.createInstance<Block_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 212, VerilogParser::RuleBlock_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2120);
    variable_identifier();
    setState(2124);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2121);
      dimension();
      setState(2126);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_real_typeContext ------------------------------------------------------------------

VerilogParser::Block_real_typeContext::Block_real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Block_real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_real_type;
}


std::any VerilogParser::Block_real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_real_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_real_typeContext* VerilogParser::block_real_type() {
  Block_real_typeContext *_localctx = _tracker.createInstance<Block_real_typeContext>(_ctx, getState());
  enterRule(_localctx, 214, VerilogParser::RuleBlock_real_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2127);
    real_identifier();
    setState(2131);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2128);
      dimension();
      setState(2133);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instantiationContext ------------------------------------------------------------------

VerilogParser::Gate_instantiationContext::Gate_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::Gate_instantiationContext::cmos_switchtype() {
  return getRuleContext<VerilogParser::Cmos_switchtypeContext>(0);
}

std::vector<VerilogParser::Cmos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::cmos_switch_instance() {
  return getRuleContexts<VerilogParser::Cmos_switch_instanceContext>();
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::Gate_instantiationContext::cmos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Cmos_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Delay3Context* VerilogParser::Gate_instantiationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Gate_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::Gate_instantiationContext::enable_gatetype() {
  return getRuleContext<VerilogParser::Enable_gatetypeContext>(0);
}

std::vector<VerilogParser::Enable_gate_instanceContext *> VerilogParser::Gate_instantiationContext::enable_gate_instance() {
  return getRuleContexts<VerilogParser::Enable_gate_instanceContext>();
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::Gate_instantiationContext::enable_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Enable_gate_instanceContext>(i);
}

VerilogParser::Drive_strengthContext* VerilogParser::Gate_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::Gate_instantiationContext::mos_switchtype() {
  return getRuleContext<VerilogParser::Mos_switchtypeContext>(0);
}

std::vector<VerilogParser::Mos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::mos_switch_instance() {
  return getRuleContexts<VerilogParser::Mos_switch_instanceContext>();
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::Gate_instantiationContext::mos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Mos_switch_instanceContext>(i);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::Gate_instantiationContext::n_input_gatetype() {
  return getRuleContext<VerilogParser::N_input_gatetypeContext>(0);
}

std::vector<VerilogParser::N_input_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_input_gate_instance() {
  return getRuleContexts<VerilogParser::N_input_gate_instanceContext>();
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_input_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_input_gate_instanceContext>(i);
}

VerilogParser::Delay2Context* VerilogParser::Gate_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::Gate_instantiationContext::n_output_gatetype() {
  return getRuleContext<VerilogParser::N_output_gatetypeContext>(0);
}

std::vector<VerilogParser::N_output_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_output_gate_instance() {
  return getRuleContexts<VerilogParser::N_output_gate_instanceContext>();
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_output_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_output_gate_instanceContext>(i);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_en_switchtype() {
  return getRuleContext<VerilogParser::Pass_en_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_enable_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_enable_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_enable_switch_instanceContext>();
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_enable_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_enable_switch_instanceContext>(i);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_switchtype() {
  return getRuleContext<VerilogParser::Pass_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_switch_instanceContext>();
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLDOWN() {
  return getToken(VerilogParser::PULLDOWN, 0);
}

std::vector<VerilogParser::Pull_gate_instanceContext *> VerilogParser::Gate_instantiationContext::pull_gate_instance() {
  return getRuleContexts<VerilogParser::Pull_gate_instanceContext>();
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::Gate_instantiationContext::pull_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Pull_gate_instanceContext>(i);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::Gate_instantiationContext::pulldown_strength() {
  return getRuleContext<VerilogParser::Pulldown_strengthContext>(0);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLUP() {
  return getToken(VerilogParser::PULLUP, 0);
}

VerilogParser::Pullup_strengthContext* VerilogParser::Gate_instantiationContext::pullup_strength() {
  return getRuleContext<VerilogParser::Pullup_strengthContext>(0);
}


size_t VerilogParser::Gate_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instantiation;
}


std::any VerilogParser::Gate_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instantiationContext* VerilogParser::gate_instantiation() {
  Gate_instantiationContext *_localctx = _tracker.createInstance<Gate_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 216, VerilogParser::RuleGate_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CMOS:
      case VerilogParser::RCMOS: {
        enterOuterAlt(_localctx, 1);
        setState(2134);
        cmos_switchtype();
        setState(2136);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2135);
          delay3();
        }
        setState(2138);
        cmos_switch_instance();
        setState(2143);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2139);
          match(VerilogParser::CO);
          setState(2140);
          cmos_switch_instance();
          setState(2145);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2146);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO: {
        enterOuterAlt(_localctx, 2);
        setState(2148);
        enable_gatetype();
        setState(2150);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
        case 1: {
          setState(2149);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2153);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2152);
          delay3();
        }
        setState(2155);
        enable_gate_instance();
        setState(2160);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2156);
          match(VerilogParser::CO);
          setState(2157);
          enable_gate_instance();
          setState(2162);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2163);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NMOS:
      case VerilogParser::PMOS:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS: {
        enterOuterAlt(_localctx, 3);
        setState(2165);
        mos_switchtype();
        setState(2167);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2166);
          delay3();
        }
        setState(2169);
        mos_switch_instance();
        setState(2174);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2170);
          match(VerilogParser::CO);
          setState(2171);
          mos_switch_instance();
          setState(2176);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2177);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::AND:
      case VerilogParser::NAND:
      case VerilogParser::NOR:
      case VerilogParser::OR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR: {
        enterOuterAlt(_localctx, 4);
        setState(2179);
        n_input_gatetype();
        setState(2181);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
        case 1: {
          setState(2180);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2184);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2183);
          delay2();
        }
        setState(2186);
        n_input_gate_instance();
        setState(2191);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2187);
          match(VerilogParser::CO);
          setState(2188);
          n_input_gate_instance();
          setState(2193);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2194);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUF:
      case VerilogParser::NOT: {
        enterOuterAlt(_localctx, 5);
        setState(2196);
        n_output_gatetype();
        setState(2198);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
        case 1: {
          setState(2197);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2201);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2200);
          delay2();
        }
        setState(2203);
        n_output_gate_instance();
        setState(2208);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2204);
          match(VerilogParser::CO);
          setState(2205);
          n_output_gate_instance();
          setState(2210);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2211);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO: {
        enterOuterAlt(_localctx, 6);
        setState(2213);
        pass_en_switchtype();
        setState(2215);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2214);
          delay2();
        }
        setState(2217);
        pass_enable_switch_instance();
        setState(2222);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2218);
          match(VerilogParser::CO);
          setState(2219);
          pass_enable_switch_instance();
          setState(2224);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2225);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRAN:
      case VerilogParser::TRAN: {
        enterOuterAlt(_localctx, 7);
        setState(2227);
        pass_switchtype();
        setState(2228);
        pass_switch_instance();
        setState(2233);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2229);
          match(VerilogParser::CO);
          setState(2230);
          pass_switch_instance();
          setState(2235);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2236);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLDOWN: {
        enterOuterAlt(_localctx, 8);
        setState(2238);
        match(VerilogParser::PULLDOWN);
        setState(2240);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
        case 1: {
          setState(2239);
          pulldown_strength();
          break;
        }

        default:
          break;
        }
        setState(2242);
        pull_gate_instance();
        setState(2247);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2243);
          match(VerilogParser::CO);
          setState(2244);
          pull_gate_instance();
          setState(2249);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2250);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLUP: {
        enterOuterAlt(_localctx, 9);
        setState(2252);
        match(VerilogParser::PULLUP);
        setState(2254);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
        case 1: {
          setState(2253);
          pullup_strength();
          break;
        }

        default:
          break;
        }
        setState(2256);
        pull_gate_instance();
        setState(2261);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2257);
          match(VerilogParser::CO);
          setState(2258);
          pull_gate_instance();
          setState(2263);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2264);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Cmos_switch_instanceContext::Cmos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Cmos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Cmos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Cmos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::ncontrol_terminal() {
  return getRuleContext<VerilogParser::Ncontrol_terminalContext>(0);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::pcontrol_terminal() {
  return getRuleContext<VerilogParser::Pcontrol_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Cmos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Cmos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switch_instance;
}


std::any VerilogParser::Cmos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::cmos_switch_instance() {
  Cmos_switch_instanceContext *_localctx = _tracker.createInstance<Cmos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 218, VerilogParser::RuleCmos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2268);
      name_of_gate_instance();
    }
    setState(2271);
    match(VerilogParser::LP);
    setState(2272);
    output_terminal();
    setState(2273);
    match(VerilogParser::CO);
    setState(2274);
    input_terminal();
    setState(2275);
    match(VerilogParser::CO);
    setState(2276);
    ncontrol_terminal();
    setState(2277);
    match(VerilogParser::CO);
    setState(2278);
    pcontrol_terminal();
    setState(2279);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Enable_gate_instanceContext::Enable_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Enable_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Enable_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Enable_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Enable_gate_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Enable_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Enable_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gate_instance;
}


std::any VerilogParser::Enable_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::enable_gate_instance() {
  Enable_gate_instanceContext *_localctx = _tracker.createInstance<Enable_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 220, VerilogParser::RuleEnable_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2281);
      name_of_gate_instance();
    }
    setState(2284);
    match(VerilogParser::LP);
    setState(2285);
    output_terminal();
    setState(2286);
    match(VerilogParser::CO);
    setState(2287);
    input_terminal();
    setState(2288);
    match(VerilogParser::CO);
    setState(2289);
    enable_terminal();
    setState(2290);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Mos_switch_instanceContext::Mos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Mos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Mos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Mos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Mos_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Mos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Mos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switch_instance;
}


std::any VerilogParser::Mos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::mos_switch_instance() {
  Mos_switch_instanceContext *_localctx = _tracker.createInstance<Mos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 222, VerilogParser::RuleMos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2292);
      name_of_gate_instance();
    }
    setState(2295);
    match(VerilogParser::LP);
    setState(2296);
    output_terminal();
    setState(2297);
    match(VerilogParser::CO);
    setState(2298);
    input_terminal();
    setState(2299);
    match(VerilogParser::CO);
    setState(2300);
    enable_terminal();
    setState(2301);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_input_gate_instanceContext::N_input_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::N_input_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::N_input_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::N_input_gate_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::N_input_gate_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_input_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_input_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gate_instance;
}


std::any VerilogParser::N_input_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::n_input_gate_instance() {
  N_input_gate_instanceContext *_localctx = _tracker.createInstance<N_input_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 224, VerilogParser::RuleN_input_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2304);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2303);
      name_of_gate_instance();
    }
    setState(2306);
    match(VerilogParser::LP);
    setState(2307);
    output_terminal();
    setState(2308);
    match(VerilogParser::CO);
    setState(2309);
    input_terminal();
    setState(2314);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2310);
      match(VerilogParser::CO);
      setState(2311);
      input_terminal();
      setState(2316);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2317);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_output_gate_instanceContext::N_output_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Output_terminalContext *> VerilogParser::N_output_gate_instanceContext::output_terminal() {
  return getRuleContexts<VerilogParser::Output_terminalContext>();
}

VerilogParser::Output_terminalContext* VerilogParser::N_output_gate_instanceContext::output_terminal(size_t i) {
  return getRuleContext<VerilogParser::Output_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::N_output_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::N_output_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_output_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_output_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gate_instance;
}


std::any VerilogParser::N_output_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::n_output_gate_instance() {
  N_output_gate_instanceContext *_localctx = _tracker.createInstance<N_output_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 226, VerilogParser::RuleN_output_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2320);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2319);
      name_of_gate_instance();
    }
    setState(2322);
    match(VerilogParser::LP);
    setState(2323);
    output_terminal();
    setState(2328);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2324);
        match(VerilogParser::CO);
        setState(2325);
        output_terminal(); 
      }
      setState(2330);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx);
    }
    setState(2331);
    match(VerilogParser::CO);
    setState(2332);
    input_terminal();
    setState(2333);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_switch_instanceContext::Pass_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_switch_instance;
}


std::any VerilogParser::Pass_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::pass_switch_instance() {
  Pass_switch_instanceContext *_localctx = _tracker.createInstance<Pass_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 228, VerilogParser::RulePass_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2336);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2335);
      name_of_gate_instance();
    }
    setState(2338);
    match(VerilogParser::LP);
    setState(2339);
    inout_terminal();
    setState(2340);
    match(VerilogParser::CO);
    setState(2341);
    inout_terminal();
    setState(2342);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_enable_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_enable_switch_instanceContext::Pass_enable_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_enable_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Pass_enable_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_enable_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_enable_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_enable_switch_instance;
}


std::any VerilogParser::Pass_enable_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_enable_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::pass_enable_switch_instance() {
  Pass_enable_switch_instanceContext *_localctx = _tracker.createInstance<Pass_enable_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 230, VerilogParser::RulePass_enable_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2345);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2344);
      name_of_gate_instance();
    }
    setState(2347);
    match(VerilogParser::LP);
    setState(2348);
    inout_terminal();
    setState(2349);
    match(VerilogParser::CO);
    setState(2350);
    inout_terminal();
    setState(2351);
    match(VerilogParser::CO);
    setState(2352);
    enable_terminal();
    setState(2353);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pull_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Pull_gate_instanceContext::Pull_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Pull_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pull_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pull_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePull_gate_instance;
}


std::any VerilogParser::Pull_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPull_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::pull_gate_instance() {
  Pull_gate_instanceContext *_localctx = _tracker.createInstance<Pull_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 232, VerilogParser::RulePull_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2356);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2355);
      name_of_gate_instance();
    }
    setState(2358);
    match(VerilogParser::LP);
    setState(2359);
    output_terminal();
    setState(2360);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_gate_instanceContext::Name_of_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::Name_of_gate_instanceContext::gate_instance_identifier() {
  return getRuleContext<VerilogParser::Gate_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_gate_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_gate_instance;
}


std::any VerilogParser::Name_of_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::name_of_gate_instance() {
  Name_of_gate_instanceContext *_localctx = _tracker.createInstance<Name_of_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 234, VerilogParser::RuleName_of_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2362);
    gate_instance_identifier();
    setState(2364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2363);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulldown_strengthContext ------------------------------------------------------------------

VerilogParser::Pulldown_strengthContext::Pulldown_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pulldown_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pulldown_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pulldown_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePulldown_strength;
}


std::any VerilogParser::Pulldown_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulldown_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::pulldown_strength() {
  Pulldown_strengthContext *_localctx = _tracker.createInstance<Pulldown_strengthContext>(_ctx, getState());
  enterRule(_localctx, 236, VerilogParser::RulePulldown_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2382);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2366);
      match(VerilogParser::LP);
      setState(2367);
      strength0();
      setState(2368);
      match(VerilogParser::CO);
      setState(2369);
      strength1();
      setState(2370);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2372);
      match(VerilogParser::LP);
      setState(2373);
      strength1();
      setState(2374);
      match(VerilogParser::CO);
      setState(2375);
      strength0();
      setState(2376);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2378);
      match(VerilogParser::LP);
      setState(2379);
      strength0();
      setState(2380);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pullup_strengthContext ------------------------------------------------------------------

VerilogParser::Pullup_strengthContext::Pullup_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pullup_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pullup_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pullup_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePullup_strength;
}


std::any VerilogParser::Pullup_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPullup_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pullup_strengthContext* VerilogParser::pullup_strength() {
  Pullup_strengthContext *_localctx = _tracker.createInstance<Pullup_strengthContext>(_ctx, getState());
  enterRule(_localctx, 238, VerilogParser::RulePullup_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2400);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2384);
      match(VerilogParser::LP);
      setState(2385);
      strength0();
      setState(2386);
      match(VerilogParser::CO);
      setState(2387);
      strength1();
      setState(2388);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2390);
      match(VerilogParser::LP);
      setState(2391);
      strength1();
      setState(2392);
      match(VerilogParser::CO);
      setState(2393);
      strength0();
      setState(2394);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2396);
      match(VerilogParser::LP);
      setState(2397);
      strength1();
      setState(2398);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_terminalContext ------------------------------------------------------------------

VerilogParser::Enable_terminalContext::Enable_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Enable_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Enable_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_terminal;
}


std::any VerilogParser::Enable_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_terminalContext* VerilogParser::enable_terminal() {
  Enable_terminalContext *_localctx = _tracker.createInstance<Enable_terminalContext>(_ctx, getState());
  enterRule(_localctx, 240, VerilogParser::RuleEnable_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2402);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_terminalContext ------------------------------------------------------------------

VerilogParser::Inout_terminalContext::Inout_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Inout_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Inout_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInout_terminal;
}


std::any VerilogParser::Inout_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_terminalContext* VerilogParser::inout_terminal() {
  Inout_terminalContext *_localctx = _tracker.createInstance<Inout_terminalContext>(_ctx, getState());
  enterRule(_localctx, 242, VerilogParser::RuleInout_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2404);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_terminalContext ------------------------------------------------------------------

VerilogParser::Input_terminalContext::Input_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Input_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Input_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInput_terminal;
}


std::any VerilogParser::Input_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_terminalContext* VerilogParser::input_terminal() {
  Input_terminalContext *_localctx = _tracker.createInstance<Input_terminalContext>(_ctx, getState());
  enterRule(_localctx, 244, VerilogParser::RuleInput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2406);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ncontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Ncontrol_terminalContext::Ncontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ncontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ncontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleNcontrol_terminal;
}


std::any VerilogParser::Ncontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::ncontrol_terminal() {
  Ncontrol_terminalContext *_localctx = _tracker.createInstance<Ncontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 246, VerilogParser::RuleNcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2408);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_terminalContext ------------------------------------------------------------------

VerilogParser::Output_terminalContext::Output_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Output_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Output_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_terminal;
}


std::any VerilogParser::Output_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_terminalContext* VerilogParser::output_terminal() {
  Output_terminalContext *_localctx = _tracker.createInstance<Output_terminalContext>(_ctx, getState());
  enterRule(_localctx, 248, VerilogParser::RuleOutput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2410);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pcontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Pcontrol_terminalContext::Pcontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Pcontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Pcontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RulePcontrol_terminal;
}


std::any VerilogParser::Pcontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::pcontrol_terminal() {
  Pcontrol_terminalContext *_localctx = _tracker.createInstance<Pcontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 250, VerilogParser::RulePcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2412);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Cmos_switchtypeContext::Cmos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::CMOS() {
  return getToken(VerilogParser::CMOS, 0);
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::RCMOS() {
  return getToken(VerilogParser::RCMOS, 0);
}


size_t VerilogParser::Cmos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switchtype;
}


std::any VerilogParser::Cmos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::cmos_switchtype() {
  Cmos_switchtypeContext *_localctx = _tracker.createInstance<Cmos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 252, VerilogParser::RuleCmos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2414);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::CMOS || _la == VerilogParser::RCMOS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gatetypeContext ------------------------------------------------------------------

VerilogParser::Enable_gatetypeContext::Enable_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFZERO() {
  return getToken(VerilogParser::BUFIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFONE() {
  return getToken(VerilogParser::BUFIFONE, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFZERO() {
  return getToken(VerilogParser::NOTIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFONE() {
  return getToken(VerilogParser::NOTIFONE, 0);
}


size_t VerilogParser::Enable_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gatetype;
}


std::any VerilogParser::Enable_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::enable_gatetype() {
  Enable_gatetypeContext *_localctx = _tracker.createInstance<Enable_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 254, VerilogParser::RuleEnable_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2416);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUFIFONE

    || _la == VerilogParser::BUFIFZERO || _la == VerilogParser::NOTIFONE

    || _la == VerilogParser::NOTIFZERO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Mos_switchtypeContext::Mos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::NMOS() {
  return getToken(VerilogParser::NMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::PMOS() {
  return getToken(VerilogParser::PMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RNMOS() {
  return getToken(VerilogParser::RNMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RPMOS() {
  return getToken(VerilogParser::RPMOS, 0);
}


size_t VerilogParser::Mos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switchtype;
}


std::any VerilogParser::Mos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::mos_switchtype() {
  Mos_switchtypeContext *_localctx = _tracker.createInstance<Mos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 256, VerilogParser::RuleMos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2418);
    _la = _input->LA(1);
    if (!(((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 100664321) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_input_gatetypeContext::N_input_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::AND() {
  return getToken(VerilogParser::AND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NAND() {
  return getToken(VerilogParser::NAND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NOR() {
  return getToken(VerilogParser::NOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XOR() {
  return getToken(VerilogParser::XOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XNOR() {
  return getToken(VerilogParser::XNOR, 0);
}


size_t VerilogParser::N_input_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gatetype;
}


std::any VerilogParser::N_input_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::n_input_gatetype() {
  N_input_gatetypeContext *_localctx = _tracker.createInstance<N_input_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 258, VerilogParser::RuleN_input_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2420);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::AND || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & 265) != 0) || _la == VerilogParser::XNOR

    || _la == VerilogParser::XOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_output_gatetypeContext::N_output_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::BUF() {
  return getToken(VerilogParser::BUF, 0);
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::NOT() {
  return getToken(VerilogParser::NOT, 0);
}


size_t VerilogParser::N_output_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gatetype;
}


std::any VerilogParser::N_output_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::n_output_gatetype() {
  N_output_gatetypeContext *_localctx = _tracker.createInstance<N_output_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 260, VerilogParser::RuleN_output_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2422);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUF || _la == VerilogParser::NOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_en_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_en_switchtypeContext::Pass_en_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFZERO() {
  return getToken(VerilogParser::TRANIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFONE() {
  return getToken(VerilogParser::TRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFONE() {
  return getToken(VerilogParser::RTRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFZERO() {
  return getToken(VerilogParser::RTRANIFZERO, 0);
}


size_t VerilogParser::Pass_en_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_en_switchtype;
}


std::any VerilogParser::Pass_en_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_en_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::pass_en_switchtype() {
  Pass_en_switchtypeContext *_localctx = _tracker.createInstance<Pass_en_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 262, VerilogParser::RulePass_en_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2424);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 196611) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_switchtypeContext::Pass_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::TRAN() {
  return getToken(VerilogParser::TRAN, 0);
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::RTRAN() {
  return getToken(VerilogParser::RTRAN, 0);
}


size_t VerilogParser::Pass_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_switchtype;
}


std::any VerilogParser::Pass_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::pass_switchtype() {
  Pass_switchtypeContext *_localctx = _tracker.createInstance<Pass_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 264, VerilogParser::RulePass_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2426);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::RTRAN

    || _la == VerilogParser::TRAN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instantiationContext ------------------------------------------------------------------

VerilogParser::Module_instantiationContext::Module_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_identifierContext* VerilogParser::Module_instantiationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

std::vector<VerilogParser::Module_instanceContext *> VerilogParser::Module_instantiationContext::module_instance() {
  return getRuleContexts<VerilogParser::Module_instanceContext>();
}

VerilogParser::Module_instanceContext* VerilogParser::Module_instantiationContext::module_instance(size_t i) {
  return getRuleContext<VerilogParser::Module_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::Module_instantiationContext::parameter_value_assignment() {
  return getRuleContext<VerilogParser::Parameter_value_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instantiation;
}


std::any VerilogParser::Module_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instantiationContext* VerilogParser::module_instantiation() {
  Module_instantiationContext *_localctx = _tracker.createInstance<Module_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 266, VerilogParser::RuleModule_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2428);
    module_identifier();
    setState(2430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2429);
      parameter_value_assignment();
    }
    setState(2432);
    module_instance();
    setState(2437);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2433);
      match(VerilogParser::CO);
      setState(2434);
      module_instance();
      setState(2439);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2440);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_value_assignmentContext ------------------------------------------------------------------

VerilogParser::Parameter_value_assignmentContext::Parameter_value_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::Parameter_value_assignmentContext::list_of_parameter_assignments() {
  return getRuleContext<VerilogParser::List_of_parameter_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Parameter_value_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_value_assignment;
}


std::any VerilogParser::Parameter_value_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_value_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::parameter_value_assignment() {
  Parameter_value_assignmentContext *_localctx = _tracker.createInstance<Parameter_value_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 268, VerilogParser::RuleParameter_value_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2442);
    match(VerilogParser::HA);
    setState(2443);
    match(VerilogParser::LP);
    setState(2444);
    list_of_parameter_assignments();
    setState(2445);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_parameter_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_parameter_assignmentsContext::List_of_parameter_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment() {
  return getRuleContexts<VerilogParser::Ordered_parameter_assignmentContext>();
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Ordered_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_parameter_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_parameter_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment() {
  return getRuleContexts<VerilogParser::Named_parameter_assignmentContext>();
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Named_parameter_assignmentContext>(i);
}


size_t VerilogParser::List_of_parameter_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_parameter_assignments;
}


std::any VerilogParser::List_of_parameter_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_parameter_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::list_of_parameter_assignments() {
  List_of_parameter_assignmentsContext *_localctx = _tracker.createInstance<List_of_parameter_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 270, VerilogParser::RuleList_of_parameter_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2463);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2447);
        ordered_parameter_assignment();
        setState(2452);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2448);
          match(VerilogParser::CO);
          setState(2449);
          ordered_parameter_assignment();
          setState(2454);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(2455);
        named_parameter_assignment();
        setState(2460);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2456);
          match(VerilogParser::CO);
          setState(2457);
          named_parameter_assignment();
          setState(2462);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Ordered_parameter_assignmentContext::Ordered_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_parameter_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_parameter_assignment;
}


std::any VerilogParser::Ordered_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::ordered_parameter_assignment() {
  Ordered_parameter_assignmentContext *_localctx = _tracker.createInstance<Ordered_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 272, VerilogParser::RuleOrdered_parameter_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2465);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Named_parameter_assignmentContext::Named_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Parameter_identifierContext* VerilogParser::Named_parameter_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Named_parameter_assignmentContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Named_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_parameter_assignment;
}


std::any VerilogParser::Named_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::named_parameter_assignment() {
  Named_parameter_assignmentContext *_localctx = _tracker.createInstance<Named_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 274, VerilogParser::RuleNamed_parameter_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2467);
    match(VerilogParser::DT);
    setState(2468);
    parameter_identifier();
    setState(2469);
    match(VerilogParser::LP);
    setState(2471);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(2470);
      mintypmax_expression();
    }
    setState(2473);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instanceContext ------------------------------------------------------------------

VerilogParser::Module_instanceContext::Module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::Module_instanceContext::name_of_module_instance() {
  return getRuleContext<VerilogParser::Name_of_module_instanceContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::Module_instanceContext::list_of_port_connections() {
  return getRuleContext<VerilogParser::List_of_port_connectionsContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance;
}


std::any VerilogParser::Module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instanceContext* VerilogParser::module_instance() {
  Module_instanceContext *_localctx = _tracker.createInstance<Module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 276, VerilogParser::RuleModule_instance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2475);
    name_of_module_instance();
    setState(2476);
    match(VerilogParser::LP);
    setState(2477);
    list_of_port_connections();
    setState(2478);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_module_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_module_instanceContext::Name_of_module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_instance_identifierContext* VerilogParser::Name_of_module_instanceContext::module_instance_identifier() {
  return getRuleContext<VerilogParser::Module_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_module_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_module_instance;
}


std::any VerilogParser::Name_of_module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_module_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::name_of_module_instance() {
  Name_of_module_instanceContext *_localctx = _tracker.createInstance<Name_of_module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 278, VerilogParser::RuleName_of_module_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2480);
    module_instance_identifier();
    setState(2482);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2481);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_connectionsContext ------------------------------------------------------------------

VerilogParser::List_of_port_connectionsContext::List_of_port_connectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::ordered_port_connection() {
  return getRuleContexts<VerilogParser::Ordered_port_connectionContext>();
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::List_of_port_connectionsContext::ordered_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Ordered_port_connectionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_connectionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_connectionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::named_port_connection() {
  return getRuleContexts<VerilogParser::Named_port_connectionContext>();
}

VerilogParser::Named_port_connectionContext* VerilogParser::List_of_port_connectionsContext::named_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Named_port_connectionContext>(i);
}


size_t VerilogParser::List_of_port_connectionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_connections;
}


std::any VerilogParser::List_of_port_connectionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_connections(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::list_of_port_connections() {
  List_of_port_connectionsContext *_localctx = _tracker.createInstance<List_of_port_connectionsContext>(_ctx, getState());
  enterRule(_localctx, 280, VerilogParser::RuleList_of_port_connections);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2484);
      ordered_port_connection();
      setState(2489);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2485);
        match(VerilogParser::CO);
        setState(2486);
        ordered_port_connection();
        setState(2491);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2492);
      named_port_connection();
      setState(2497);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2493);
        match(VerilogParser::CO);
        setState(2494);
        named_port_connection();
        setState(2499);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_port_connectionContext ------------------------------------------------------------------

VerilogParser::Ordered_port_connectionContext::Ordered_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Ordered_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Ordered_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_port_connection;
}


std::any VerilogParser::Ordered_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::ordered_port_connection() {
  Ordered_port_connectionContext *_localctx = _tracker.createInstance<Ordered_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 282, VerilogParser::RuleOrdered_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2505);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2502);
        attribute_instance(); 
      }
      setState(2507);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx);
    }
    setState(2509);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(2508);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_port_connectionContext ------------------------------------------------------------------

VerilogParser::Named_port_connectionContext::Named_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Named_port_connectionContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Named_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Named_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Named_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Named_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_port_connection;
}


std::any VerilogParser::Named_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_port_connectionContext* VerilogParser::named_port_connection() {
  Named_port_connectionContext *_localctx = _tracker.createInstance<Named_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 284, VerilogParser::RuleNamed_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2514);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2511);
      attribute_instance();
      setState(2516);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2517);
    match(VerilogParser::DT);
    setState(2518);
    port_identifier();
    setState(2519);
    match(VerilogParser::LP);
    setState(2521);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(2520);
      expression(0);
    }
    setState(2523);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_regionContext ------------------------------------------------------------------

VerilogParser::Generate_regionContext::Generate_regionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_regionContext::GENERATE() {
  return getToken(VerilogParser::GENERATE, 0);
}

tree::TerminalNode* VerilogParser::Generate_regionContext::ENDGENERATE() {
  return getToken(VerilogParser::ENDGENERATE, 0);
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_regionContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_regionContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}


size_t VerilogParser::Generate_regionContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_region;
}


std::any VerilogParser::Generate_regionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_region(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_regionContext* VerilogParser::generate_region() {
  Generate_regionContext *_localctx = _tracker.createInstance<Generate_regionContext>(_ctx, getState());
  enterRule(_localctx, 286, VerilogParser::RuleGenerate_region);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2525);
    match(VerilogParser::GENERATE);
    setState(2529);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2470840122124411854) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7494165567648940639) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 2305843009213693983) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2526);
      module_or_generate_item();
      setState(2531);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2532);
    match(VerilogParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_declarationContext ------------------------------------------------------------------

VerilogParser::Genvar_declarationContext::Genvar_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::GENVAR() {
  return getToken(VerilogParser::GENVAR, 0);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::Genvar_declarationContext::list_of_genvar_identifiers() {
  return getRuleContext<VerilogParser::List_of_genvar_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Genvar_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_declaration;
}


std::any VerilogParser::Genvar_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_declarationContext* VerilogParser::genvar_declaration() {
  Genvar_declarationContext *_localctx = _tracker.createInstance<Genvar_declarationContext>(_ctx, getState());
  enterRule(_localctx, 288, VerilogParser::RuleGenvar_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2534);
    match(VerilogParser::GENVAR);
    setState(2535);
    list_of_genvar_identifiers();
    setState(2536);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_genvar_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_genvar_identifiersContext::List_of_genvar_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Genvar_identifierContext *> VerilogParser::List_of_genvar_identifiersContext::genvar_identifier() {
  return getRuleContexts<VerilogParser::Genvar_identifierContext>();
}

VerilogParser::Genvar_identifierContext* VerilogParser::List_of_genvar_identifiersContext::genvar_identifier(size_t i) {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_genvar_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_genvar_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_genvar_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_genvar_identifiers;
}


std::any VerilogParser::List_of_genvar_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_genvar_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::list_of_genvar_identifiers() {
  List_of_genvar_identifiersContext *_localctx = _tracker.createInstance<List_of_genvar_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 290, VerilogParser::RuleList_of_genvar_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2538);
    genvar_identifier();
    setState(2543);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2539);
      match(VerilogParser::CO);
      setState(2540);
      genvar_identifier();
      setState(2545);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_generate_constructContext ------------------------------------------------------------------

VerilogParser::Loop_generate_constructContext::Loop_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Genvar_initializationContext* VerilogParser::Loop_generate_constructContext::genvar_initialization() {
  return getRuleContext<VerilogParser::Genvar_initializationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_generate_constructContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Loop_generate_constructContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}

VerilogParser::Genvar_iterationContext* VerilogParser::Loop_generate_constructContext::genvar_iteration() {
  return getRuleContext<VerilogParser::Genvar_iterationContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Generate_blockContext* VerilogParser::Loop_generate_constructContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}


size_t VerilogParser::Loop_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_generate_construct;
}


std::any VerilogParser::Loop_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::loop_generate_construct() {
  Loop_generate_constructContext *_localctx = _tracker.createInstance<Loop_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 292, VerilogParser::RuleLoop_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2546);
    match(VerilogParser::FOR);
    setState(2547);
    match(VerilogParser::LP);
    setState(2548);
    genvar_initialization();
    setState(2549);
    match(VerilogParser::SC);
    setState(2550);
    genvar_expression();
    setState(2551);
    match(VerilogParser::SC);
    setState(2552);
    genvar_iteration();
    setState(2553);
    match(VerilogParser::RP);
    setState(2554);
    generate_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_initializationContext ------------------------------------------------------------------

VerilogParser::Genvar_initializationContext::Genvar_initializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_initializationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_initializationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_initializationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_initializationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_initialization;
}


std::any VerilogParser::Genvar_initializationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_initialization(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_initializationContext* VerilogParser::genvar_initialization() {
  Genvar_initializationContext *_localctx = _tracker.createInstance<Genvar_initializationContext>(_ctx, getState());
  enterRule(_localctx, 294, VerilogParser::RuleGenvar_initialization);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2556);
    genvar_identifier();
    setState(2557);
    match(VerilogParser::EQ);
    setState(2558);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_expressionContext ------------------------------------------------------------------

VerilogParser::Genvar_expressionContext::Genvar_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_expression;
}


std::any VerilogParser::Genvar_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_expressionContext* VerilogParser::genvar_expression() {
  Genvar_expressionContext *_localctx = _tracker.createInstance<Genvar_expressionContext>(_ctx, getState());
  enterRule(_localctx, 296, VerilogParser::RuleGenvar_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2560);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_iterationContext ------------------------------------------------------------------

VerilogParser::Genvar_iterationContext::Genvar_iterationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_iterationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_iterationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Genvar_iterationContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}


size_t VerilogParser::Genvar_iterationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_iteration;
}


std::any VerilogParser::Genvar_iterationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_iteration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_iterationContext* VerilogParser::genvar_iteration() {
  Genvar_iterationContext *_localctx = _tracker.createInstance<Genvar_iterationContext>(_ctx, getState());
  enterRule(_localctx, 298, VerilogParser::RuleGenvar_iteration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2562);
    genvar_identifier();
    setState(2563);
    match(VerilogParser::EQ);
    setState(2564);
    genvar_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_generate_constructContext ------------------------------------------------------------------

VerilogParser::Conditional_generate_constructContext::Conditional_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::If_generate_constructContext* VerilogParser::Conditional_generate_constructContext::if_generate_construct() {
  return getRuleContext<VerilogParser::If_generate_constructContext>(0);
}

VerilogParser::Case_generate_constructContext* VerilogParser::Conditional_generate_constructContext::case_generate_construct() {
  return getRuleContext<VerilogParser::Case_generate_constructContext>(0);
}


size_t VerilogParser::Conditional_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_generate_construct;
}


std::any VerilogParser::Conditional_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::conditional_generate_construct() {
  Conditional_generate_constructContext *_localctx = _tracker.createInstance<Conditional_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 300, VerilogParser::RuleConditional_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(2566);
        if_generate_construct();
        break;
      }

      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(2567);
        case_generate_construct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_generate_constructContext ------------------------------------------------------------------

VerilogParser::If_generate_constructContext::If_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::If_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Generate_block_or_nullContext *> VerilogParser::If_generate_constructContext::generate_block_or_null() {
  return getRuleContexts<VerilogParser::Generate_block_or_nullContext>();
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::If_generate_constructContext::generate_block_or_null(size_t i) {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::If_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleIf_generate_construct;
}


std::any VerilogParser::If_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIf_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::If_generate_constructContext* VerilogParser::if_generate_construct() {
  If_generate_constructContext *_localctx = _tracker.createInstance<If_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 302, VerilogParser::RuleIf_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2570);
    match(VerilogParser::IF);
    setState(2571);
    match(VerilogParser::LP);
    setState(2572);
    constant_expression(0);
    setState(2573);
    match(VerilogParser::RP);
    setState(2574);
    generate_block_or_null();
    setState(2577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      setState(2575);
      match(VerilogParser::ELSE);
      setState(2576);
      generate_block_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_constructContext ------------------------------------------------------------------

VerilogParser::Case_generate_constructContext::Case_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_generate_itemContext *> VerilogParser::Case_generate_constructContext::case_generate_item() {
  return getRuleContexts<VerilogParser::Case_generate_itemContext>();
}

VerilogParser::Case_generate_itemContext* VerilogParser::Case_generate_constructContext::case_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Case_generate_itemContext>(i);
}


size_t VerilogParser::Case_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_construct;
}


std::any VerilogParser::Case_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_constructContext* VerilogParser::case_generate_construct() {
  Case_generate_constructContext *_localctx = _tracker.createInstance<Case_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 304, VerilogParser::RuleCase_generate_construct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2579);
    match(VerilogParser::CASE);
    setState(2580);
    match(VerilogParser::LP);
    setState(2581);
    constant_expression(0);
    setState(2582);
    match(VerilogParser::RP);
    setState(2584); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2583);
      case_generate_item();
      setState(2586); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::DEFAULT || ((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER);
    setState(2588);
    match(VerilogParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_itemContext ------------------------------------------------------------------

VerilogParser::Case_generate_itemContext::Case_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Case_generate_itemContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_itemContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::Case_generate_itemContext::generate_block_or_null() {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_generate_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_item;
}


std::any VerilogParser::Case_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_itemContext* VerilogParser::case_generate_item() {
  Case_generate_itemContext *_localctx = _tracker.createInstance<Case_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 306, VerilogParser::RuleCase_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2606);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2590);
        constant_expression(0);
        setState(2595);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2591);
          match(VerilogParser::CO);
          setState(2592);
          constant_expression(0);
          setState(2597);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2598);
        match(VerilogParser::CL);
        setState(2599);
        generate_block_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(2601);
        match(VerilogParser::DEFAULT);
        setState(2603);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2602);
          match(VerilogParser::CL);
        }
        setState(2605);
        generate_block_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_blockContext ------------------------------------------------------------------

VerilogParser::Generate_blockContext::Generate_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_blockContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_blockContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Generate_block_nameContext* VerilogParser::Generate_blockContext::generate_block_name() {
  return getRuleContext<VerilogParser::Generate_block_nameContext>(0);
}


size_t VerilogParser::Generate_blockContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block;
}


std::any VerilogParser::Generate_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_blockContext* VerilogParser::generate_block() {
  Generate_blockContext *_localctx = _tracker.createInstance<Generate_blockContext>(_ctx, getState());
  enterRule(_localctx, 308, VerilogParser::RuleGenerate_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2620);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ANALOG:
      case VerilogParser::LP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2608);
        module_or_generate_item();
        break;
      }

      case VerilogParser::BEGIN: {
        enterOuterAlt(_localctx, 2);
        setState(2609);
        match(VerilogParser::BEGIN);
        setState(2611);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2610);
          generate_block_name();
        }
        setState(2616);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2470840122124411854) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & -7494165567648940639) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 133)) & 2305843009213693983) != 0) || ((((_la - 210) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
          setState(2613);
          module_or_generate_item();
          setState(2618);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2619);
        match(VerilogParser::END);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_nameContext ------------------------------------------------------------------

VerilogParser::Generate_block_nameContext::Generate_block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::Generate_block_nameContext::generate_block_identifier() {
  return getRuleContext<VerilogParser::Generate_block_identifierContext>(0);
}


size_t VerilogParser::Generate_block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_name;
}


std::any VerilogParser::Generate_block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_nameContext* VerilogParser::generate_block_name() {
  Generate_block_nameContext *_localctx = _tracker.createInstance<Generate_block_nameContext>(_ctx, getState());
  enterRule(_localctx, 310, VerilogParser::RuleGenerate_block_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2622);
    match(VerilogParser::CL);
    setState(2623);
    generate_block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_or_nullContext ------------------------------------------------------------------

VerilogParser::Generate_block_or_nullContext::Generate_block_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Generate_blockContext* VerilogParser::Generate_block_or_nullContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}

tree::TerminalNode* VerilogParser::Generate_block_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Generate_block_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_or_null;
}


std::any VerilogParser::Generate_block_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::generate_block_or_null() {
  Generate_block_or_nullContext *_localctx = _tracker.createInstance<Generate_block_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 312, VerilogParser::RuleGenerate_block_or_null);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2627);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BEGIN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ANALOG:
      case VerilogParser::LP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2625);
        generate_block();
        break;
      }

      case VerilogParser::SC: {
        enterOuterAlt(_localctx, 2);
        setState(2626);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_declarationContext::Udp_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::PRIMITIVE() {
  return getToken(VerilogParser::PRIMITIVE, 0);
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_declarationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Udp_port_listContext* VerilogParser::Udp_declarationContext::udp_port_list() {
  return getRuleContext<VerilogParser::Udp_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_bodyContext* VerilogParser::Udp_declarationContext::udp_body() {
  return getRuleContext<VerilogParser::Udp_bodyContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::ENDPRIMITIVE() {
  return getToken(VerilogParser::ENDPRIMITIVE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Udp_port_declarationContext *> VerilogParser::Udp_declarationContext::udp_port_declaration() {
  return getRuleContexts<VerilogParser::Udp_port_declarationContext>();
}

VerilogParser::Udp_port_declarationContext* VerilogParser::Udp_declarationContext::udp_port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_port_declarationContext>(i);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::Udp_declarationContext::udp_declaration_port_list() {
  return getRuleContext<VerilogParser::Udp_declaration_port_listContext>(0);
}


size_t VerilogParser::Udp_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration;
}


std::any VerilogParser::Udp_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declarationContext* VerilogParser::udp_declaration() {
  Udp_declarationContext *_localctx = _tracker.createInstance<Udp_declarationContext>(_ctx, getState());
  enterRule(_localctx, 314, VerilogParser::RuleUdp_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2664);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2632);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2629);
        attribute_instance();
        setState(2634);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2635);
      match(VerilogParser::PRIMITIVE);
      setState(2636);
      udp_identifier();
      setState(2637);
      match(VerilogParser::LP);
      setState(2638);
      udp_port_list();
      setState(2639);
      match(VerilogParser::RP);
      setState(2640);
      match(VerilogParser::SC);
      setState(2642); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2641);
        udp_port_declaration();
        setState(2644); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 59) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 59)) & 68721573889) != 0) || _la == VerilogParser::LP);
      setState(2646);
      udp_body();
      setState(2647);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2652);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2649);
        attribute_instance();
        setState(2654);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2655);
      match(VerilogParser::PRIMITIVE);
      setState(2656);
      udp_identifier();
      setState(2657);
      match(VerilogParser::LP);
      setState(2658);
      udp_declaration_port_list();
      setState(2659);
      match(VerilogParser::RP);
      setState(2660);
      match(VerilogParser::SC);
      setState(2661);
      udp_body();
      setState(2662);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_port_listContext::Udp_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_port_listContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_port_identifierContext *> VerilogParser::Udp_port_listContext::input_port_identifier() {
  return getRuleContexts<VerilogParser::Input_port_identifierContext>();
}

VerilogParser::Input_port_identifierContext* VerilogParser::Udp_port_listContext::input_port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Input_port_identifierContext>(i);
}


size_t VerilogParser::Udp_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_list;
}


std::any VerilogParser::Udp_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_listContext* VerilogParser::udp_port_list() {
  Udp_port_listContext *_localctx = _tracker.createInstance<Udp_port_listContext>(_ctx, getState());
  enterRule(_localctx, 316, VerilogParser::RuleUdp_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2666);
    output_port_identifier();
    setState(2667);
    match(VerilogParser::CO);
    setState(2668);
    input_port_identifier();
    setState(2673);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2669);
      match(VerilogParser::CO);
      setState(2670);
      input_port_identifier();
      setState(2675);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declaration_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_declaration_port_listContext::Udp_declaration_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_declaration_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_declaration_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Udp_input_declarationContext *> VerilogParser::Udp_declaration_port_listContext::udp_input_declaration() {
  return getRuleContexts<VerilogParser::Udp_input_declarationContext>();
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_input_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(i);
}


size_t VerilogParser::Udp_declaration_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration_port_list;
}


std::any VerilogParser::Udp_declaration_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::udp_declaration_port_list() {
  Udp_declaration_port_listContext *_localctx = _tracker.createInstance<Udp_declaration_port_listContext>(_ctx, getState());
  enterRule(_localctx, 318, VerilogParser::RuleUdp_declaration_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2676);
    udp_output_declaration();
    setState(2677);
    match(VerilogParser::CO);
    setState(2678);
    udp_input_declaration();
    setState(2683);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2679);
      match(VerilogParser::CO);
      setState(2680);
      udp_input_declaration();
      setState(2685);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_port_declarationContext::Udp_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_port_declarationContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_port_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_port_declarationContext::udp_input_declaration() {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(0);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::Udp_port_declarationContext::udp_reg_declaration() {
  return getRuleContext<VerilogParser::Udp_reg_declarationContext>(0);
}


size_t VerilogParser::Udp_port_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_declaration;
}


std::any VerilogParser::Udp_port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_declarationContext* VerilogParser::udp_port_declaration() {
  Udp_port_declarationContext *_localctx = _tracker.createInstance<Udp_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 320, VerilogParser::RuleUdp_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2695);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2686);
      udp_output_declaration();
      setState(2687);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2689);
      udp_input_declaration();
      setState(2690);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2692);
      udp_reg_declaration();
      setState(2693);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_output_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_output_declarationContext::Udp_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Udp_output_declarationContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_output_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_output_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Udp_output_declarationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Udp_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_output_declaration;
}


std::any VerilogParser::Udp_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_output_declarationContext* VerilogParser::udp_output_declaration() {
  Udp_output_declarationContext *_localctx = _tracker.createInstance<Udp_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 322, VerilogParser::RuleUdp_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2700);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2697);
        attribute_instance();
        setState(2702);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2703);
      match(VerilogParser::OUTPUT);
      setState(2704);
      port_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2708);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2705);
        attribute_instance();
        setState(2710);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2711);
      match(VerilogParser::OUTPUT);
      setState(2712);
      match(VerilogParser::REG);
      setState(2713);
      port_identifier();
      setState(2716);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::EQ) {
        setState(2714);
        match(VerilogParser::EQ);
        setState(2715);
        constant_expression(0);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_input_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_input_declarationContext::Udp_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Udp_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_input_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_input_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_input_declaration;
}


std::any VerilogParser::Udp_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::udp_input_declaration() {
  Udp_input_declarationContext *_localctx = _tracker.createInstance<Udp_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 324, VerilogParser::RuleUdp_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2723);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2720);
      attribute_instance();
      setState(2725);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2726);
    match(VerilogParser::INPUT);
    setState(2727);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_reg_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_reg_declarationContext::Udp_reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::Variable_identifierContext* VerilogParser::Udp_reg_declarationContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_reg_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_reg_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_reg_declaration;
}


std::any VerilogParser::Udp_reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_reg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::udp_reg_declaration() {
  Udp_reg_declarationContext *_localctx = _tracker.createInstance<Udp_reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 326, VerilogParser::RuleUdp_reg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2732);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2729);
      attribute_instance();
      setState(2734);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2735);
    match(VerilogParser::REG);
    setState(2736);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_bodyContext ------------------------------------------------------------------

VerilogParser::Udp_bodyContext::Udp_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Combinational_bodyContext* VerilogParser::Udp_bodyContext::combinational_body() {
  return getRuleContext<VerilogParser::Combinational_bodyContext>(0);
}

VerilogParser::Sequential_bodyContext* VerilogParser::Udp_bodyContext::sequential_body() {
  return getRuleContext<VerilogParser::Sequential_bodyContext>(0);
}


size_t VerilogParser::Udp_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_body;
}


std::any VerilogParser::Udp_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_bodyContext* VerilogParser::udp_body() {
  Udp_bodyContext *_localctx = _tracker.createInstance<Udp_bodyContext>(_ctx, getState());
  enterRule(_localctx, 328, VerilogParser::RuleUdp_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2738);
      combinational_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2739);
      sequential_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_bodyContext ------------------------------------------------------------------

VerilogParser::Combinational_bodyContext::Combinational_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

std::vector<VerilogParser::Combinational_entryContext *> VerilogParser::Combinational_bodyContext::combinational_entry() {
  return getRuleContexts<VerilogParser::Combinational_entryContext>();
}

VerilogParser::Combinational_entryContext* VerilogParser::Combinational_bodyContext::combinational_entry(size_t i) {
  return getRuleContext<VerilogParser::Combinational_entryContext>(i);
}


size_t VerilogParser::Combinational_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_body;
}


std::any VerilogParser::Combinational_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_bodyContext* VerilogParser::combinational_body() {
  Combinational_bodyContext *_localctx = _tracker.createInstance<Combinational_bodyContext>(_ctx, getState());
  enterRule(_localctx, 330, VerilogParser::RuleCombinational_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2742);
    match(VerilogParser::TABLE);
    setState(2744); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2743);
      combinational_entry();
      setState(2746); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
    setState(2748);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_entryContext ------------------------------------------------------------------

VerilogParser::Combinational_entryContext::Combinational_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Combinational_entryContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Output_symbolContext* VerilogParser::Combinational_entryContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Combinational_entryContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_entry;
}


std::any VerilogParser::Combinational_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_entryContext* VerilogParser::combinational_entry() {
  Combinational_entryContext *_localctx = _tracker.createInstance<Combinational_entryContext>(_ctx, getState());
  enterRule(_localctx, 332, VerilogParser::RuleCombinational_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2750);
    level_input_list();
    setState(2751);
    match(VerilogParser::CL);
    setState(2752);
    output_symbol();
    setState(2753);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_bodyContext ------------------------------------------------------------------

VerilogParser::Sequential_bodyContext::Sequential_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::Sequential_bodyContext::udp_initial_statement() {
  return getRuleContext<VerilogParser::Udp_initial_statementContext>(0);
}

std::vector<VerilogParser::Sequential_entryContext *> VerilogParser::Sequential_bodyContext::sequential_entry() {
  return getRuleContexts<VerilogParser::Sequential_entryContext>();
}

VerilogParser::Sequential_entryContext* VerilogParser::Sequential_bodyContext::sequential_entry(size_t i) {
  return getRuleContext<VerilogParser::Sequential_entryContext>(i);
}


size_t VerilogParser::Sequential_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_body;
}


std::any VerilogParser::Sequential_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_bodyContext* VerilogParser::sequential_body() {
  Sequential_bodyContext *_localctx = _tracker.createInstance<Sequential_bodyContext>(_ctx, getState());
  enterRule(_localctx, 334, VerilogParser::RuleSequential_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2756);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::INITIAL) {
      setState(2755);
      udp_initial_statement();
    }
    setState(2758);
    match(VerilogParser::TABLE);
    setState(2760); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2759);
      sequential_entry();
      setState(2762); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & 120259084289) != 0));
    setState(2764);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_initial_statementContext ------------------------------------------------------------------

VerilogParser::Udp_initial_statementContext::Udp_initial_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_initial_statementContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Init_valContext* VerilogParser::Udp_initial_statementContext::init_val() {
  return getRuleContext<VerilogParser::Init_valContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Udp_initial_statementContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_initial_statement;
}


std::any VerilogParser::Udp_initial_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_initial_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::udp_initial_statement() {
  Udp_initial_statementContext *_localctx = _tracker.createInstance<Udp_initial_statementContext>(_ctx, getState());
  enterRule(_localctx, 336, VerilogParser::RuleUdp_initial_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2766);
    match(VerilogParser::INITIAL);
    setState(2767);
    output_port_identifier();
    setState(2768);
    match(VerilogParser::EQ);
    setState(2769);
    init_val();
    setState(2770);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Init_valContext ------------------------------------------------------------------

VerilogParser::Init_valContext::Init_valContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Init_valContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Init_valContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Init_valContext::getRuleIndex() const {
  return VerilogParser::RuleInit_val;
}


std::any VerilogParser::Init_valContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInit_val(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Init_valContext* VerilogParser::init_val() {
  Init_valContext *_localctx = _tracker.createInstance<Init_valContext>(_ctx, getState());
  enterRule(_localctx, 338, VerilogParser::RuleInit_val);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2772);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2773);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_entryContext ------------------------------------------------------------------

VerilogParser::Sequential_entryContext::Sequential_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Seq_input_listContext* VerilogParser::Sequential_entryContext::seq_input_list() {
  return getRuleContext<VerilogParser::Seq_input_listContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sequential_entryContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}

VerilogParser::Current_stateContext* VerilogParser::Sequential_entryContext::current_state() {
  return getRuleContext<VerilogParser::Current_stateContext>(0);
}

VerilogParser::Next_stateContext* VerilogParser::Sequential_entryContext::next_state() {
  return getRuleContext<VerilogParser::Next_stateContext>(0);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Sequential_entryContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_entry;
}


std::any VerilogParser::Sequential_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_entryContext* VerilogParser::sequential_entry() {
  Sequential_entryContext *_localctx = _tracker.createInstance<Sequential_entryContext>(_ctx, getState());
  enterRule(_localctx, 340, VerilogParser::RuleSequential_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2776);
    seq_input_list();
    setState(2777);
    match(VerilogParser::CL);
    setState(2778);
    current_state();
    setState(2779);
    match(VerilogParser::CL);
    setState(2780);
    next_state();
    setState(2781);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_input_listContext ------------------------------------------------------------------

VerilogParser::Seq_input_listContext::Seq_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Seq_input_listContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

VerilogParser::Edge_input_listContext* VerilogParser::Seq_input_listContext::edge_input_list() {
  return getRuleContext<VerilogParser::Edge_input_listContext>(0);
}


size_t VerilogParser::Seq_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_input_list;
}


std::any VerilogParser::Seq_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_input_listContext* VerilogParser::seq_input_list() {
  Seq_input_listContext *_localctx = _tracker.createInstance<Seq_input_listContext>(_ctx, getState());
  enterRule(_localctx, 342, VerilogParser::RuleSeq_input_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2783);
      level_input_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2784);
      edge_input_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_input_listContext ------------------------------------------------------------------

VerilogParser::Level_input_listContext::Level_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Level_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Level_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Level_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_input_list;
}


std::any VerilogParser::Level_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_input_listContext* VerilogParser::level_input_list() {
  Level_input_listContext *_localctx = _tracker.createInstance<Level_input_listContext>(_ctx, getState());
  enterRule(_localctx, 344, VerilogParser::RuleLevel_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2788); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2787);
      level_symbol();
      setState(2790); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_input_listContext ------------------------------------------------------------------

VerilogParser::Edge_input_listContext::Edge_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Edge_indicatorContext* VerilogParser::Edge_input_listContext::edge_indicator() {
  return getRuleContext<VerilogParser::Edge_indicatorContext>(0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Edge_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_input_list;
}


std::any VerilogParser::Edge_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_input_listContext* VerilogParser::edge_input_list() {
  Edge_input_listContext *_localctx = _tracker.createInstance<Edge_input_listContext>(_ctx, getState());
  enterRule(_localctx, 346, VerilogParser::RuleEdge_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2795);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2792);
      level_symbol();
      setState(2797);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2798);
    edge_indicator();
    setState(2802);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2799);
      level_symbol();
      setState(2804);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_indicatorContext ------------------------------------------------------------------

VerilogParser::Edge_indicatorContext::Edge_indicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_indicatorContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_indicatorContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Edge_symbolContext* VerilogParser::Edge_indicatorContext::edge_symbol() {
  return getRuleContext<VerilogParser::Edge_symbolContext>(0);
}


size_t VerilogParser::Edge_indicatorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_indicator;
}


std::any VerilogParser::Edge_indicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_indicator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_indicatorContext* VerilogParser::edge_indicator() {
  Edge_indicatorContext *_localctx = _tracker.createInstance<Edge_indicatorContext>(_ctx, getState());
  enterRule(_localctx, 348, VerilogParser::RuleEdge_indicator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2811);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 1);
        setState(2805);
        match(VerilogParser::LP);
        setState(2806);
        level_symbol();
        setState(2807);
        level_symbol();
        setState(2808);
        match(VerilogParser::RP);
        break;
      }

      case VerilogParser::EDGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2810);
        edge_symbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Current_stateContext ------------------------------------------------------------------

VerilogParser::Current_stateContext::Current_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_symbolContext* VerilogParser::Current_stateContext::level_symbol() {
  return getRuleContext<VerilogParser::Level_symbolContext>(0);
}


size_t VerilogParser::Current_stateContext::getRuleIndex() const {
  return VerilogParser::RuleCurrent_state;
}


std::any VerilogParser::Current_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCurrent_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Current_stateContext* VerilogParser::current_state() {
  Current_stateContext *_localctx = _tracker.createInstance<Current_stateContext>(_ctx, getState());
  enterRule(_localctx, 350, VerilogParser::RuleCurrent_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2813);
    level_symbol();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_stateContext ------------------------------------------------------------------

VerilogParser::Next_stateContext::Next_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_symbolContext* VerilogParser::Next_stateContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Next_stateContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Next_stateContext::getRuleIndex() const {
  return VerilogParser::RuleNext_state;
}


std::any VerilogParser::Next_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNext_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Next_stateContext* VerilogParser::next_state() {
  Next_stateContext *_localctx = _tracker.createInstance<Next_stateContext>(_ctx, getState());
  enterRule(_localctx, 352, VerilogParser::RuleNext_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2817);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::OUTPUT_OR_LEVEL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2815);
        output_symbol();
        break;
      }

      case VerilogParser::MI: {
        enterOuterAlt(_localctx, 2);
        setState(2816);
        match(VerilogParser::MI);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_symbolContext ------------------------------------------------------------------

VerilogParser::Output_symbolContext::Output_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Output_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_symbol;
}


std::any VerilogParser::Output_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_symbolContext* VerilogParser::output_symbol() {
  Output_symbolContext *_localctx = _tracker.createInstance<Output_symbolContext>(_ctx, getState());
  enterRule(_localctx, 354, VerilogParser::RuleOutput_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2819);
    match(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_symbolContext ------------------------------------------------------------------

VerilogParser::Level_symbolContext::Level_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Level_symbolContext::LEVEL_ONLY_SYMBOL() {
  return getToken(VerilogParser::LEVEL_ONLY_SYMBOL, 0);
}

tree::TerminalNode* VerilogParser::Level_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Level_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_symbol;
}


std::any VerilogParser::Level_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_symbolContext* VerilogParser::level_symbol() {
  Level_symbolContext *_localctx = _tracker.createInstance<Level_symbolContext>(_ctx, getState());
  enterRule(_localctx, 356, VerilogParser::RuleLevel_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2821);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_symbolContext ------------------------------------------------------------------

VerilogParser::Edge_symbolContext::Edge_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_symbolContext::EDGE_SYMBOL() {
  return getToken(VerilogParser::EDGE_SYMBOL, 0);
}


size_t VerilogParser::Edge_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_symbol;
}


std::any VerilogParser::Edge_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_symbolContext* VerilogParser::edge_symbol() {
  Edge_symbolContext *_localctx = _tracker.createInstance<Edge_symbolContext>(_ctx, getState());
  enterRule(_localctx, 358, VerilogParser::RuleEdge_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2823);
    match(VerilogParser::EDGE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instantiationContext ------------------------------------------------------------------

VerilogParser::Udp_instantiationContext::Udp_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_instantiationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

std::vector<VerilogParser::Udp_instanceContext *> VerilogParser::Udp_instantiationContext::udp_instance() {
  return getRuleContexts<VerilogParser::Udp_instanceContext>();
}

VerilogParser::Udp_instanceContext* VerilogParser::Udp_instantiationContext::udp_instance(size_t i) {
  return getRuleContext<VerilogParser::Udp_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Udp_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay2Context* VerilogParser::Udp_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Udp_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instantiation;
}


std::any VerilogParser::Udp_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instantiationContext* VerilogParser::udp_instantiation() {
  Udp_instantiationContext *_localctx = _tracker.createInstance<Udp_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 360, VerilogParser::RuleUdp_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2825);
    udp_identifier();
    setState(2827);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      setState(2826);
      drive_strength();
      break;
    }

    default:
      break;
    }
    setState(2830);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2829);
      delay2();
    }
    setState(2832);
    udp_instance();
    setState(2837);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2833);
      match(VerilogParser::CO);
      setState(2834);
      udp_instance();
      setState(2839);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2840);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instanceContext ------------------------------------------------------------------

VerilogParser::Udp_instanceContext::Udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Udp_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::Udp_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::Udp_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::Udp_instanceContext::name_of_udp_instance() {
  return getRuleContext<VerilogParser::Name_of_udp_instanceContext>(0);
}


size_t VerilogParser::Udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance;
}


std::any VerilogParser::Udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instanceContext* VerilogParser::udp_instance() {
  Udp_instanceContext *_localctx = _tracker.createInstance<Udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 362, VerilogParser::RuleUdp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2843);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(2842);
      name_of_udp_instance();
    }
    setState(2845);
    match(VerilogParser::LP);
    setState(2846);
    output_terminal();
    setState(2847);
    match(VerilogParser::CO);
    setState(2848);
    input_terminal();
    setState(2853);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2849);
      match(VerilogParser::CO);
      setState(2850);
      input_terminal();
      setState(2855);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2856);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_udp_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_udp_instanceContext::Name_of_udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::Name_of_udp_instanceContext::udp_instance_identifier() {
  return getRuleContext<VerilogParser::Udp_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_udp_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_udp_instance;
}


std::any VerilogParser::Name_of_udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_udp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::name_of_udp_instance() {
  Name_of_udp_instanceContext *_localctx = _tracker.createInstance<Name_of_udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 364, VerilogParser::RuleName_of_udp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2858);
    udp_instance_identifier();
    setState(2860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2859);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continuous_assignContext ------------------------------------------------------------------

VerilogParser::Continuous_assignContext::Continuous_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::Continuous_assignContext::list_of_net_assignments() {
  return getRuleContext<VerilogParser::List_of_net_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Continuous_assignContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay3Context* VerilogParser::Continuous_assignContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}


size_t VerilogParser::Continuous_assignContext::getRuleIndex() const {
  return VerilogParser::RuleContinuous_assign;
}


std::any VerilogParser::Continuous_assignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitContinuous_assign(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Continuous_assignContext* VerilogParser::continuous_assign() {
  Continuous_assignContext *_localctx = _tracker.createInstance<Continuous_assignContext>(_ctx, getState());
  enterRule(_localctx, 366, VerilogParser::RuleContinuous_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2862);
    match(VerilogParser::ASSIGN);
    setState(2864);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(2863);
      drive_strength();
    }
    setState(2867);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2866);
      delay3();
    }
    setState(2869);
    list_of_net_assignments();
    setState(2870);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_assignmentsContext::List_of_net_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_assignmentContext *> VerilogParser::List_of_net_assignmentsContext::net_assignment() {
  return getRuleContexts<VerilogParser::Net_assignmentContext>();
}

VerilogParser::Net_assignmentContext* VerilogParser::List_of_net_assignmentsContext::net_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_assignments;
}


std::any VerilogParser::List_of_net_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::list_of_net_assignments() {
  List_of_net_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 368, VerilogParser::RuleList_of_net_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2872);
    net_assignment();
    setState(2877);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2873);
      match(VerilogParser::CO);
      setState(2874);
      net_assignment();
      setState(2879);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_assignmentContext::Net_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_assignmentContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Net_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_assignment;
}


std::any VerilogParser::Net_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_assignmentContext* VerilogParser::net_assignment() {
  Net_assignmentContext *_localctx = _tracker.createInstance<Net_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 370, VerilogParser::RuleNet_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2880);
    net_lvalue();
    setState(2881);
    match(VerilogParser::EQ);
    setState(2882);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_constructContext ------------------------------------------------------------------

VerilogParser::Initial_constructContext::Initial_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Initial_constructContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::StatementContext* VerilogParser::Initial_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Initial_constructContext::getRuleIndex() const {
  return VerilogParser::RuleInitial_construct;
}


std::any VerilogParser::Initial_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInitial_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Initial_constructContext* VerilogParser::initial_construct() {
  Initial_constructContext *_localctx = _tracker.createInstance<Initial_constructContext>(_ctx, getState());
  enterRule(_localctx, 372, VerilogParser::RuleInitial_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2884);
    match(VerilogParser::INITIAL);
    setState(2885);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Always_constructContext ------------------------------------------------------------------

VerilogParser::Always_constructContext::Always_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Always_constructContext::ALWAYS() {
  return getToken(VerilogParser::ALWAYS, 0);
}

VerilogParser::StatementContext* VerilogParser::Always_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Always_constructContext::getRuleIndex() const {
  return VerilogParser::RuleAlways_construct;
}


std::any VerilogParser::Always_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAlways_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Always_constructContext* VerilogParser::always_construct() {
  Always_constructContext *_localctx = _tracker.createInstance<Always_constructContext>(_ctx, getState());
  enterRule(_localctx, 374, VerilogParser::RuleAlways_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2887);
    match(VerilogParser::ALWAYS);
    setState(2888);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analog_constructContext ------------------------------------------------------------------

VerilogParser::Analog_constructContext::Analog_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Analog_constructContext::ANALOG() {
  return getToken(VerilogParser::ANALOG, 0);
}

VerilogParser::StatementContext* VerilogParser::Analog_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Analog_constructContext::getRuleIndex() const {
  return VerilogParser::RuleAnalog_construct;
}


std::any VerilogParser::Analog_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAnalog_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Analog_constructContext* VerilogParser::analog_construct() {
  Analog_constructContext *_localctx = _tracker.createInstance<Analog_constructContext>(_ctx, getState());
  enterRule(_localctx, 376, VerilogParser::RuleAnalog_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2890);
    match(VerilogParser::ANALOG);
    setState(2891);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Blocking_assignmentContext::Blocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Blocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Blocking_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Blocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Blocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Blocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleBlocking_assignment;
}


std::any VerilogParser::Blocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Blocking_assignmentContext* VerilogParser::blocking_assignment() {
  Blocking_assignmentContext *_localctx = _tracker.createInstance<Blocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 378, VerilogParser::RuleBlocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2893);
    variable_lvalue();
    setState(2894);
    match(VerilogParser::EQ);
    setState(2896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2895);
      delay_or_event_control();
    }
    setState(2898);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonblocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Nonblocking_assignmentContext::Nonblocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Nonblocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Nonblocking_assignmentContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Nonblocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Nonblocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Nonblocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNonblocking_assignment;
}


std::any VerilogParser::Nonblocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNonblocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::nonblocking_assignment() {
  Nonblocking_assignmentContext *_localctx = _tracker.createInstance<Nonblocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 380, VerilogParser::RuleNonblocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2900);
    variable_lvalue();
    setState(2901);
    match(VerilogParser::LTEQ);
    setState(2903);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2902);
      delay_or_event_control();
    }
    setState(2905);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analog_assignmentContext ------------------------------------------------------------------

VerilogParser::Analog_assignmentContext::Analog_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Function_callContext* VerilogParser::Analog_assignmentContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Analog_assignmentContext::LTPL() {
  return getToken(VerilogParser::LTPL, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Analog_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Analog_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Analog_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleAnalog_assignment;
}


std::any VerilogParser::Analog_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAnalog_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Analog_assignmentContext* VerilogParser::analog_assignment() {
  Analog_assignmentContext *_localctx = _tracker.createInstance<Analog_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 382, VerilogParser::RuleAnalog_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2907);
    function_call();
    setState(2908);
    match(VerilogParser::LTPL);
    setState(2910);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::REPEAT || _la == VerilogParser::AT

    || _la == VerilogParser::HA) {
      setState(2909);
      delay_or_event_control();
    }
    setState(2912);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_continuous_assignmentsContext ------------------------------------------------------------------

VerilogParser::Procedural_continuous_assignmentsContext::Procedural_continuous_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::Variable_assignmentContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_assignment() {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::DEASSIGN() {
  return getToken(VerilogParser::DEASSIGN, 0);
}

VerilogParser::Variable_lvalueContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::FORCE() {
  return getToken(VerilogParser::FORCE, 0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::RELEASE() {
  return getToken(VerilogParser::RELEASE, 0);
}


size_t VerilogParser::Procedural_continuous_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_continuous_assignments;
}


std::any VerilogParser::Procedural_continuous_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_continuous_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::procedural_continuous_assignments() {
  Procedural_continuous_assignmentsContext *_localctx = _tracker.createInstance<Procedural_continuous_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 384, VerilogParser::RuleProcedural_continuous_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2922);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ASSIGN: {
        enterOuterAlt(_localctx, 1);
        setState(2914);
        match(VerilogParser::ASSIGN);
        setState(2915);
        variable_assignment();
        break;
      }

      case VerilogParser::DEASSIGN: {
        enterOuterAlt(_localctx, 2);
        setState(2916);
        match(VerilogParser::DEASSIGN);
        setState(2917);
        variable_lvalue();
        break;
      }

      case VerilogParser::FORCE: {
        enterOuterAlt(_localctx, 3);
        setState(2918);
        match(VerilogParser::FORCE);
        setState(2919);
        variable_assignment();
        break;
      }

      case VerilogParser::RELEASE: {
        enterOuterAlt(_localctx, 4);
        setState(2920);
        match(VerilogParser::RELEASE);
        setState(2921);
        variable_lvalue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_assignmentContext ------------------------------------------------------------------

VerilogParser::Variable_assignmentContext::Variable_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Variable_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Variable_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Variable_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_assignment;
}


std::any VerilogParser::Variable_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_assignmentContext* VerilogParser::variable_assignment() {
  Variable_assignmentContext *_localctx = _tracker.createInstance<Variable_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 386, VerilogParser::RuleVariable_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2924);
    variable_lvalue();
    setState(2925);
    match(VerilogParser::EQ);
    setState(2926);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Par_blockContext ------------------------------------------------------------------

VerilogParser::Par_blockContext::Par_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Par_blockContext::FORK() {
  return getToken(VerilogParser::FORK, 0);
}

tree::TerminalNode* VerilogParser::Par_blockContext::JOIN() {
  return getToken(VerilogParser::JOIN, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Par_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Par_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Par_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Par_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Par_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Par_blockContext::getRuleIndex() const {
  return VerilogParser::RulePar_block;
}


std::any VerilogParser::Par_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPar_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Par_blockContext* VerilogParser::par_block() {
  Par_blockContext *_localctx = _tracker.createInstance<Par_blockContext>(_ctx, getState());
  enterRule(_localctx, 388, VerilogParser::RulePar_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2928);
    match(VerilogParser::FORK);
    setState(2936);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2929);
      block_name();
      setState(2933);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2930);
          block_item_declaration(); 
        }
        setState(2935);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx);
      }
    }
    setState(2941);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18542164091375144) != 0) || ((((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 73014444035) != 0) || ((((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 180706949007409153) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(2938);
      statement();
      setState(2943);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2944);
    match(VerilogParser::JOIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_nameContext ------------------------------------------------------------------

VerilogParser::Block_nameContext::Block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Block_identifierContext* VerilogParser::Block_nameContext::block_identifier() {
  return getRuleContext<VerilogParser::Block_identifierContext>(0);
}


size_t VerilogParser::Block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_name;
}


std::any VerilogParser::Block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_nameContext* VerilogParser::block_name() {
  Block_nameContext *_localctx = _tracker.createInstance<Block_nameContext>(_ctx, getState());
  enterRule(_localctx, 390, VerilogParser::RuleBlock_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2946);
    match(VerilogParser::CL);
    setState(2947);
    block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_blockContext ------------------------------------------------------------------

VerilogParser::Seq_blockContext::Seq_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Seq_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Seq_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Seq_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Seq_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Seq_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Seq_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Seq_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Seq_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_block;
}


std::any VerilogParser::Seq_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_blockContext* VerilogParser::seq_block() {
  Seq_blockContext *_localctx = _tracker.createInstance<Seq_blockContext>(_ctx, getState());
  enterRule(_localctx, 392, VerilogParser::RuleSeq_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2949);
    match(VerilogParser::BEGIN);
    setState(2957);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2950);
      block_name();
      setState(2954);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2951);
          block_item_declaration(); 
        }
        setState(2956);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
      }
    }
    setState(2962);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18542164091375144) != 0) || ((((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 73014444035) != 0) || ((((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 180706949007409153) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(2959);
      statement();
      setState(2964);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2965);
    match(VerilogParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

VerilogParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Blocking_assignmentContext* VerilogParser::StatementContext::blocking_assignment() {
  return getRuleContext<VerilogParser::Blocking_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::StatementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::StatementContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::StatementContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Case_statementContext* VerilogParser::StatementContext::case_statement() {
  return getRuleContext<VerilogParser::Case_statementContext>(0);
}

VerilogParser::Conditional_statementContext* VerilogParser::StatementContext::conditional_statement() {
  return getRuleContext<VerilogParser::Conditional_statementContext>(0);
}

VerilogParser::Disable_statementContext* VerilogParser::StatementContext::disable_statement() {
  return getRuleContext<VerilogParser::Disable_statementContext>(0);
}

VerilogParser::Event_triggerContext* VerilogParser::StatementContext::event_trigger() {
  return getRuleContext<VerilogParser::Event_triggerContext>(0);
}

VerilogParser::Loop_statementContext* VerilogParser::StatementContext::loop_statement() {
  return getRuleContext<VerilogParser::Loop_statementContext>(0);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::StatementContext::nonblocking_assignment() {
  return getRuleContext<VerilogParser::Nonblocking_assignmentContext>(0);
}

VerilogParser::Analog_assignmentContext* VerilogParser::StatementContext::analog_assignment() {
  return getRuleContext<VerilogParser::Analog_assignmentContext>(0);
}

VerilogParser::Par_blockContext* VerilogParser::StatementContext::par_block() {
  return getRuleContext<VerilogParser::Par_blockContext>(0);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::StatementContext::procedural_continuous_assignments() {
  return getRuleContext<VerilogParser::Procedural_continuous_assignmentsContext>(0);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::StatementContext::procedural_timing_control_statement() {
  return getRuleContext<VerilogParser::Procedural_timing_control_statementContext>(0);
}

VerilogParser::Seq_blockContext* VerilogParser::StatementContext::seq_block() {
  return getRuleContext<VerilogParser::Seq_blockContext>(0);
}

VerilogParser::System_task_enableContext* VerilogParser::StatementContext::system_task_enable() {
  return getRuleContext<VerilogParser::System_task_enableContext>(0);
}

VerilogParser::Task_enableContext* VerilogParser::StatementContext::task_enable() {
  return getRuleContext<VerilogParser::Task_enableContext>(0);
}

VerilogParser::Wait_statementContext* VerilogParser::StatementContext::wait_statement() {
  return getRuleContext<VerilogParser::Wait_statementContext>(0);
}


size_t VerilogParser::StatementContext::getRuleIndex() const {
  return VerilogParser::RuleStatement;
}


std::any VerilogParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::StatementContext* VerilogParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 394, VerilogParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3080);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2970);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2967);
        attribute_instance();
        setState(2972);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2973);
      blocking_assignment();
      setState(2974);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2979);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2976);
        attribute_instance();
        setState(2981);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2982);
      case_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2986);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2983);
        attribute_instance();
        setState(2988);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2989);
      conditional_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2993);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2990);
        attribute_instance();
        setState(2995);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2996);
      disable_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3000);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2997);
        attribute_instance();
        setState(3002);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3003);
      event_trigger();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3007);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3004);
        attribute_instance();
        setState(3009);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3010);
      loop_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3014);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3011);
        attribute_instance();
        setState(3016);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3017);
      nonblocking_assignment();
      setState(3018);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3023);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3020);
        attribute_instance();
        setState(3025);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3026);
      analog_assignment();
      setState(3027);
      match(VerilogParser::SC);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3032);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3029);
        attribute_instance();
        setState(3034);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3035);
      par_block();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3039);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3036);
        attribute_instance();
        setState(3041);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3042);
      procedural_continuous_assignments();
      setState(3043);
      match(VerilogParser::SC);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3048);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3045);
        attribute_instance();
        setState(3050);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3051);
      procedural_timing_control_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3055);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3052);
        attribute_instance();
        setState(3057);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3058);
      seq_block();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3062);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3059);
        attribute_instance();
        setState(3064);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3065);
      system_task_enable();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3069);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3066);
        attribute_instance();
        setState(3071);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3072);
      task_enable();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3076);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3073);
        attribute_instance();
        setState(3078);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3079);
      wait_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_or_nullContext ------------------------------------------------------------------

VerilogParser::Statement_or_nullContext::Statement_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Statement_or_nullContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Statement_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Statement_or_nullContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Statement_or_nullContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Statement_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleStatement_or_null;
}


std::any VerilogParser::Statement_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Statement_or_nullContext* VerilogParser::statement_or_null() {
  Statement_or_nullContext *_localctx = _tracker.createInstance<Statement_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 396, VerilogParser::RuleStatement_or_null);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3090);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3082);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3086);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(3083);
        attribute_instance();
        setState(3088);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3089);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_statementContext ------------------------------------------------------------------

VerilogParser::Function_statementContext::Function_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Function_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Function_statementContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_statement;
}


std::any VerilogParser::Function_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_statementContext* VerilogParser::function_statement() {
  Function_statementContext *_localctx = _tracker.createInstance<Function_statementContext>(_ctx, getState());
  enterRule(_localctx, 398, VerilogParser::RuleFunction_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3092);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_controlContext ------------------------------------------------------------------

VerilogParser::Delay_controlContext::Delay_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay_controlContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay_controlContext::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay_controlContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_control;
}


std::any VerilogParser::Delay_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_controlContext* VerilogParser::delay_control() {
  Delay_controlContext *_localctx = _tracker.createInstance<Delay_controlContext>(_ctx, getState());
  enterRule(_localctx, 400, VerilogParser::RuleDelay_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3101);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3094);
      match(VerilogParser::HA);
      setState(3095);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3096);
      match(VerilogParser::HA);
      setState(3097);
      match(VerilogParser::LP);
      setState(3098);
      mintypmax_expression();
      setState(3099);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_or_event_controlContext ------------------------------------------------------------------

VerilogParser::Delay_or_event_controlContext::Delay_or_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Delay_or_event_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Delay_or_event_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Delay_or_event_controlContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_or_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_or_event_control;
}


std::any VerilogParser::Delay_or_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_or_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::delay_or_event_control() {
  Delay_or_event_controlContext *_localctx = _tracker.createInstance<Delay_or_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 402, VerilogParser::RuleDelay_or_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3111);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(3103);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(3104);
        event_control();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 3);
        setState(3105);
        match(VerilogParser::REPEAT);
        setState(3106);
        match(VerilogParser::LP);
        setState(3107);
        expression(0);
        setState(3108);
        match(VerilogParser::RP);
        setState(3109);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Disable_statementContext ------------------------------------------------------------------

VerilogParser::Disable_statementContext::Disable_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Disable_statementContext::DISABLE() {
  return getToken(VerilogParser::DISABLE, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Disable_statementContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Disable_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Disable_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDisable_statement;
}


std::any VerilogParser::Disable_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDisable_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Disable_statementContext* VerilogParser::disable_statement() {
  Disable_statementContext *_localctx = _tracker.createInstance<Disable_statementContext>(_ctx, getState());
  enterRule(_localctx, 404, VerilogParser::RuleDisable_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3113);
    match(VerilogParser::DISABLE);
    setState(3114);
    hierarchical_identifier();
    setState(3115);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_controlContext ------------------------------------------------------------------

VerilogParser::Event_controlContext::Event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_controlContext::AT() {
  return getToken(VerilogParser::AT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_controlContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Event_expressionContext* VerilogParser::Event_controlContext::event_expression() {
  return getRuleContext<VerilogParser::Event_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::AS() {
  return getToken(VerilogParser::AS, 0);
}


size_t VerilogParser::Event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_control;
}


std::any VerilogParser::Event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_controlContext* VerilogParser::event_control() {
  Event_controlContext *_localctx = _tracker.createInstance<Event_controlContext>(_ctx, getState());
  enterRule(_localctx, 406, VerilogParser::RuleEvent_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3130);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3117);
      match(VerilogParser::AT);
      setState(3118);
      hierarchical_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3119);
      match(VerilogParser::AT);
      setState(3120);
      match(VerilogParser::LP);
      setState(3121);
      event_expression(0);
      setState(3122);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3124);
      match(VerilogParser::AT);
      setState(3125);
      match(VerilogParser::AS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3126);
      match(VerilogParser::AT);
      setState(3127);
      match(VerilogParser::LP);
      setState(3128);
      match(VerilogParser::AS);
      setState(3129);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_triggerContext ------------------------------------------------------------------

VerilogParser::Event_triggerContext::Event_triggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_triggerContext::MIGT() {
  return getToken(VerilogParser::MIGT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_triggerContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_triggerContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Event_triggerContext::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Event_triggerContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_trigger;
}


std::any VerilogParser::Event_triggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_triggerContext* VerilogParser::event_trigger() {
  Event_triggerContext *_localctx = _tracker.createInstance<Event_triggerContext>(_ctx, getState());
  enterRule(_localctx, 408, VerilogParser::RuleEvent_trigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3132);
    match(VerilogParser::MIGT);
    setState(3133);
    hierarchical_identifier();
    setState(3135);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3134);
      bit_select();
    }
    setState(3137);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_expressionContext ------------------------------------------------------------------

VerilogParser::Event_expressionContext::Event_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Event_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

std::vector<VerilogParser::Event_expressionContext *> VerilogParser::Event_expressionContext::event_expression() {
  return getRuleContexts<VerilogParser::Event_expressionContext>();
}

VerilogParser::Event_expressionContext* VerilogParser::Event_expressionContext::event_expression(size_t i) {
  return getRuleContext<VerilogParser::Event_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Event_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_expression;
}


std::any VerilogParser::Event_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Event_expressionContext* VerilogParser::event_expression() {
   return event_expression(0);
}

VerilogParser::Event_expressionContext* VerilogParser::event_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Event_expressionContext *_localctx = _tracker.createInstance<Event_expressionContext>(_ctx, parentState);
  VerilogParser::Event_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 410;
  enterRecursionRule(_localctx, 410, VerilogParser::RuleEvent_expression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3145);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        setState(3140);
        expression(0);
        break;
      }

      case VerilogParser::POSEDGE: {
        setState(3141);
        match(VerilogParser::POSEDGE);
        setState(3142);
        expression(0);
        break;
      }

      case VerilogParser::NEGEDGE: {
        setState(3143);
        match(VerilogParser::NEGEDGE);
        setState(3144);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(3155);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(3153);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3147);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(3148);
          match(VerilogParser::OR);
          setState(3149);
          event_expression(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3150);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(3151);
          match(VerilogParser::CO);
          setState(3152);
          event_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(3157);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Procedural_timing_controlContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_controlContext::Procedural_timing_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Procedural_timing_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Procedural_timing_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}


size_t VerilogParser::Procedural_timing_controlContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control;
}


std::any VerilogParser::Procedural_timing_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::procedural_timing_control() {
  Procedural_timing_controlContext *_localctx = _tracker.createInstance<Procedural_timing_controlContext>(_ctx, getState());
  enterRule(_localctx, 412, VerilogParser::RuleProcedural_timing_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3160);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(3158);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(3159);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_timing_control_statementContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_control_statementContext::Procedural_timing_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::Procedural_timing_control_statementContext::procedural_timing_control() {
  return getRuleContext<VerilogParser::Procedural_timing_controlContext>(0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Procedural_timing_control_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Procedural_timing_control_statementContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control_statement;
}


std::any VerilogParser::Procedural_timing_control_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::procedural_timing_control_statement() {
  Procedural_timing_control_statementContext *_localctx = _tracker.createInstance<Procedural_timing_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 414, VerilogParser::RuleProcedural_timing_control_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3162);
    procedural_timing_control();
    setState(3163);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wait_statementContext ------------------------------------------------------------------

VerilogParser::Wait_statementContext::Wait_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Wait_statementContext::WAIT() {
  return getToken(VerilogParser::WAIT, 0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Wait_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Wait_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Wait_statementContext::getRuleIndex() const {
  return VerilogParser::RuleWait_statement;
}


std::any VerilogParser::Wait_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWait_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Wait_statementContext* VerilogParser::wait_statement() {
  Wait_statementContext *_localctx = _tracker.createInstance<Wait_statementContext>(_ctx, getState());
  enterRule(_localctx, 416, VerilogParser::RuleWait_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3165);
    match(VerilogParser::WAIT);
    setState(3166);
    match(VerilogParser::LP);
    setState(3167);
    expression(0);
    setState(3168);
    match(VerilogParser::RP);
    setState(3169);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_statementContext ------------------------------------------------------------------

VerilogParser::Conditional_statementContext::Conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Conditional_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Statement_or_nullContext *> VerilogParser::Conditional_statementContext::statement_or_null() {
  return getRuleContexts<VerilogParser::Statement_or_nullContext>();
}

VerilogParser::Statement_or_nullContext* VerilogParser::Conditional_statementContext::statement_or_null(size_t i) {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::Conditional_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_statement;
}


std::any VerilogParser::Conditional_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_statementContext* VerilogParser::conditional_statement() {
  Conditional_statementContext *_localctx = _tracker.createInstance<Conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 418, VerilogParser::RuleConditional_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3171);
    match(VerilogParser::IF);
    setState(3172);
    match(VerilogParser::LP);
    setState(3173);
    expression(0);
    setState(3174);
    match(VerilogParser::RP);
    setState(3175);
    statement_or_null();
    setState(3178);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
    case 1: {
      setState(3176);
      match(VerilogParser::ELSE);
      setState(3177);
      statement_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_statementContext ------------------------------------------------------------------

VerilogParser::Case_statementContext::Case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Case_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_itemContext *> VerilogParser::Case_statementContext::case_item() {
  return getRuleContexts<VerilogParser::Case_itemContext>();
}

VerilogParser::Case_itemContext* VerilogParser::Case_statementContext::case_item(size_t i) {
  return getRuleContext<VerilogParser::Case_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEZ() {
  return getToken(VerilogParser::CASEZ, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEX() {
  return getToken(VerilogParser::CASEX, 0);
}


size_t VerilogParser::Case_statementContext::getRuleIndex() const {
  return VerilogParser::RuleCase_statement;
}


std::any VerilogParser::Case_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_statementContext* VerilogParser::case_statement() {
  Case_statementContext *_localctx = _tracker.createInstance<Case_statementContext>(_ctx, getState());
  enterRule(_localctx, 420, VerilogParser::RuleCase_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3213);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(3180);
        match(VerilogParser::CASE);
        setState(3181);
        match(VerilogParser::LP);
        setState(3182);
        expression(0);
        setState(3183);
        match(VerilogParser::RP);
        setState(3185); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3184);
          case_item();
          setState(3187); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 168) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER);
        setState(3189);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEZ: {
        enterOuterAlt(_localctx, 2);
        setState(3191);
        match(VerilogParser::CASEZ);
        setState(3192);
        match(VerilogParser::LP);
        setState(3193);
        expression(0);
        setState(3194);
        match(VerilogParser::RP);
        setState(3196); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3195);
          case_item();
          setState(3198); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 168) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER);
        setState(3200);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEX: {
        enterOuterAlt(_localctx, 3);
        setState(3202);
        match(VerilogParser::CASEX);
        setState(3203);
        match(VerilogParser::LP);
        setState(3204);
        expression(0);
        setState(3205);
        match(VerilogParser::RP);
        setState(3207); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3206);
          case_item();
          setState(3209); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == VerilogParser::DEFAULT || ((((_la - 168) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER);
        setState(3211);
        match(VerilogParser::ENDCASE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_itemContext ------------------------------------------------------------------

VerilogParser::Case_itemContext::Case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Case_itemContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Case_itemContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Case_itemContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_item;
}


std::any VerilogParser::Case_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_itemContext* VerilogParser::case_item() {
  Case_itemContext *_localctx = _tracker.createInstance<Case_itemContext>(_ctx, getState());
  enterRule(_localctx, 422, VerilogParser::RuleCase_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3231);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(3215);
        expression(0);
        setState(3220);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(3216);
          match(VerilogParser::CO);
          setState(3217);
          expression(0);
          setState(3222);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3223);
        match(VerilogParser::CL);
        setState(3224);
        statement_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(3226);
        match(VerilogParser::DEFAULT);
        setState(3228);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(3227);
          match(VerilogParser::CL);
        }
        setState(3230);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statementContext ------------------------------------------------------------------

VerilogParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOREVER() {
  return getToken(VerilogParser::FOREVER, 0);
}

VerilogParser::StatementContext* VerilogParser::Loop_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Loop_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::WHILE() {
  return getToken(VerilogParser::WHILE, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

std::vector<VerilogParser::Variable_assignmentContext *> VerilogParser::Loop_statementContext::variable_assignment() {
  return getRuleContexts<VerilogParser::Variable_assignmentContext>();
}

VerilogParser::Variable_assignmentContext* VerilogParser::Loop_statementContext::variable_assignment(size_t i) {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_statementContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}


size_t VerilogParser::Loop_statementContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_statement;
}


std::any VerilogParser::Loop_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_statementContext* VerilogParser::loop_statement() {
  Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 424, VerilogParser::RuleLoop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3257);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FOREVER: {
        enterOuterAlt(_localctx, 1);
        setState(3233);
        match(VerilogParser::FOREVER);
        setState(3234);
        statement();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 2);
        setState(3235);
        match(VerilogParser::REPEAT);
        setState(3236);
        match(VerilogParser::LP);
        setState(3237);
        expression(0);
        setState(3238);
        match(VerilogParser::RP);
        setState(3239);
        statement();
        break;
      }

      case VerilogParser::WHILE: {
        enterOuterAlt(_localctx, 3);
        setState(3241);
        match(VerilogParser::WHILE);
        setState(3242);
        match(VerilogParser::LP);
        setState(3243);
        expression(0);
        setState(3244);
        match(VerilogParser::RP);
        setState(3245);
        statement();
        break;
      }

      case VerilogParser::FOR: {
        enterOuterAlt(_localctx, 4);
        setState(3247);
        match(VerilogParser::FOR);
        setState(3248);
        match(VerilogParser::LP);
        setState(3249);
        variable_assignment();
        setState(3250);
        match(VerilogParser::SC);
        setState(3251);
        expression(0);
        setState(3252);
        match(VerilogParser::SC);
        setState(3253);
        variable_assignment();
        setState(3254);
        match(VerilogParser::RP);
        setState(3255);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_enableContext ------------------------------------------------------------------

VerilogParser::System_task_enableContext::System_task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_task_identifierContext* VerilogParser::System_task_enableContext::system_task_identifier() {
  return getRuleContext<VerilogParser::System_task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::System_task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::System_task_enableContext::sys_task_en_port_list() {
  return getRuleContext<VerilogParser::Sys_task_en_port_listContext>(0);
}


size_t VerilogParser::System_task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_enable;
}


std::any VerilogParser::System_task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_enableContext* VerilogParser::system_task_enable() {
  System_task_enableContext *_localctx = _tracker.createInstance<System_task_enableContext>(_ctx, getState());
  enterRule(_localctx, 426, VerilogParser::RuleSystem_task_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3259);
    system_task_identifier();
    setState(3261);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3260);
      sys_task_en_port_list();
    }
    setState(3263);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_listContext::Sys_task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Sys_task_en_port_itemContext *> VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item() {
  return getRuleContexts<VerilogParser::Sys_task_en_port_itemContext>();
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item(size_t i) {
  return getRuleContext<VerilogParser::Sys_task_en_port_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_list;
}


std::any VerilogParser::Sys_task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::sys_task_en_port_list() {
  Sys_task_en_port_listContext *_localctx = _tracker.createInstance<Sys_task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 428, VerilogParser::RuleSys_task_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3265);
    match(VerilogParser::LP);
    setState(3266);
    sys_task_en_port_item();
    setState(3271);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3267);
      match(VerilogParser::CO);
      setState(3268);
      sys_task_en_port_item();
      setState(3273);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3274);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_itemContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_itemContext::Sys_task_en_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Sys_task_en_port_itemContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Sys_task_en_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_item;
}


std::any VerilogParser::Sys_task_en_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::sys_task_en_port_item() {
  Sys_task_en_port_itemContext *_localctx = _tracker.createInstance<Sys_task_en_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 430, VerilogParser::RuleSys_task_en_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3277);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(3276);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_enableContext ------------------------------------------------------------------

VerilogParser::Task_enableContext::Task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Task_enableContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Task_en_port_listContext* VerilogParser::Task_enableContext::task_en_port_list() {
  return getRuleContext<VerilogParser::Task_en_port_listContext>(0);
}


size_t VerilogParser::Task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleTask_enable;
}


std::any VerilogParser::Task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_enableContext* VerilogParser::task_enable() {
  Task_enableContext *_localctx = _tracker.createInstance<Task_enableContext>(_ctx, getState());
  enterRule(_localctx, 432, VerilogParser::RuleTask_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3279);
    hierarchical_identifier();
    setState(3281);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3280);
      task_en_port_list();
    }
    setState(3283);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Task_en_port_listContext::Task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Task_en_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Task_en_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_en_port_list;
}


std::any VerilogParser::Task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_en_port_listContext* VerilogParser::task_en_port_list() {
  Task_en_port_listContext *_localctx = _tracker.createInstance<Task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 434, VerilogParser::RuleTask_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3285);
    match(VerilogParser::LP);
    setState(3286);
    expression(0);
    setState(3291);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3287);
      match(VerilogParser::CO);
      setState(3288);
      expression(0);
      setState(3293);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3294);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_blockContext ------------------------------------------------------------------

VerilogParser::Specify_blockContext::Specify_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specify_blockContext::SPECIFY() {
  return getToken(VerilogParser::SPECIFY, 0);
}

tree::TerminalNode* VerilogParser::Specify_blockContext::ENDSPECIFY() {
  return getToken(VerilogParser::ENDSPECIFY, 0);
}

std::vector<VerilogParser::Specify_itemContext *> VerilogParser::Specify_blockContext::specify_item() {
  return getRuleContexts<VerilogParser::Specify_itemContext>();
}

VerilogParser::Specify_itemContext* VerilogParser::Specify_blockContext::specify_item(size_t i) {
  return getRuleContext<VerilogParser::Specify_itemContext>(i);
}


size_t VerilogParser::Specify_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_block;
}


std::any VerilogParser::Specify_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_blockContext* VerilogParser::specify_block() {
  Specify_blockContext *_localctx = _tracker.createInstance<Specify_blockContext>(_ctx, getState());
  enterRule(_localctx, 436, VerilogParser::RuleSpecify_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3296);
    match(VerilogParser::SPECIFY);
    setState(3300);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 54043199822364672) != 0) || ((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 9126903809) != 0) || _la == VerilogParser::LP) {
      setState(3297);
      specify_item();
      setState(3302);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3303);
    match(VerilogParser::ENDSPECIFY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_itemContext ------------------------------------------------------------------

VerilogParser::Specify_itemContext::Specify_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_declarationContext* VerilogParser::Specify_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::Specify_itemContext::pulsestyle_declaration() {
  return getRuleContext<VerilogParser::Pulsestyle_declarationContext>(0);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::Specify_itemContext::showcancelled_declaration() {
  return getRuleContext<VerilogParser::Showcancelled_declarationContext>(0);
}

VerilogParser::Path_declarationContext* VerilogParser::Specify_itemContext::path_declaration() {
  return getRuleContext<VerilogParser::Path_declarationContext>(0);
}

VerilogParser::System_timing_checkContext* VerilogParser::Specify_itemContext::system_timing_check() {
  return getRuleContext<VerilogParser::System_timing_checkContext>(0);
}


size_t VerilogParser::Specify_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_item;
}


std::any VerilogParser::Specify_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_itemContext* VerilogParser::specify_item() {
  Specify_itemContext *_localctx = _tracker.createInstance<Specify_itemContext>(_ctx, getState());
  enterRule(_localctx, 438, VerilogParser::RuleSpecify_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3310);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SPECPARAM: {
        enterOuterAlt(_localctx, 1);
        setState(3305);
        specparam_declaration();
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT:
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 2);
        setState(3306);
        pulsestyle_declaration();
        break;
      }

      case VerilogParser::NOSHOWCANCELLED:
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 3);
        setState(3307);
        showcancelled_declaration();
        break;
      }

      case VerilogParser::IF:
      case VerilogParser::IFNONE:
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 4);
        setState(3308);
        path_declaration();
        break;
      }

      case VerilogParser::DLFULLSKEW:
      case VerilogParser::DLHOLD:
      case VerilogParser::DLNOCHANGE:
      case VerilogParser::DLPERIOD:
      case VerilogParser::DLRECOVERY:
      case VerilogParser::DLRECREM:
      case VerilogParser::DLREMOVAL:
      case VerilogParser::DLSETUP:
      case VerilogParser::DLSETUPHOLD:
      case VerilogParser::DLSKEW:
      case VerilogParser::DLTIMESKEW:
      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 5);
        setState(3309);
        system_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulsestyle_declarationContext ------------------------------------------------------------------

VerilogParser::Pulsestyle_declarationContext::Pulsestyle_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONEVENT() {
  return getToken(VerilogParser::PULSESTYLE_ONEVENT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Pulsestyle_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONDETECT() {
  return getToken(VerilogParser::PULSESTYLE_ONDETECT, 0);
}


size_t VerilogParser::Pulsestyle_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePulsestyle_declaration;
}


std::any VerilogParser::Pulsestyle_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulsestyle_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::pulsestyle_declaration() {
  Pulsestyle_declarationContext *_localctx = _tracker.createInstance<Pulsestyle_declarationContext>(_ctx, getState());
  enterRule(_localctx, 440, VerilogParser::RulePulsestyle_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3320);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 1);
        setState(3312);
        match(VerilogParser::PULSESTYLE_ONEVENT);
        setState(3313);
        list_of_path_outputs();
        setState(3314);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT: {
        enterOuterAlt(_localctx, 2);
        setState(3316);
        match(VerilogParser::PULSESTYLE_ONDETECT);
        setState(3317);
        list_of_path_outputs();
        setState(3318);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Showcancelled_declarationContext ------------------------------------------------------------------

VerilogParser::Showcancelled_declarationContext::Showcancelled_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SHOWCANCELLED() {
  return getToken(VerilogParser::SHOWCANCELLED, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Showcancelled_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::NOSHOWCANCELLED() {
  return getToken(VerilogParser::NOSHOWCANCELLED, 0);
}


size_t VerilogParser::Showcancelled_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleShowcancelled_declaration;
}


std::any VerilogParser::Showcancelled_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitShowcancelled_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::showcancelled_declaration() {
  Showcancelled_declarationContext *_localctx = _tracker.createInstance<Showcancelled_declarationContext>(_ctx, getState());
  enterRule(_localctx, 442, VerilogParser::RuleShowcancelled_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3330);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 1);
        setState(3322);
        match(VerilogParser::SHOWCANCELLED);
        setState(3323);
        list_of_path_outputs();
        setState(3324);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NOSHOWCANCELLED: {
        enterOuterAlt(_localctx, 2);
        setState(3326);
        match(VerilogParser::NOSHOWCANCELLED);
        setState(3327);
        list_of_path_outputs();
        setState(3328);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_declarationContext ------------------------------------------------------------------

VerilogParser::Path_declarationContext::Path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Simple_path_declarationContext* VerilogParser::Path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Path_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::Path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::Path_declarationContext::state_dependent_path_declaration() {
  return getRuleContext<VerilogParser::State_dependent_path_declarationContext>(0);
}


size_t VerilogParser::Path_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePath_declaration;
}


std::any VerilogParser::Path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_declarationContext* VerilogParser::path_declaration() {
  Path_declarationContext *_localctx = _tracker.createInstance<Path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 444, VerilogParser::RulePath_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3341);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3332);
      simple_path_declaration();
      setState(3333);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3335);
      edge_sensitive_path_declaration();
      setState(3336);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3338);
      state_dependent_path_declaration();
      setState(3339);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_path_declarationContext ------------------------------------------------------------------

VerilogParser::Simple_path_declarationContext::Simple_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::Simple_path_declarationContext::parallel_path_description() {
  return getRuleContext<VerilogParser::Parallel_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Simple_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Simple_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::Simple_path_declarationContext::full_path_description() {
  return getRuleContext<VerilogParser::Full_path_descriptionContext>(0);
}


size_t VerilogParser::Simple_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_path_declaration;
}


std::any VerilogParser::Simple_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::simple_path_declaration() {
  Simple_path_declarationContext *_localctx = _tracker.createInstance<Simple_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 446, VerilogParser::RuleSimple_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3351);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3343);
      parallel_path_description();
      setState(3344);
      match(VerilogParser::EQ);
      setState(3345);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3347);
      full_path_description();
      setState(3348);
      match(VerilogParser::EQ);
      setState(3349);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_path_descriptionContext::Parallel_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_path_description;
}


std::any VerilogParser::Parallel_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::parallel_path_description() {
  Parallel_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 448, VerilogParser::RuleParallel_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3353);
    match(VerilogParser::LP);
    setState(3354);
    specify_input_terminal_descriptor();
    setState(3356);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3355);
      polarity_operator();
    }
    setState(3358);
    match(VerilogParser::EQGT);
    setState(3359);
    specify_output_terminal_descriptor();
    setState(3360);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_path_descriptionContext::Full_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_path_description;
}


std::any VerilogParser::Full_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::full_path_description() {
  Full_path_descriptionContext *_localctx = _tracker.createInstance<Full_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 450, VerilogParser::RuleFull_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3362);
    match(VerilogParser::LP);
    setState(3363);
    list_of_path_inputs();
    setState(3365);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3364);
      polarity_operator();
    }
    setState(3367);
    match(VerilogParser::ASGT);
    setState(3368);
    list_of_path_outputs();
    setState(3369);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_inputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_inputsContext::List_of_path_inputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_input_terminal_descriptorContext *> VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_input_terminal_descriptorContext>();
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_inputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_inputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_inputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_inputs;
}


std::any VerilogParser::List_of_path_inputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_inputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::list_of_path_inputs() {
  List_of_path_inputsContext *_localctx = _tracker.createInstance<List_of_path_inputsContext>(_ctx, getState());
  enterRule(_localctx, 452, VerilogParser::RuleList_of_path_inputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3371);
    specify_input_terminal_descriptor();
    setState(3376);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3372);
      match(VerilogParser::CO);
      setState(3373);
      specify_input_terminal_descriptor();
      setState(3378);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_outputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_outputsContext::List_of_path_outputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_output_terminal_descriptorContext *> VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_output_terminal_descriptorContext>();
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_outputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_outputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_outputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_outputs;
}


std::any VerilogParser::List_of_path_outputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_outputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::list_of_path_outputs() {
  List_of_path_outputsContext *_localctx = _tracker.createInstance<List_of_path_outputsContext>(_ctx, getState());
  enterRule(_localctx, 454, VerilogParser::RuleList_of_path_outputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3379);
    specify_output_terminal_descriptor();
    setState(3384);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3380);
      match(VerilogParser::CO);
      setState(3381);
      specify_output_terminal_descriptor();
      setState(3386);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_input_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_input_terminal_descriptorContext::Specify_input_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Input_identifierContext* VerilogParser::Specify_input_terminal_descriptorContext::input_identifier() {
  return getRuleContext<VerilogParser::Input_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_input_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_input_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_input_terminal_descriptor;
}


std::any VerilogParser::Specify_input_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_input_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::specify_input_terminal_descriptor() {
  Specify_input_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_input_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 456, VerilogParser::RuleSpecify_input_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3387);
    input_identifier();
    setState(3392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3388);
      match(VerilogParser::LB);
      setState(3389);
      constant_range_expression();
      setState(3390);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_output_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_output_terminal_descriptorContext::Specify_output_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_identifierContext* VerilogParser::Specify_output_terminal_descriptorContext::output_identifier() {
  return getRuleContext<VerilogParser::Output_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_output_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_output_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_output_terminal_descriptor;
}


std::any VerilogParser::Specify_output_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_output_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::specify_output_terminal_descriptor() {
  Specify_output_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_output_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 458, VerilogParser::RuleSpecify_output_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3394);
    output_identifier();
    setState(3399);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3395);
      match(VerilogParser::LB);
      setState(3396);
      constant_range_expression();
      setState(3397);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_identifierContext ------------------------------------------------------------------

VerilogParser::Input_identifierContext::Input_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Input_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Input_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_identifier;
}


std::any VerilogParser::Input_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_identifierContext* VerilogParser::input_identifier() {
  Input_identifierContext *_localctx = _tracker.createInstance<Input_identifierContext>(_ctx, getState());
  enterRule(_localctx, 460, VerilogParser::RuleInput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3401);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_identifierContext ------------------------------------------------------------------

VerilogParser::Output_identifierContext::Output_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Output_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Output_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_identifier;
}


std::any VerilogParser::Output_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_identifierContext* VerilogParser::output_identifier() {
  Output_identifierContext *_localctx = _tracker.createInstance<Output_identifierContext>(_ctx, getState());
  enterRule(_localctx, 462, VerilogParser::RuleOutput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3403);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_valueContext ------------------------------------------------------------------

VerilogParser::Path_delay_valueContext::Path_delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::Path_delay_valueContext::list_of_path_delay_expressions() {
  return getRuleContext<VerilogParser::List_of_path_delay_expressionsContext>(0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Path_delay_valueContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_value;
}


std::any VerilogParser::Path_delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_valueContext* VerilogParser::path_delay_value() {
  Path_delay_valueContext *_localctx = _tracker.createInstance<Path_delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 464, VerilogParser::RulePath_delay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3410);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3405);
      list_of_path_delay_expressions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3406);
      match(VerilogParser::LP);
      setState(3407);
      list_of_path_delay_expressions();
      setState(3408);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_delay_expressionsContext ------------------------------------------------------------------

VerilogParser::List_of_path_delay_expressionsContext::List_of_path_delay_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t_path_delay_expression() {
  return getRuleContext<VerilogParser::T_path_delay_expressionContext>(0);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::trise_path_delay_expression() {
  return getRuleContext<VerilogParser::Trise_path_delay_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_delay_expressionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_delay_expressionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tfall_path_delay_expression() {
  return getRuleContext<VerilogParser::Tfall_path_delay_expressionContext>(0);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz_path_delay_expressionContext>(0);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t01_path_delay_expression() {
  return getRuleContext<VerilogParser::T01_path_delay_expressionContext>(0);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t10_path_delay_expression() {
  return getRuleContext<VerilogParser::T10_path_delay_expressionContext>(0);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0z_path_delay_expression() {
  return getRuleContext<VerilogParser::T0z_path_delay_expressionContext>(0);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz1_path_delay_expressionContext>(0);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1z_path_delay_expression() {
  return getRuleContext<VerilogParser::T1z_path_delay_expressionContext>(0);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz0_path_delay_expressionContext>(0);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0x_path_delay_expression() {
  return getRuleContext<VerilogParser::T0x_path_delay_expressionContext>(0);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx1_path_delay_expressionContext>(0);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1x_path_delay_expression() {
  return getRuleContext<VerilogParser::T1x_path_delay_expressionContext>(0);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx0_path_delay_expressionContext>(0);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::txz_path_delay_expression() {
  return getRuleContext<VerilogParser::Txz_path_delay_expressionContext>(0);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tzx_path_delay_expression() {
  return getRuleContext<VerilogParser::Tzx_path_delay_expressionContext>(0);
}


size_t VerilogParser::List_of_path_delay_expressionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_delay_expressions;
}


std::any VerilogParser::List_of_path_delay_expressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_delay_expressions(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::list_of_path_delay_expressions() {
  List_of_path_delay_expressionsContext *_localctx = _tracker.createInstance<List_of_path_delay_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 466, VerilogParser::RuleList_of_path_delay_expressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3446);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3412);
      t_path_delay_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3413);
      trise_path_delay_expression();
      setState(3414);
      match(VerilogParser::CO);
      setState(3415);
      tfall_path_delay_expression();
      setState(3418);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3416);
        match(VerilogParser::CO);
        setState(3417);
        tz_path_delay_expression();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3420);
      t01_path_delay_expression();
      setState(3421);
      match(VerilogParser::CO);
      setState(3422);
      t10_path_delay_expression();
      setState(3423);
      match(VerilogParser::CO);
      setState(3424);
      t0z_path_delay_expression();
      setState(3425);
      match(VerilogParser::CO);
      setState(3426);
      tz1_path_delay_expression();
      setState(3427);
      match(VerilogParser::CO);
      setState(3428);
      t1z_path_delay_expression();
      setState(3429);
      match(VerilogParser::CO);
      setState(3430);
      tz0_path_delay_expression();
      setState(3444);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3431);
        match(VerilogParser::CO);
        setState(3432);
        t0x_path_delay_expression();
        setState(3433);
        match(VerilogParser::CO);
        setState(3434);
        tx1_path_delay_expression();
        setState(3435);
        match(VerilogParser::CO);
        setState(3436);
        t1x_path_delay_expression();
        setState(3437);
        match(VerilogParser::CO);
        setState(3438);
        tx0_path_delay_expression();
        setState(3439);
        match(VerilogParser::CO);
        setState(3440);
        txz_path_delay_expression();
        setState(3441);
        match(VerilogParser::CO);
        setState(3442);
        tzx_path_delay_expression();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T_path_delay_expressionContext::T_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT_path_delay_expression;
}


std::any VerilogParser::T_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::t_path_delay_expression() {
  T_path_delay_expressionContext *_localctx = _tracker.createInstance<T_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 468, VerilogParser::RuleT_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3448);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trise_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Trise_path_delay_expressionContext::Trise_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Trise_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Trise_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTrise_path_delay_expression;
}


std::any VerilogParser::Trise_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTrise_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::trise_path_delay_expression() {
  Trise_path_delay_expressionContext *_localctx = _tracker.createInstance<Trise_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 470, VerilogParser::RuleTrise_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3450);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tfall_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tfall_path_delay_expressionContext::Tfall_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tfall_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tfall_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTfall_path_delay_expression;
}


std::any VerilogParser::Tfall_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTfall_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::tfall_path_delay_expression() {
  Tfall_path_delay_expressionContext *_localctx = _tracker.createInstance<Tfall_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 472, VerilogParser::RuleTfall_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3452);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz_path_delay_expressionContext::Tz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz_path_delay_expression;
}


std::any VerilogParser::Tz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::tz_path_delay_expression() {
  Tz_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 474, VerilogParser::RuleTz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3454);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T01_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T01_path_delay_expressionContext::T01_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T01_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T01_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT01_path_delay_expression;
}


std::any VerilogParser::T01_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT01_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::t01_path_delay_expression() {
  T01_path_delay_expressionContext *_localctx = _tracker.createInstance<T01_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 476, VerilogParser::RuleT01_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3456);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T10_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T10_path_delay_expressionContext::T10_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T10_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T10_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT10_path_delay_expression;
}


std::any VerilogParser::T10_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT10_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::t10_path_delay_expression() {
  T10_path_delay_expressionContext *_localctx = _tracker.createInstance<T10_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 478, VerilogParser::RuleT10_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3458);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0z_path_delay_expressionContext::T0z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0z_path_delay_expression;
}


std::any VerilogParser::T0z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::t0z_path_delay_expression() {
  T0z_path_delay_expressionContext *_localctx = _tracker.createInstance<T0z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 480, VerilogParser::RuleT0z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3460);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz1_path_delay_expressionContext::Tz1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz1_path_delay_expression;
}


std::any VerilogParser::Tz1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::tz1_path_delay_expression() {
  Tz1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 482, VerilogParser::RuleTz1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3462);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1z_path_delay_expressionContext::T1z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1z_path_delay_expression;
}


std::any VerilogParser::T1z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::t1z_path_delay_expression() {
  T1z_path_delay_expressionContext *_localctx = _tracker.createInstance<T1z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 484, VerilogParser::RuleT1z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3464);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz0_path_delay_expressionContext::Tz0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz0_path_delay_expression;
}


std::any VerilogParser::Tz0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::tz0_path_delay_expression() {
  Tz0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 486, VerilogParser::RuleTz0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3466);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0x_path_delay_expressionContext::T0x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0x_path_delay_expression;
}


std::any VerilogParser::T0x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::t0x_path_delay_expression() {
  T0x_path_delay_expressionContext *_localctx = _tracker.createInstance<T0x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 488, VerilogParser::RuleT0x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3468);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx1_path_delay_expressionContext::Tx1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx1_path_delay_expression;
}


std::any VerilogParser::Tx1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::tx1_path_delay_expression() {
  Tx1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 490, VerilogParser::RuleTx1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3470);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1x_path_delay_expressionContext::T1x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1x_path_delay_expression;
}


std::any VerilogParser::T1x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::t1x_path_delay_expression() {
  T1x_path_delay_expressionContext *_localctx = _tracker.createInstance<T1x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 492, VerilogParser::RuleT1x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3472);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx0_path_delay_expressionContext::Tx0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx0_path_delay_expression;
}


std::any VerilogParser::Tx0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::tx0_path_delay_expression() {
  Tx0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 494, VerilogParser::RuleTx0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3474);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Txz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Txz_path_delay_expressionContext::Txz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Txz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Txz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTxz_path_delay_expression;
}


std::any VerilogParser::Txz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTxz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::txz_path_delay_expression() {
  Txz_path_delay_expressionContext *_localctx = _tracker.createInstance<Txz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 496, VerilogParser::RuleTxz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3476);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tzx_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tzx_path_delay_expressionContext::Tzx_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tzx_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tzx_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTzx_path_delay_expression;
}


std::any VerilogParser::Tzx_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTzx_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::tzx_path_delay_expression() {
  Tzx_path_delay_expressionContext *_localctx = _tracker.createInstance<Tzx_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 498, VerilogParser::RuleTzx_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3478);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Path_delay_expressionContext::Path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Path_delay_expressionContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_expression;
}


std::any VerilogParser::Path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_expressionContext* VerilogParser::path_delay_expression() {
  Path_delay_expressionContext *_localctx = _tracker.createInstance<Path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 500, VerilogParser::RulePath_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3480);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_sensitive_path_declarationContext ------------------------------------------------------------------

VerilogParser::Edge_sensitive_path_declarationContext::Edge_sensitive_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::parallel_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Parallel_edge_sensitive_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Edge_sensitive_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Edge_sensitive_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::full_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Full_edge_sensitive_path_descriptionContext>(0);
}


size_t VerilogParser::Edge_sensitive_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_sensitive_path_declaration;
}


std::any VerilogParser::Edge_sensitive_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_sensitive_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::edge_sensitive_path_declaration() {
  Edge_sensitive_path_declarationContext *_localctx = _tracker.createInstance<Edge_sensitive_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 502, VerilogParser::RuleEdge_sensitive_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3490);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3482);
      parallel_edge_sensitive_path_description();
      setState(3483);
      match(VerilogParser::EQ);
      setState(3484);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3486);
      full_edge_sensitive_path_description();
      setState(3487);
      match(VerilogParser::EQ);
      setState(3488);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_edge_sensitive_path_descriptionContext::Parallel_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_edge_sensitive_path_description;
}


std::any VerilogParser::Parallel_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::parallel_edge_sensitive_path_description() {
  Parallel_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 504, VerilogParser::RuleParallel_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3492);
    match(VerilogParser::LP);
    setState(3494);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3493);
      edge_identifier();
    }
    setState(3496);
    specify_input_terminal_descriptor();
    setState(3497);
    match(VerilogParser::EQGT);
    setState(3498);
    match(VerilogParser::LP);
    setState(3499);
    specify_output_terminal_descriptor();
    setState(3501);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3500);
      polarity_operator();
    }
    setState(3503);
    match(VerilogParser::CL);
    setState(3504);
    data_source_expression();
    setState(3505);
    match(VerilogParser::RP);
    setState(3506);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_edge_sensitive_path_descriptionContext::Full_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_edge_sensitive_path_description;
}


std::any VerilogParser::Full_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::full_edge_sensitive_path_description() {
  Full_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Full_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 506, VerilogParser::RuleFull_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3508);
    match(VerilogParser::LP);
    setState(3510);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3509);
      edge_identifier();
    }
    setState(3512);
    list_of_path_inputs();
    setState(3513);
    match(VerilogParser::ASGT);
    setState(3514);
    match(VerilogParser::LP);
    setState(3515);
    list_of_path_outputs();
    setState(3517);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3516);
      polarity_operator();
    }
    setState(3519);
    match(VerilogParser::CL);
    setState(3520);
    data_source_expression();
    setState(3521);
    match(VerilogParser::RP);
    setState(3522);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_source_expressionContext ------------------------------------------------------------------

VerilogParser::Data_source_expressionContext::Data_source_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Data_source_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Data_source_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleData_source_expression;
}


std::any VerilogParser::Data_source_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_source_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_source_expressionContext* VerilogParser::data_source_expression() {
  Data_source_expressionContext *_localctx = _tracker.createInstance<Data_source_expressionContext>(_ctx, getState());
  enterRule(_localctx, 508, VerilogParser::RuleData_source_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3524);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_identifierContext ------------------------------------------------------------------

VerilogParser::Edge_identifierContext::Edge_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}


size_t VerilogParser::Edge_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_identifier;
}


std::any VerilogParser::Edge_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_identifierContext* VerilogParser::edge_identifier() {
  Edge_identifierContext *_localctx = _tracker.createInstance<Edge_identifierContext>(_ctx, getState());
  enterRule(_localctx, 510, VerilogParser::RuleEdge_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3526);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_dependent_path_declarationContext ------------------------------------------------------------------

VerilogParser::State_dependent_path_declarationContext::State_dependent_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::State_dependent_path_declarationContext::module_path_expression() {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IFNONE() {
  return getToken(VerilogParser::IFNONE, 0);
}


size_t VerilogParser::State_dependent_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleState_dependent_path_declaration;
}


std::any VerilogParser::State_dependent_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitState_dependent_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::state_dependent_path_declaration() {
  State_dependent_path_declarationContext *_localctx = _tracker.createInstance<State_dependent_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 512, VerilogParser::RuleState_dependent_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3542);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3528);
      match(VerilogParser::IF);
      setState(3529);
      match(VerilogParser::LP);
      setState(3530);
      module_path_expression(0);
      setState(3531);
      match(VerilogParser::RP);
      setState(3532);
      simple_path_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3534);
      match(VerilogParser::IF);
      setState(3535);
      match(VerilogParser::LP);
      setState(3536);
      module_path_expression(0);
      setState(3537);
      match(VerilogParser::RP);
      setState(3538);
      edge_sensitive_path_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3540);
      match(VerilogParser::IFNONE);
      setState(3541);
      simple_path_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Polarity_operatorContext ------------------------------------------------------------------

VerilogParser::Polarity_operatorContext::Polarity_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Polarity_operatorContext::getRuleIndex() const {
  return VerilogParser::RulePolarity_operator;
}


std::any VerilogParser::Polarity_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPolarity_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Polarity_operatorContext* VerilogParser::polarity_operator() {
  Polarity_operatorContext *_localctx = _tracker.createInstance<Polarity_operatorContext>(_ctx, getState());
  enterRule(_localctx, 514, VerilogParser::RulePolarity_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3544);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MI

    || _la == VerilogParser::PL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_timing_checkContext ------------------------------------------------------------------

VerilogParser::System_timing_checkContext::System_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Setup_timing_checkContext* VerilogParser::System_timing_checkContext::setup_timing_check() {
  return getRuleContext<VerilogParser::Setup_timing_checkContext>(0);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::System_timing_checkContext::hold_timing_check() {
  return getRuleContext<VerilogParser::Hold_timing_checkContext>(0);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::System_timing_checkContext::setuphold_timing_check() {
  return getRuleContext<VerilogParser::Setuphold_timing_checkContext>(0);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::System_timing_checkContext::recovery_timing_check() {
  return getRuleContext<VerilogParser::Recovery_timing_checkContext>(0);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::System_timing_checkContext::removal_timing_check() {
  return getRuleContext<VerilogParser::Removal_timing_checkContext>(0);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::System_timing_checkContext::recrem_timing_check() {
  return getRuleContext<VerilogParser::Recrem_timing_checkContext>(0);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::System_timing_checkContext::skew_timing_check() {
  return getRuleContext<VerilogParser::Skew_timing_checkContext>(0);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::System_timing_checkContext::timeskew_timing_check() {
  return getRuleContext<VerilogParser::Timeskew_timing_checkContext>(0);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::System_timing_checkContext::fullskew_timing_check() {
  return getRuleContext<VerilogParser::Fullskew_timing_checkContext>(0);
}

VerilogParser::Period_timing_checkContext* VerilogParser::System_timing_checkContext::period_timing_check() {
  return getRuleContext<VerilogParser::Period_timing_checkContext>(0);
}

VerilogParser::Width_timing_checkContext* VerilogParser::System_timing_checkContext::width_timing_check() {
  return getRuleContext<VerilogParser::Width_timing_checkContext>(0);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::System_timing_checkContext::nochange_timing_check() {
  return getRuleContext<VerilogParser::Nochange_timing_checkContext>(0);
}


size_t VerilogParser::System_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_timing_check;
}


std::any VerilogParser::System_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_timing_checkContext* VerilogParser::system_timing_check() {
  System_timing_checkContext *_localctx = _tracker.createInstance<System_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 516, VerilogParser::RuleSystem_timing_check);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3558);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::DLSETUP: {
        enterOuterAlt(_localctx, 1);
        setState(3546);
        setup_timing_check();
        break;
      }

      case VerilogParser::DLHOLD: {
        enterOuterAlt(_localctx, 2);
        setState(3547);
        hold_timing_check();
        break;
      }

      case VerilogParser::DLSETUPHOLD: {
        enterOuterAlt(_localctx, 3);
        setState(3548);
        setuphold_timing_check();
        break;
      }

      case VerilogParser::DLRECOVERY: {
        enterOuterAlt(_localctx, 4);
        setState(3549);
        recovery_timing_check();
        break;
      }

      case VerilogParser::DLREMOVAL: {
        enterOuterAlt(_localctx, 5);
        setState(3550);
        removal_timing_check();
        break;
      }

      case VerilogParser::DLRECREM: {
        enterOuterAlt(_localctx, 6);
        setState(3551);
        recrem_timing_check();
        break;
      }

      case VerilogParser::DLSKEW: {
        enterOuterAlt(_localctx, 7);
        setState(3552);
        skew_timing_check();
        break;
      }

      case VerilogParser::DLTIMESKEW: {
        enterOuterAlt(_localctx, 8);
        setState(3553);
        timeskew_timing_check();
        break;
      }

      case VerilogParser::DLFULLSKEW: {
        enterOuterAlt(_localctx, 9);
        setState(3554);
        fullskew_timing_check();
        break;
      }

      case VerilogParser::DLPERIOD: {
        enterOuterAlt(_localctx, 10);
        setState(3555);
        period_timing_check();
        break;
      }

      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 11);
        setState(3556);
        width_timing_check();
        break;
      }

      case VerilogParser::DLNOCHANGE: {
        enterOuterAlt(_localctx, 12);
        setState(3557);
        nochange_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setup_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setup_timing_checkContext::Setup_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::DLSETUP() {
  return getToken(VerilogParser::DLSETUP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Data_eventContext* VerilogParser::Setup_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setup_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Reference_eventContext* VerilogParser::Setup_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setup_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Setup_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Setup_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetup_timing_check;
}


std::any VerilogParser::Setup_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetup_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setup_timing_checkContext* VerilogParser::setup_timing_check() {
  Setup_timing_checkContext *_localctx = _tracker.createInstance<Setup_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 518, VerilogParser::RuleSetup_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3560);
    match(VerilogParser::DLSETUP);
    setState(3561);
    match(VerilogParser::LP);
    setState(3562);
    data_event();
    setState(3563);
    match(VerilogParser::CO);
    setState(3564);
    reference_event();
    setState(3565);
    match(VerilogParser::CO);
    setState(3566);
    timing_check_limit();
    setState(3568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3567);
      notifier_opt();
    }
    setState(3570);
    match(VerilogParser::RP);
    setState(3571);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Notifier_optContext ------------------------------------------------------------------

VerilogParser::Notifier_optContext::Notifier_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Notifier_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Notifier_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Notifier_optContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier_opt;
}


std::any VerilogParser::Notifier_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Notifier_optContext* VerilogParser::notifier_opt() {
  Notifier_optContext *_localctx = _tracker.createInstance<Notifier_optContext>(_ctx, getState());
  enterRule(_localctx, 520, VerilogParser::RuleNotifier_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3573);
    match(VerilogParser::CO);
    setState(3575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(3574);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Hold_timing_checkContext::Hold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::DLHOLD() {
  return getToken(VerilogParser::DLHOLD, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Hold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Hold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Hold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Hold_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Hold_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Hold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleHold_timing_check;
}


std::any VerilogParser::Hold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::hold_timing_check() {
  Hold_timing_checkContext *_localctx = _tracker.createInstance<Hold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 522, VerilogParser::RuleHold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3577);
    match(VerilogParser::DLHOLD);
    setState(3578);
    match(VerilogParser::LP);
    setState(3579);
    reference_event();
    setState(3580);
    match(VerilogParser::CO);
    setState(3581);
    data_event();
    setState(3582);
    match(VerilogParser::CO);
    setState(3583);
    timing_check_limit();
    setState(3585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3584);
      notifier_opt();
    }
    setState(3587);
    match(VerilogParser::RP);
    setState(3588);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setuphold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setuphold_timing_checkContext::Setuphold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::DLSETUPHOLD() {
  return getToken(VerilogParser::DLSETUPHOLD, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Setuphold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setuphold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Setuphold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Setuphold_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setuphold_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Setuphold_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Setuphold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetuphold_timing_check;
}


std::any VerilogParser::Setuphold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetuphold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::setuphold_timing_check() {
  Setuphold_timing_checkContext *_localctx = _tracker.createInstance<Setuphold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 524, VerilogParser::RuleSetuphold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3590);
    match(VerilogParser::DLSETUPHOLD);
    setState(3591);
    match(VerilogParser::LP);
    setState(3592);
    reference_event();
    setState(3593);
    match(VerilogParser::CO);
    setState(3594);
    data_event();
    setState(3595);
    match(VerilogParser::CO);
    setState(3596);
    timing_check_limit();
    setState(3597);
    match(VerilogParser::CO);
    setState(3598);
    timing_check_limit();
    setState(3600);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3599);
      timing_check_opt();
    }
    setState(3602);
    match(VerilogParser::RP);
    setState(3603);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_optContext ------------------------------------------------------------------

VerilogParser::Timing_check_optContext::Timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::Timing_check_optContext::stamptime_cond_opt() {
  return getRuleContext<VerilogParser::Stamptime_cond_optContext>(0);
}


size_t VerilogParser::Timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_opt;
}


std::any VerilogParser::Timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_optContext* VerilogParser::timing_check_opt() {
  Timing_check_optContext *_localctx = _tracker.createInstance<Timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 526, VerilogParser::RuleTiming_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3605);
    match(VerilogParser::CO);
    setState(3607);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(3606);
      notifier();
    }
    setState(3610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3609);
      stamptime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_cond_optContext ------------------------------------------------------------------

VerilogParser::Stamptime_cond_optContext::Stamptime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Stamptime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::Stamptime_cond_optContext::stamptime_condition() {
  return getRuleContext<VerilogParser::Stamptime_conditionContext>(0);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::Stamptime_cond_optContext::checktime_cond_opt() {
  return getRuleContext<VerilogParser::Checktime_cond_optContext>(0);
}


size_t VerilogParser::Stamptime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_cond_opt;
}


std::any VerilogParser::Stamptime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::stamptime_cond_opt() {
  Stamptime_cond_optContext *_localctx = _tracker.createInstance<Stamptime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 528, VerilogParser::RuleStamptime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3612);
    match(VerilogParser::CO);
    setState(3614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(3613);
      stamptime_condition();
    }
    setState(3617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3616);
      checktime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_cond_optContext ------------------------------------------------------------------

VerilogParser::Checktime_cond_optContext::Checktime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Checktime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Checktime_conditionContext* VerilogParser::Checktime_cond_optContext::checktime_condition() {
  return getRuleContext<VerilogParser::Checktime_conditionContext>(0);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::Checktime_cond_optContext::delayed_ref_opt() {
  return getRuleContext<VerilogParser::Delayed_ref_optContext>(0);
}


size_t VerilogParser::Checktime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_cond_opt;
}


std::any VerilogParser::Checktime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::checktime_cond_opt() {
  Checktime_cond_optContext *_localctx = _tracker.createInstance<Checktime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 530, VerilogParser::RuleChecktime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3619);
    match(VerilogParser::CO);
    setState(3621);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(3620);
      checktime_condition();
    }
    setState(3624);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3623);
      delayed_ref_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_ref_optContext ------------------------------------------------------------------

VerilogParser::Delayed_ref_optContext::Delayed_ref_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_ref_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_referenceContext* VerilogParser::Delayed_ref_optContext::delayed_reference() {
  return getRuleContext<VerilogParser::Delayed_referenceContext>(0);
}

VerilogParser::Delayed_data_optContext* VerilogParser::Delayed_ref_optContext::delayed_data_opt() {
  return getRuleContext<VerilogParser::Delayed_data_optContext>(0);
}


size_t VerilogParser::Delayed_ref_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_ref_opt;
}


std::any VerilogParser::Delayed_ref_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_ref_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::delayed_ref_opt() {
  Delayed_ref_optContext *_localctx = _tracker.createInstance<Delayed_ref_optContext>(_ctx, getState());
  enterRule(_localctx, 532, VerilogParser::RuleDelayed_ref_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3626);
    match(VerilogParser::CO);
    setState(3628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(3627);
      delayed_reference();
    }
    setState(3631);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3630);
      delayed_data_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_data_optContext ------------------------------------------------------------------

VerilogParser::Delayed_data_optContext::Delayed_data_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_data_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_dataContext* VerilogParser::Delayed_data_optContext::delayed_data() {
  return getRuleContext<VerilogParser::Delayed_dataContext>(0);
}


size_t VerilogParser::Delayed_data_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data_opt;
}


std::any VerilogParser::Delayed_data_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_data_optContext* VerilogParser::delayed_data_opt() {
  Delayed_data_optContext *_localctx = _tracker.createInstance<Delayed_data_optContext>(_ctx, getState());
  enterRule(_localctx, 534, VerilogParser::RuleDelayed_data_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3633);
    match(VerilogParser::CO);
    setState(3635);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(3634);
      delayed_data();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recovery_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recovery_timing_checkContext::Recovery_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::DLRECOVERY() {
  return getToken(VerilogParser::DLRECOVERY, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recovery_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recovery_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recovery_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recovery_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Recovery_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Recovery_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecovery_timing_check;
}


std::any VerilogParser::Recovery_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecovery_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::recovery_timing_check() {
  Recovery_timing_checkContext *_localctx = _tracker.createInstance<Recovery_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 536, VerilogParser::RuleRecovery_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3637);
    match(VerilogParser::DLRECOVERY);
    setState(3638);
    match(VerilogParser::LP);
    setState(3639);
    reference_event();
    setState(3640);
    match(VerilogParser::CO);
    setState(3641);
    data_event();
    setState(3642);
    match(VerilogParser::CO);
    setState(3643);
    timing_check_limit();
    setState(3645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3644);
      notifier_opt();
    }
    setState(3647);
    match(VerilogParser::RP);
    setState(3648);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Removal_timing_checkContext ------------------------------------------------------------------

VerilogParser::Removal_timing_checkContext::Removal_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::DLREMOVAL() {
  return getToken(VerilogParser::DLREMOVAL, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Removal_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Removal_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Removal_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Removal_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Removal_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Removal_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRemoval_timing_check;
}


std::any VerilogParser::Removal_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemoval_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::removal_timing_check() {
  Removal_timing_checkContext *_localctx = _tracker.createInstance<Removal_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 538, VerilogParser::RuleRemoval_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3650);
    match(VerilogParser::DLREMOVAL);
    setState(3651);
    match(VerilogParser::LP);
    setState(3652);
    reference_event();
    setState(3653);
    match(VerilogParser::CO);
    setState(3654);
    data_event();
    setState(3655);
    match(VerilogParser::CO);
    setState(3656);
    timing_check_limit();
    setState(3658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3657);
      notifier_opt();
    }
    setState(3660);
    match(VerilogParser::RP);
    setState(3661);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recrem_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recrem_timing_checkContext::Recrem_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::DLRECREM() {
  return getToken(VerilogParser::DLRECREM, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recrem_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recrem_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recrem_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Recrem_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recrem_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Recrem_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Recrem_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecrem_timing_check;
}


std::any VerilogParser::Recrem_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecrem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::recrem_timing_check() {
  Recrem_timing_checkContext *_localctx = _tracker.createInstance<Recrem_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 540, VerilogParser::RuleRecrem_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3663);
    match(VerilogParser::DLRECREM);
    setState(3664);
    match(VerilogParser::LP);
    setState(3665);
    reference_event();
    setState(3666);
    match(VerilogParser::CO);
    setState(3667);
    data_event();
    setState(3668);
    match(VerilogParser::CO);
    setState(3669);
    timing_check_limit();
    setState(3670);
    match(VerilogParser::CO);
    setState(3671);
    timing_check_limit();
    setState(3673);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3672);
      timing_check_opt();
    }
    setState(3675);
    match(VerilogParser::RP);
    setState(3676);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Skew_timing_checkContext::Skew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::DLSKEW() {
  return getToken(VerilogParser::DLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Skew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Skew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Skew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Skew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Skew_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Skew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check;
}


std::any VerilogParser::Skew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::skew_timing_check() {
  Skew_timing_checkContext *_localctx = _tracker.createInstance<Skew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 542, VerilogParser::RuleSkew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3678);
    match(VerilogParser::DLSKEW);
    setState(3679);
    match(VerilogParser::LP);
    setState(3680);
    reference_event();
    setState(3681);
    match(VerilogParser::CO);
    setState(3682);
    data_event();
    setState(3683);
    match(VerilogParser::CO);
    setState(3684);
    timing_check_limit();
    setState(3686);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3685);
      notifier_opt();
    }
    setState(3688);
    match(VerilogParser::RP);
    setState(3689);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timeskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Timeskew_timing_checkContext::Timeskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::DLTIMESKEW() {
  return getToken(VerilogParser::DLTIMESKEW, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Timeskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Timeskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Timeskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Timeskew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Timeskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Timeskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleTimeskew_timing_check;
}


std::any VerilogParser::Timeskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTimeskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::timeskew_timing_check() {
  Timeskew_timing_checkContext *_localctx = _tracker.createInstance<Timeskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 544, VerilogParser::RuleTimeskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3691);
    match(VerilogParser::DLTIMESKEW);
    setState(3692);
    match(VerilogParser::LP);
    setState(3693);
    reference_event();
    setState(3694);
    match(VerilogParser::CO);
    setState(3695);
    data_event();
    setState(3696);
    match(VerilogParser::CO);
    setState(3697);
    timing_check_limit();
    setState(3699);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3698);
      skew_timing_check_opt();
    }
    setState(3701);
    match(VerilogParser::RP);
    setState(3702);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_check_optContext ------------------------------------------------------------------

VerilogParser::Skew_timing_check_optContext::Skew_timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Skew_timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::Skew_timing_check_optContext::event_based_flag_opt() {
  return getRuleContext<VerilogParser::Event_based_flag_optContext>(0);
}


size_t VerilogParser::Skew_timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check_opt;
}


std::any VerilogParser::Skew_timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::skew_timing_check_opt() {
  Skew_timing_check_optContext *_localctx = _tracker.createInstance<Skew_timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 546, VerilogParser::RuleSkew_timing_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3704);
    match(VerilogParser::CO);
    setState(3706);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 210) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 210)) & 36028797018964033) != 0)) {
      setState(3705);
      notifier();
    }
    setState(3709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3708);
      event_based_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flag_optContext ------------------------------------------------------------------

VerilogParser::Event_based_flag_optContext::Event_based_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_based_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Event_based_flagContext* VerilogParser::Event_based_flag_optContext::event_based_flag() {
  return getRuleContext<VerilogParser::Event_based_flagContext>(0);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::Event_based_flag_optContext::remain_active_flag_opt() {
  return getRuleContext<VerilogParser::Remain_active_flag_optContext>(0);
}


size_t VerilogParser::Event_based_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag_opt;
}


std::any VerilogParser::Event_based_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::event_based_flag_opt() {
  Event_based_flag_optContext *_localctx = _tracker.createInstance<Event_based_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 548, VerilogParser::RuleEvent_based_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3711);
    match(VerilogParser::CO);
    setState(3713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(3712);
      event_based_flag();
    }
    setState(3716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3715);
      remain_active_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flag_optContext ------------------------------------------------------------------

VerilogParser::Remain_active_flag_optContext::Remain_active_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Remain_active_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Remain_active_flagContext* VerilogParser::Remain_active_flag_optContext::remain_active_flag() {
  return getRuleContext<VerilogParser::Remain_active_flagContext>(0);
}


size_t VerilogParser::Remain_active_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag_opt;
}


std::any VerilogParser::Remain_active_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::remain_active_flag_opt() {
  Remain_active_flag_optContext *_localctx = _tracker.createInstance<Remain_active_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 550, VerilogParser::RuleRemain_active_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3718);
    match(VerilogParser::CO);
    setState(3720);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 8935457564403425) != 0) || _la == VerilogParser::IDENTIFIER) {
      setState(3719);
      remain_active_flag();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Fullskew_timing_checkContext::Fullskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::DLFULLSKEW() {
  return getToken(VerilogParser::DLFULLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Fullskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Fullskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Fullskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Fullskew_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Fullskew_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Fullskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Fullskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleFullskew_timing_check;
}


std::any VerilogParser::Fullskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFullskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::fullskew_timing_check() {
  Fullskew_timing_checkContext *_localctx = _tracker.createInstance<Fullskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 552, VerilogParser::RuleFullskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3722);
    match(VerilogParser::DLFULLSKEW);
    setState(3723);
    match(VerilogParser::LP);
    setState(3724);
    reference_event();
    setState(3725);
    match(VerilogParser::CO);
    setState(3726);
    data_event();
    setState(3727);
    match(VerilogParser::CO);
    setState(3728);
    timing_check_limit();
    setState(3729);
    match(VerilogParser::CO);
    setState(3730);
    timing_check_limit();
    setState(3732);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3731);
      skew_timing_check_opt();
    }
    setState(3734);
    match(VerilogParser::RP);
    setState(3735);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Period_timing_checkContext ------------------------------------------------------------------

VerilogParser::Period_timing_checkContext::Period_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::DLPERIOD() {
  return getToken(VerilogParser::DLPERIOD, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Period_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Period_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Period_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Period_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RulePeriod_timing_check;
}


std::any VerilogParser::Period_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPeriod_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Period_timing_checkContext* VerilogParser::period_timing_check() {
  Period_timing_checkContext *_localctx = _tracker.createInstance<Period_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 554, VerilogParser::RulePeriod_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3737);
    match(VerilogParser::DLPERIOD);
    setState(3738);
    match(VerilogParser::LP);
    setState(3739);
    controlled_reference_event();
    setState(3740);
    match(VerilogParser::CO);
    setState(3741);
    timing_check_limit();
    setState(3743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3742);
      notifier_opt();
    }
    setState(3745);
    match(VerilogParser::RP);
    setState(3746);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_timing_checkContext ------------------------------------------------------------------

VerilogParser::Width_timing_checkContext::Width_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::DLWIDTH() {
  return getToken(VerilogParser::DLWIDTH, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Width_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Width_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Threshold_optContext* VerilogParser::Width_timing_checkContext::threshold_opt() {
  return getRuleContext<VerilogParser::Threshold_optContext>(0);
}


size_t VerilogParser::Width_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_timing_check;
}


std::any VerilogParser::Width_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_timing_checkContext* VerilogParser::width_timing_check() {
  Width_timing_checkContext *_localctx = _tracker.createInstance<Width_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 556, VerilogParser::RuleWidth_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3748);
    match(VerilogParser::DLWIDTH);
    setState(3749);
    match(VerilogParser::LP);
    setState(3750);
    controlled_reference_event();
    setState(3751);
    match(VerilogParser::CO);
    setState(3752);
    timing_check_limit();
    setState(3754);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3753);
      threshold_opt();
    }
    setState(3756);
    match(VerilogParser::RP);
    setState(3757);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Threshold_optContext ------------------------------------------------------------------

VerilogParser::Threshold_optContext::Threshold_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Threshold_optContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Threshold_optContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::ThresholdContext* VerilogParser::Threshold_optContext::threshold() {
  return getRuleContext<VerilogParser::ThresholdContext>(0);
}

VerilogParser::NotifierContext* VerilogParser::Threshold_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Threshold_optContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold_opt;
}


std::any VerilogParser::Threshold_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Threshold_optContext* VerilogParser::threshold_opt() {
  Threshold_optContext *_localctx = _tracker.createInstance<Threshold_optContext>(_ctx, getState());
  enterRule(_localctx, 558, VerilogParser::RuleThreshold_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3759);
    match(VerilogParser::CO);
    setState(3760);
    threshold();
    setState(3763);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3761);
      match(VerilogParser::CO);
      setState(3762);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nochange_timing_checkContext ------------------------------------------------------------------

VerilogParser::Nochange_timing_checkContext::Nochange_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::DLNOCHANGE() {
  return getToken(VerilogParser::DLNOCHANGE, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Nochange_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Nochange_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Nochange_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::start_edge_offset() {
  return getRuleContext<VerilogParser::Start_edge_offsetContext>(0);
}

VerilogParser::End_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::end_edge_offset() {
  return getRuleContext<VerilogParser::End_edge_offsetContext>(0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Nochange_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Nochange_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleNochange_timing_check;
}


std::any VerilogParser::Nochange_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNochange_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::nochange_timing_check() {
  Nochange_timing_checkContext *_localctx = _tracker.createInstance<Nochange_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 560, VerilogParser::RuleNochange_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3765);
    match(VerilogParser::DLNOCHANGE);
    setState(3766);
    match(VerilogParser::LP);
    setState(3767);
    reference_event();
    setState(3768);
    match(VerilogParser::CO);
    setState(3769);
    data_event();
    setState(3770);
    match(VerilogParser::CO);
    setState(3771);
    start_edge_offset();
    setState(3772);
    match(VerilogParser::CO);
    setState(3773);
    end_edge_offset();
    setState(3775);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3774);
      notifier_opt();
    }
    setState(3777);
    match(VerilogParser::RP);
    setState(3778);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_conditionContext ------------------------------------------------------------------

VerilogParser::Checktime_conditionContext::Checktime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Checktime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Checktime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_condition;
}


std::any VerilogParser::Checktime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_conditionContext* VerilogParser::checktime_condition() {
  Checktime_conditionContext *_localctx = _tracker.createInstance<Checktime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 562, VerilogParser::RuleChecktime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3780);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_reference_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_reference_eventContext::Controlled_reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::Controlled_reference_eventContext::controlled_timing_check_event() {
  return getRuleContext<VerilogParser::Controlled_timing_check_eventContext>(0);
}


size_t VerilogParser::Controlled_reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_reference_event;
}


std::any VerilogParser::Controlled_reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_reference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::controlled_reference_event() {
  Controlled_reference_eventContext *_localctx = _tracker.createInstance<Controlled_reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 564, VerilogParser::RuleControlled_reference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3782);
    controlled_timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_eventContext ------------------------------------------------------------------

VerilogParser::Data_eventContext::Data_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Data_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Data_eventContext::getRuleIndex() const {
  return VerilogParser::RuleData_event;
}


std::any VerilogParser::Data_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_eventContext* VerilogParser::data_event() {
  Data_eventContext *_localctx = _tracker.createInstance<Data_eventContext>(_ctx, getState());
  enterRule(_localctx, 566, VerilogParser::RuleData_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3784);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_dataContext ------------------------------------------------------------------

VerilogParser::Delayed_dataContext::Delayed_dataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_dataContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_dataContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_dataContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data;
}


std::any VerilogParser::Delayed_dataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_dataContext* VerilogParser::delayed_data() {
  Delayed_dataContext *_localctx = _tracker.createInstance<Delayed_dataContext>(_ctx, getState());
  enterRule(_localctx, 568, VerilogParser::RuleDelayed_data);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3786);
    terminal_identifier();
    setState(3791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3787);
      match(VerilogParser::LB);
      setState(3788);
      constant_mintypmax_expression();
      setState(3789);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_referenceContext ------------------------------------------------------------------

VerilogParser::Delayed_referenceContext::Delayed_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_referenceContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_referenceContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_referenceContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_reference;
}


std::any VerilogParser::Delayed_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_referenceContext* VerilogParser::delayed_reference() {
  Delayed_referenceContext *_localctx = _tracker.createInstance<Delayed_referenceContext>(_ctx, getState());
  enterRule(_localctx, 570, VerilogParser::RuleDelayed_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3793);
    terminal_identifier();
    setState(3798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3794);
      match(VerilogParser::LB);
      setState(3795);
      constant_mintypmax_expression();
      setState(3796);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_edge_offsetContext ------------------------------------------------------------------

VerilogParser::End_edge_offsetContext::End_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::End_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::End_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleEnd_edge_offset;
}


std::any VerilogParser::End_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnd_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::End_edge_offsetContext* VerilogParser::end_edge_offset() {
  End_edge_offsetContext *_localctx = _tracker.createInstance<End_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 572, VerilogParser::RuleEnd_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3800);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flagContext ------------------------------------------------------------------

VerilogParser::Event_based_flagContext::Event_based_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Event_based_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Event_based_flagContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag;
}


std::any VerilogParser::Event_based_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flagContext* VerilogParser::event_based_flag() {
  Event_based_flagContext *_localctx = _tracker.createInstance<Event_based_flagContext>(_ctx, getState());
  enterRule(_localctx, 574, VerilogParser::RuleEvent_based_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3802);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotifierContext ------------------------------------------------------------------

VerilogParser::NotifierContext::NotifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::NotifierContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}


size_t VerilogParser::NotifierContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier;
}


std::any VerilogParser::NotifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NotifierContext* VerilogParser::notifier() {
  NotifierContext *_localctx = _tracker.createInstance<NotifierContext>(_ctx, getState());
  enterRule(_localctx, 576, VerilogParser::RuleNotifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3804);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reference_eventContext ------------------------------------------------------------------

VerilogParser::Reference_eventContext::Reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Reference_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleReference_event;
}


std::any VerilogParser::Reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reference_eventContext* VerilogParser::reference_event() {
  Reference_eventContext *_localctx = _tracker.createInstance<Reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 578, VerilogParser::RuleReference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3806);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flagContext ------------------------------------------------------------------

VerilogParser::Remain_active_flagContext::Remain_active_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Remain_active_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Remain_active_flagContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag;
}


std::any VerilogParser::Remain_active_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flagContext* VerilogParser::remain_active_flag() {
  Remain_active_flagContext *_localctx = _tracker.createInstance<Remain_active_flagContext>(_ctx, getState());
  enterRule(_localctx, 580, VerilogParser::RuleRemain_active_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3808);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_conditionContext ------------------------------------------------------------------

VerilogParser::Stamptime_conditionContext::Stamptime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Stamptime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Stamptime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_condition;
}


std::any VerilogParser::Stamptime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::stamptime_condition() {
  Stamptime_conditionContext *_localctx = _tracker.createInstance<Stamptime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 582, VerilogParser::RuleStamptime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3810);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_edge_offsetContext ------------------------------------------------------------------

VerilogParser::Start_edge_offsetContext::Start_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Start_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Start_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleStart_edge_offset;
}


std::any VerilogParser::Start_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStart_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::start_edge_offset() {
  Start_edge_offsetContext *_localctx = _tracker.createInstance<Start_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 584, VerilogParser::RuleStart_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3812);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThresholdContext ------------------------------------------------------------------

VerilogParser::ThresholdContext::ThresholdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::ThresholdContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::ThresholdContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold;
}


std::any VerilogParser::ThresholdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ThresholdContext* VerilogParser::threshold() {
  ThresholdContext *_localctx = _tracker.createInstance<ThresholdContext>(_ctx, getState());
  enterRule(_localctx, 586, VerilogParser::RuleThreshold);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3814);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_limitContext ------------------------------------------------------------------

VerilogParser::Timing_check_limitContext::Timing_check_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Timing_check_limitContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Timing_check_limitContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_limit;
}


std::any VerilogParser::Timing_check_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_limit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_limitContext* VerilogParser::timing_check_limit() {
  Timing_check_limitContext *_localctx = _tracker.createInstance<Timing_check_limitContext>(_ctx, getState());
  enterRule(_localctx, 588, VerilogParser::RuleTiming_check_limit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3816);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Timing_check_eventContext::Timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event;
}


std::any VerilogParser::Timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_eventContext* VerilogParser::timing_check_event() {
  Timing_check_eventContext *_localctx = _tracker.createInstance<Timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 590, VerilogParser::RuleTiming_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3819);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 4504699138998273) != 0)) {
      setState(3818);
      timing_check_event_control();
    }
    setState(3821);
    specify_terminal_descriptor();
    setState(3824);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3822);
      match(VerilogParser::AMAMAM);
      setState(3823);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_timing_check_eventContext::Controlled_timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Controlled_timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Controlled_timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Controlled_timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_timing_check_event;
}


std::any VerilogParser::Controlled_timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_timing_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::controlled_timing_check_event() {
  Controlled_timing_check_eventContext *_localctx = _tracker.createInstance<Controlled_timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 592, VerilogParser::RuleControlled_timing_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3826);
    timing_check_event_control();
    setState(3827);
    specify_terminal_descriptor();
    setState(3830);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3828);
      match(VerilogParser::AMAMAM);
      setState(3829);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_event_controlContext ------------------------------------------------------------------

VerilogParser::Timing_check_event_controlContext::Timing_check_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::Timing_check_event_controlContext::edge_control_specifier() {
  return getRuleContext<VerilogParser::Edge_control_specifierContext>(0);
}


size_t VerilogParser::Timing_check_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event_control;
}


std::any VerilogParser::Timing_check_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::timing_check_event_control() {
  Timing_check_event_controlContext *_localctx = _tracker.createInstance<Timing_check_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 594, VerilogParser::RuleTiming_check_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3835);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::POSEDGE: {
        enterOuterAlt(_localctx, 1);
        setState(3832);
        match(VerilogParser::POSEDGE);
        break;
      }

      case VerilogParser::NEGEDGE: {
        enterOuterAlt(_localctx, 2);
        setState(3833);
        match(VerilogParser::NEGEDGE);
        break;
      }

      case VerilogParser::EDGE: {
        enterOuterAlt(_localctx, 3);
        setState(3834);
        edge_control_specifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_terminal_descriptorContext::Specify_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Specify_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_terminal_descriptor;
}


std::any VerilogParser::Specify_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::specify_terminal_descriptor() {
  Specify_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 596, VerilogParser::RuleSpecify_terminal_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3839);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3837);
      specify_input_terminal_descriptor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3838);
      specify_output_terminal_descriptor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_control_specifierContext ------------------------------------------------------------------

VerilogParser::Edge_control_specifierContext::Edge_control_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::EDGE() {
  return getToken(VerilogParser::EDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Edge_descriptorContext *> VerilogParser::Edge_control_specifierContext::edge_descriptor() {
  return getRuleContexts<VerilogParser::Edge_descriptorContext>();
}

VerilogParser::Edge_descriptorContext* VerilogParser::Edge_control_specifierContext::edge_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Edge_descriptorContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Edge_control_specifierContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Edge_control_specifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_control_specifier;
}


std::any VerilogParser::Edge_control_specifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_control_specifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::edge_control_specifier() {
  Edge_control_specifierContext *_localctx = _tracker.createInstance<Edge_control_specifierContext>(_ctx, getState());
  enterRule(_localctx, 598, VerilogParser::RuleEdge_control_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3841);
    match(VerilogParser::EDGE);
    setState(3842);
    match(VerilogParser::LB);
    setState(3843);
    edge_descriptor();
    setState(3848);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3844);
      match(VerilogParser::CO);
      setState(3845);
      edge_descriptor();
      setState(3850);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3851);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_descriptorContext ------------------------------------------------------------------

VerilogParser::Edge_descriptorContext::Edge_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_descriptorContext::EDGE_DESCRIPTOR() {
  return getToken(VerilogParser::EDGE_DESCRIPTOR, 0);
}


size_t VerilogParser::Edge_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_descriptor;
}


std::any VerilogParser::Edge_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_descriptorContext* VerilogParser::edge_descriptor() {
  Edge_descriptorContext *_localctx = _tracker.createInstance<Edge_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 600, VerilogParser::RuleEdge_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3853);
    match(VerilogParser::EDGE_DESCRIPTOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Timing_check_conditionContext::Timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::Timing_check_conditionContext::scalar_timing_check_condition() {
  return getRuleContext<VerilogParser::Scalar_timing_check_conditionContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_condition;
}


std::any VerilogParser::Timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::timing_check_condition() {
  Timing_check_conditionContext *_localctx = _tracker.createInstance<Timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 602, VerilogParser::RuleTiming_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3860);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3855);
      scalar_timing_check_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3856);
      match(VerilogParser::LP);
      setState(3857);
      scalar_timing_check_condition();
      setState(3858);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Scalar_timing_check_conditionContext::Scalar_timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Scalar_timing_check_conditionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

VerilogParser::Scalar_constantContext* VerilogParser::Scalar_timing_check_conditionContext::scalar_constant() {
  return getRuleContext<VerilogParser::Scalar_constantContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}


size_t VerilogParser::Scalar_timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_timing_check_condition;
}


std::any VerilogParser::Scalar_timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_timing_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::scalar_timing_check_condition() {
  Scalar_timing_check_conditionContext *_localctx = _tracker.createInstance<Scalar_timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 604, VerilogParser::RuleScalar_timing_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3881);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3862);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3863);
      match(VerilogParser::TI);
      setState(3864);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3865);
      expression(0);
      setState(3866);
      match(VerilogParser::EQEQ);
      setState(3867);
      scalar_constant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3869);
      expression(0);
      setState(3870);
      match(VerilogParser::EQEQEQ);
      setState(3871);
      scalar_constant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3873);
      expression(0);
      setState(3874);
      match(VerilogParser::EMEQ);
      setState(3875);
      scalar_constant();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3877);
      expression(0);
      setState(3878);
      match(VerilogParser::EMEQEQ);
      setState(3879);
      scalar_constant();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_constantContext ------------------------------------------------------------------

VerilogParser::Scalar_constantContext::Scalar_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Scalar_constantContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Scalar_constantContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Scalar_constantContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_constant;
}


std::any VerilogParser::Scalar_constantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_constant(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_constantContext* VerilogParser::scalar_constant() {
  Scalar_constantContext *_localctx = _tracker.createInstance<Scalar_constantContext>(_ctx, getState());
  enterRule(_localctx, 606, VerilogParser::RuleScalar_constant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3883);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3884);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcatenationContext ------------------------------------------------------------------

VerilogParser::ConcatenationContext::ConcatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::ConcatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ConcatenationContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ConcatenationContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::ConcatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::ConcatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConcatenation;
}


std::any VerilogParser::ConcatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConcatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ConcatenationContext* VerilogParser::concatenation() {
  ConcatenationContext *_localctx = _tracker.createInstance<ConcatenationContext>(_ctx, getState());
  enterRule(_localctx, 608, VerilogParser::RuleConcatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3887);
    match(VerilogParser::LC);
    setState(3888);
    expression(0);
    setState(3893);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3889);
      match(VerilogParser::CO);
      setState(3890);
      expression(0);
      setState(3895);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3896);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_concatenationContext::Constant_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_concatenationContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_concatenationContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_concatenation;
}


std::any VerilogParser::Constant_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_concatenationContext* VerilogParser::constant_concatenation() {
  Constant_concatenationContext *_localctx = _tracker.createInstance<Constant_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 610, VerilogParser::RuleConstant_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3898);
    match(VerilogParser::LC);
    setState(3899);
    constant_expression(0);
    setState(3904);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3900);
      match(VerilogParser::CO);
      setState(3901);
      constant_expression(0);
      setState(3906);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3907);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_multiple_concatenationContext::Constant_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_multiple_concatenationContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Constant_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_multiple_concatenation;
}


std::any VerilogParser::Constant_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::constant_multiple_concatenation() {
  Constant_multiple_concatenationContext *_localctx = _tracker.createInstance<Constant_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 612, VerilogParser::RuleConstant_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3909);
    match(VerilogParser::LC);
    setState(3910);
    constant_expression(0);
    setState(3911);
    constant_concatenation();
    setState(3912);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_concatenationContext::Module_path_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_concatenationContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_concatenationContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_path_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_concatenation;
}


std::any VerilogParser::Module_path_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::module_path_concatenation() {
  Module_path_concatenationContext *_localctx = _tracker.createInstance<Module_path_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 614, VerilogParser::RuleModule_path_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3914);
    match(VerilogParser::LC);
    setState(3915);
    module_path_expression(0);
    setState(3920);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3916);
      match(VerilogParser::CO);
      setState(3917);
      module_path_expression(0);
      setState(3922);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3923);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_multiple_concatenationContext::Module_path_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Module_path_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_multiple_concatenationContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Module_path_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_multiple_concatenation;
}


std::any VerilogParser::Module_path_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::module_path_multiple_concatenation() {
  Module_path_multiple_concatenationContext *_localctx = _tracker.createInstance<Module_path_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 616, VerilogParser::RuleModule_path_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3925);
    match(VerilogParser::LC);
    setState(3926);
    constant_expression(0);
    setState(3927);
    module_path_concatenation();
    setState(3928);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Multiple_concatenationContext::Multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::Multiple_concatenationContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleMultiple_concatenation;
}


std::any VerilogParser::Multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMultiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::multiple_concatenation() {
  Multiple_concatenationContext *_localctx = _tracker.createInstance<Multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 618, VerilogParser::RuleMultiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3930);
    match(VerilogParser::LC);
    setState(3931);
    constant_expression(0);
    setState(3932);
    concatenation();
    setState(3933);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_function_callContext::Constant_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Function_identifierContext* VerilogParser::Constant_function_callContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_function_call;
}


std::any VerilogParser::Constant_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_function_callContext* VerilogParser::constant_function_call() {
  Constant_function_callContext *_localctx = _tracker.createInstance<Constant_function_callContext>(_ctx, getState());
  enterRule(_localctx, 620, VerilogParser::RuleConstant_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3935);
    function_identifier();
    setState(3939);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3936);
        attribute_instance(); 
      }
      setState(3941);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx);
    }
    setState(3942);
    match(VerilogParser::LP);
    setState(3943);
    constant_expression(0);
    setState(3948);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3944);
      match(VerilogParser::CO);
      setState(3945);
      constant_expression(0);
      setState(3950);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3951);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_system_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_system_function_callContext::Constant_system_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::Constant_system_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_system_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_system_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_system_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_system_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_system_function_call;
}


std::any VerilogParser::Constant_system_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_system_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::constant_system_function_call() {
  Constant_system_function_callContext *_localctx = _tracker.createInstance<Constant_system_function_callContext>(_ctx, getState());
  enterRule(_localctx, 622, VerilogParser::RuleConstant_system_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3953);
    system_function_identifier();
    setState(3954);
    match(VerilogParser::LP);
    setState(3955);
    constant_expression(0);
    setState(3960);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3956);
      match(VerilogParser::CO);
      setState(3957);
      constant_expression(0);
      setState(3962);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3963);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

VerilogParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Function_callContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Function_callContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Function_callContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_callContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_call;
}


std::any VerilogParser::Function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_callContext* VerilogParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 624, VerilogParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3965);
    hierarchical_identifier();
    setState(3969);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3966);
        attribute_instance(); 
      }
      setState(3971);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
    }
    setState(3972);
    match(VerilogParser::LP);
    setState(3973);
    expression(0);
    setState(3978);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3974);
      match(VerilogParser::CO);
      setState(3975);
      expression(0);
      setState(3980);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3981);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_callContext ------------------------------------------------------------------

VerilogParser::System_function_callContext::System_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::System_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::System_function_callContext::sys_func_call_port_list() {
  return getRuleContext<VerilogParser::Sys_func_call_port_listContext>(0);
}


size_t VerilogParser::System_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_call;
}


std::any VerilogParser::System_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_callContext* VerilogParser::system_function_call() {
  System_function_callContext *_localctx = _tracker.createInstance<System_function_callContext>(_ctx, getState());
  enterRule(_localctx, 626, VerilogParser::RuleSystem_function_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3983);
    system_function_identifier();
    setState(3985);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
    case 1: {
      setState(3984);
      sys_func_call_port_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_func_call_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_func_call_port_listContext::Sys_func_call_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Sys_func_call_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Sys_func_call_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_func_call_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_func_call_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_func_call_port_list;
}


std::any VerilogParser::Sys_func_call_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_func_call_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::sys_func_call_port_list() {
  Sys_func_call_port_listContext *_localctx = _tracker.createInstance<Sys_func_call_port_listContext>(_ctx, getState());
  enterRule(_localctx, 628, VerilogParser::RuleSys_func_call_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3987);
    match(VerilogParser::LP);
    setState(3988);
    expression(0);
    setState(3993);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3989);
      match(VerilogParser::CO);
      setState(3990);
      expression(0);
      setState(3995);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3996);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_expressionContext ------------------------------------------------------------------

VerilogParser::Base_expressionContext::Base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Base_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleBase_expression;
}


std::any VerilogParser::Base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBase_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Base_expressionContext* VerilogParser::base_expression() {
  Base_expressionContext *_localctx = _tracker.createInstance<Base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 630, VerilogParser::RuleBase_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3998);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_base_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_base_expressionContext::Constant_base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_base_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Constant_base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_base_expression;
}


std::any VerilogParser::Constant_base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_base_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::constant_base_expression() {
  Constant_base_expressionContext *_localctx = _tracker.createInstance<Constant_base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 632, VerilogParser::RuleConstant_base_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4000);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_primaryContext* VerilogParser::Constant_expressionContext::constant_primary() {
  return getRuleContext<VerilogParser::Constant_primaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::Constant_expressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_expression;
}


std::any VerilogParser::Constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Constant_expressionContext* VerilogParser::constant_expression() {
   return constant_expression(0);
}

VerilogParser::Constant_expressionContext* VerilogParser::constant_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, parentState);
  VerilogParser::Constant_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 634;
  enterRecursionRule(_localctx, 634, VerilogParser::RuleConstant_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4013);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        setState(4003);
        constant_primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI: {
        setState(4004);
        unary_operator();
        setState(4008);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4005);
            attribute_instance(); 
          }
          setState(4010);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
        }
        setState(4011);
        constant_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4128);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4126);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4015);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4016);
          match(VerilogParser::ASAS);
          setState(4020);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4017);
              attribute_instance(); 
            }
            setState(4022);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          }
          setState(4023);
          constant_expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4024);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(4025);
          _la = _input->LA(1);
          if (!(((((_la - 179) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 179)) & 67371009) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4029);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4026);
              attribute_instance(); 
            }
            setState(4031);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          }
          setState(4032);
          constant_expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4033);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(4034);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4038);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4035);
              attribute_instance(); 
            }
            setState(4040);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          }
          setState(4041);
          constant_expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4042);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(4043);
          _la = _input->LA(1);
          if (!(((((_la - 158) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 158)) & 8227) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4047);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4044);
              attribute_instance(); 
            }
            setState(4049);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          }
          setState(4050);
          constant_expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4051);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(4052);
          _la = _input->LA(1);
          if (!(((((_la - 162) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 162)) & 8858370305) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4056);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4053);
              attribute_instance(); 
            }
            setState(4058);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
          }
          setState(4059);
          constant_expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4060);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4061);
          _la = _input->LA(1);
          if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 156)) & 9219) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4065);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4062);
              attribute_instance(); 
            }
            setState(4067);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
          }
          setState(4068);
          constant_expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4069);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4070);
          match(VerilogParser::AM);
          setState(4074);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4071);
              attribute_instance(); 
            }
            setState(4076);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
          }
          setState(4077);
          constant_expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4078);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4079);
          _la = _input->LA(1);
          if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 168)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4083);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4080);
              attribute_instance(); 
            }
            setState(4085);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx);
          }
          setState(4086);
          constant_expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4087);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4088);
          match(VerilogParser::VL);
          setState(4092);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4089);
              attribute_instance(); 
            }
            setState(4094);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
          }
          setState(4095);
          constant_expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4096);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4097);
          match(VerilogParser::AMAM);
          setState(4101);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4098);
              attribute_instance(); 
            }
            setState(4103);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx);
          }
          setState(4104);
          constant_expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4105);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4106);
          match(VerilogParser::VLVL);
          setState(4110);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4107);
              attribute_instance(); 
            }
            setState(4112);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
          }
          setState(4113);
          constant_expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(4114);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4115);
          match(VerilogParser::QM);
          setState(4119);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4116);
              attribute_instance(); 
            }
            setState(4121);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
          }
          setState(4122);
          constant_expression(0);
          setState(4123);
          match(VerilogParser::CL);
          setState(4124);
          constant_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4130);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Constant_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_mintypmax_expressionContext::Constant_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_mintypmax_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_mintypmax_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Constant_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Constant_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_mintypmax_expression;
}


std::any VerilogParser::Constant_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::constant_mintypmax_expression() {
  Constant_mintypmax_expressionContext *_localctx = _tracker.createInstance<Constant_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 636, VerilogParser::RuleConstant_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4131);
    constant_expression(0);
    setState(4137);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4132);
      match(VerilogParser::CL);
      setState(4133);
      constant_expression(0);
      setState(4134);
      match(VerilogParser::CL);
      setState(4135);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_range_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_range_expressionContext::Constant_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_range_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::Constant_range_expressionContext::constant_base_expression() {
  return getRuleContext<VerilogParser::Constant_base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Constant_range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Constant_range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_range_expression;
}


std::any VerilogParser::Constant_range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_range_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::constant_range_expression() {
  Constant_range_expressionContext *_localctx = _tracker.createInstance<Constant_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 638, VerilogParser::RuleConstant_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4152);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4139);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4140);
      msb_constant_expression();
      setState(4141);
      match(VerilogParser::CL);
      setState(4142);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4144);
      constant_base_expression();
      setState(4145);
      match(VerilogParser::PLCL);
      setState(4146);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4148);
      constant_base_expression();
      setState(4149);
      match(VerilogParser::MICL);
      setState(4150);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dimension_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Dimension_constant_expressionContext::Dimension_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Dimension_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Dimension_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension_constant_expression;
}


std::any VerilogParser::Dimension_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::dimension_constant_expression() {
  Dimension_constant_expressionContext *_localctx = _tracker.createInstance<Dimension_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 640, VerilogParser::RuleDimension_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4154);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

VerilogParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::PrimaryContext* VerilogParser::ExpressionContext::primary() {
  return getRuleContext<VerilogParser::PrimaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::ExpressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::ExpressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::ExpressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ExpressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ExpressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::ExpressionContext::getRuleIndex() const {
  return VerilogParser::RuleExpression;
}


std::any VerilogParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::ExpressionContext* VerilogParser::expression() {
   return expression(0);
}

VerilogParser::ExpressionContext* VerilogParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  VerilogParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 642;
  enterRecursionRule(_localctx, 642, VerilogParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4167);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        setState(4157);
        primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI: {
        setState(4158);
        unary_operator();
        setState(4162);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4159);
            attribute_instance(); 
          }
          setState(4164);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
        }
        setState(4165);
        primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4282);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4280);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4169);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4170);
          match(VerilogParser::ASAS);
          setState(4174);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4171);
              attribute_instance(); 
            }
            setState(4176);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          }
          setState(4177);
          expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4178);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(4179);
          _la = _input->LA(1);
          if (!(((((_la - 179) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 179)) & 67371009) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4183);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4180);
              attribute_instance(); 
            }
            setState(4185);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          }
          setState(4186);
          expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4187);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(4188);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4192);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4189);
              attribute_instance(); 
            }
            setState(4194);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          }
          setState(4195);
          expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4196);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(4197);
          _la = _input->LA(1);
          if (!(((((_la - 158) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 158)) & 8227) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4201);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4198);
              attribute_instance(); 
            }
            setState(4203);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          }
          setState(4204);
          expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4205);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(4206);
          _la = _input->LA(1);
          if (!(((((_la - 162) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 162)) & 8858370305) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4210);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4207);
              attribute_instance(); 
            }
            setState(4212);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx);
          }
          setState(4213);
          expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4214);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4215);
          _la = _input->LA(1);
          if (!(((((_la - 156) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 156)) & 9219) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4219);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4216);
              attribute_instance(); 
            }
            setState(4221);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
          }
          setState(4222);
          expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4223);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4224);
          match(VerilogParser::AM);
          setState(4228);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4225);
              attribute_instance(); 
            }
            setState(4230);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
          }
          setState(4231);
          expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4232);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4233);
          _la = _input->LA(1);
          if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 168)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4237);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4234);
              attribute_instance(); 
            }
            setState(4239);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx);
          }
          setState(4240);
          expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4241);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4242);
          match(VerilogParser::VL);
          setState(4246);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4243);
              attribute_instance(); 
            }
            setState(4248);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx);
          }
          setState(4249);
          expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4250);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4251);
          match(VerilogParser::AMAM);
          setState(4255);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4252);
              attribute_instance(); 
            }
            setState(4257);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
          }
          setState(4258);
          expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4259);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4260);
          match(VerilogParser::VLVL);
          setState(4264);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4261);
              attribute_instance(); 
            }
            setState(4266);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
          }
          setState(4267);
          expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4268);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4269);
          match(VerilogParser::QM);
          setState(4273);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4270);
              attribute_instance(); 
            }
            setState(4275);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
          }
          setState(4276);
          expression(0);
          setState(4277);
          match(VerilogParser::CL);
          setState(4278);
          expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4284);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Lsb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Lsb_constant_expressionContext::Lsb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Lsb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Lsb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleLsb_constant_expression;
}


std::any VerilogParser::Lsb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::lsb_constant_expression() {
  Lsb_constant_expressionContext *_localctx = _tracker.createInstance<Lsb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 644, VerilogParser::RuleLsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4285);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Mintypmax_expressionContext::Mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Mintypmax_expressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Mintypmax_expressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMintypmax_expression;
}


std::any VerilogParser::Mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::mintypmax_expression() {
  Mintypmax_expressionContext *_localctx = _tracker.createInstance<Mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 646, VerilogParser::RuleMintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4287);
    expression(0);
    setState(4293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4288);
      match(VerilogParser::CL);
      setState(4289);
      expression(0);
      setState(4290);
      match(VerilogParser::CL);
      setState(4291);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_expressionContext::Module_path_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_path_primaryContext* VerilogParser::Module_path_expressionContext::module_path_primary() {
  return getRuleContext<VerilogParser::Module_path_primaryContext>(0);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::Module_path_expressionContext::unary_module_path_operator() {
  return getRuleContext<VerilogParser::Unary_module_path_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_path_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_path_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Module_path_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_expression;
}


std::any VerilogParser::Module_path_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression() {
   return module_path_expression(0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Module_path_expressionContext *_localctx = _tracker.createInstance<Module_path_expressionContext>(_ctx, parentState);
  VerilogParser::Module_path_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 648;
  enterRecursionRule(_localctx, 648, VerilogParser::RuleModule_path_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4306);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER:
      case VerilogParser::UNIT_NUMBER:
      case VerilogParser::IDENTIFIER: {
        setState(4296);
        module_path_primary();
        break;
      }

      case VerilogParser::CATI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::EM:
      case VerilogParser::TI: {
        setState(4297);
        unary_module_path_operator();
        setState(4301);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4298);
            attribute_instance(); 
          }
          setState(4303);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
        }
        setState(4304);
        module_path_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4376);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4374);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4308);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4309);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::EQEQ

          || _la == VerilogParser::EMEQ)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4313);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4310);
              attribute_instance(); 
            }
            setState(4315);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
          }
          setState(4316);
          module_path_expression(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4317);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4318);
          match(VerilogParser::AM);
          setState(4322);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4319);
              attribute_instance(); 
            }
            setState(4324);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx);
          }
          setState(4325);
          module_path_expression(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4326);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4327);
          _la = _input->LA(1);
          if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 168)) & 8257) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4331);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4328);
              attribute_instance(); 
            }
            setState(4333);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx);
          }
          setState(4334);
          module_path_expression(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4335);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4336);
          match(VerilogParser::VL);
          setState(4340);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4337);
              attribute_instance(); 
            }
            setState(4342);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
          }
          setState(4343);
          module_path_expression(5);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4344);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4345);
          match(VerilogParser::AMAM);
          setState(4349);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4346);
              attribute_instance(); 
            }
            setState(4351);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx);
          }
          setState(4352);
          module_path_expression(4);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4353);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4354);
          match(VerilogParser::VLVL);
          setState(4358);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4355);
              attribute_instance(); 
            }
            setState(4360);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx);
          }
          setState(4361);
          module_path_expression(3);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4362);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4363);
          match(VerilogParser::QM);
          setState(4367);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4364);
              attribute_instance(); 
            }
            setState(4369);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
          }
          setState(4370);
          module_path_expression(0);
          setState(4371);
          match(VerilogParser::CL);
          setState(4372);
          module_path_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4378);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Module_path_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_mintypmax_expressionContext::Module_path_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Module_path_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Module_path_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_mintypmax_expression;
}


std::any VerilogParser::Module_path_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::module_path_mintypmax_expression() {
  Module_path_mintypmax_expressionContext *_localctx = _tracker.createInstance<Module_path_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 650, VerilogParser::RuleModule_path_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4379);
    module_path_expression(0);
    setState(4385);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4380);
      match(VerilogParser::CL);
      setState(4381);
      module_path_expression(0);
      setState(4382);
      match(VerilogParser::CL);
      setState(4383);
      module_path_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Msb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Msb_constant_expressionContext::Msb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Msb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Msb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMsb_constant_expression;
}


std::any VerilogParser::Msb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::msb_constant_expression() {
  Msb_constant_expressionContext *_localctx = _tracker.createInstance<Msb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 652, VerilogParser::RuleMsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4387);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_expressionContext ------------------------------------------------------------------

VerilogParser::Range_expressionContext::Range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Range_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Base_expressionContext* VerilogParser::Range_expressionContext::base_expression() {
  return getRuleContext<VerilogParser::Base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleRange_expression;
}


std::any VerilogParser::Range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_expressionContext* VerilogParser::range_expression() {
  Range_expressionContext *_localctx = _tracker.createInstance<Range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 654, VerilogParser::RuleRange_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4389);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4390);
      msb_constant_expression();
      setState(4391);
      match(VerilogParser::CL);
      setState(4392);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4394);
      base_expression();
      setState(4395);
      match(VerilogParser::PLCL);
      setState(4396);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4398);
      base_expression();
      setState(4399);
      match(VerilogParser::MICL);
      setState(4400);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Width_constant_expressionContext::Width_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Width_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Width_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_constant_expression;
}


std::any VerilogParser::Width_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::width_constant_expression() {
  Width_constant_expressionContext *_localctx = _tracker.createInstance<Width_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 656, VerilogParser::RuleWidth_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4404);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_primaryContext ------------------------------------------------------------------

VerilogParser::Constant_primaryContext::Constant_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Constant_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Constant_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Constant_primaryContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_primaryContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::Constant_primaryContext::constant_multiple_concatenation() {
  return getRuleContext<VerilogParser::Constant_multiple_concatenationContext>(0);
}

VerilogParser::Constant_function_callContext* VerilogParser::Constant_primaryContext::constant_function_call() {
  return getRuleContext<VerilogParser::Constant_function_callContext>(0);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::Constant_primaryContext::constant_system_function_call() {
  return getRuleContext<VerilogParser::Constant_system_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Constant_primaryContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::Constant_primaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::Constant_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_primary;
}


std::any VerilogParser::Constant_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_primaryContext* VerilogParser::constant_primary() {
  Constant_primaryContext *_localctx = _tracker.createInstance<Constant_primaryContext>(_ctx, getState());
  enterRule(_localctx, 658, VerilogParser::RuleConstant_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4423);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 452, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4406);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4407);
      identifier();
      setState(4412);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
      case 1: {
        setState(4408);
        match(VerilogParser::LB);
        setState(4409);
        constant_range_expression();
        setState(4410);
        match(VerilogParser::RB);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4414);
      constant_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4415);
      constant_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4416);
      constant_function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4417);
      constant_system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4418);
      match(VerilogParser::LP);
      setState(4419);
      constant_mintypmax_expression();
      setState(4420);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4422);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_primaryContext ------------------------------------------------------------------

VerilogParser::Module_path_primaryContext::Module_path_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Module_path_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Module_path_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_multiple_concatenation() {
  return getRuleContext<VerilogParser::Module_path_multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::Module_path_primaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::Module_path_primaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::Module_path_primaryContext::module_path_mintypmax_expression() {
  return getRuleContext<VerilogParser::Module_path_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_path_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_primary;
}


std::any VerilogParser::Module_path_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_primaryContext* VerilogParser::module_path_primary() {
  Module_path_primaryContext *_localctx = _tracker.createInstance<Module_path_primaryContext>(_ctx, getState());
  enterRule(_localctx, 660, VerilogParser::RuleModule_path_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4435);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 453, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4425);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4426);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4427);
      module_path_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4428);
      module_path_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4429);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4430);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4431);
      match(VerilogParser::LP);
      setState(4432);
      module_path_mintypmax_expression();
      setState(4433);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

VerilogParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::PrimaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::PrimaryContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::PrimaryContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::PrimaryContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::PrimaryContext::multiple_concatenation() {
  return getRuleContext<VerilogParser::Multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::PrimaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::PrimaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::PrimaryContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::PrimaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::PrimaryContext::getRuleIndex() const {
  return VerilogParser::RulePrimary;
}


std::any VerilogParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPrimary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PrimaryContext* VerilogParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 662, VerilogParser::RulePrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4451);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 455, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4437);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4438);
      hierarchical_identifier();
      setState(4440);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
      case 1: {
        setState(4439);
        select_();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4442);
      concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4443);
      multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4444);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4445);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4446);
      match(VerilogParser::LP);
      setState(4447);
      mintypmax_expression();
      setState(4448);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4450);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_Context ------------------------------------------------------------------

VerilogParser::Select_Context::Select_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Select_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Range_expressionContext* VerilogParser::Select_Context::range_expression() {
  return getRuleContext<VerilogParser::Range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Select_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Select_Context::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Select_Context::getRuleIndex() const {
  return VerilogParser::RuleSelect_;
}


std::any VerilogParser::Select_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSelect_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Select_Context* VerilogParser::select_() {
  Select_Context *_localctx = _tracker.createInstance<Select_Context>(_ctx, getState());
  enterRule(_localctx, 664, VerilogParser::RuleSelect_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4454);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
    case 1: {
      setState(4453);
      bit_select();
      break;
    }

    default:
      break;
    }
    setState(4456);
    match(VerilogParser::LB);
    setState(4457);
    range_expression();
    setState(4458);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_selectContext ------------------------------------------------------------------

VerilogParser::Bit_selectContext::Bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Bit_selectContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Bit_selectContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleBit_select;
}


std::any VerilogParser::Bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Bit_selectContext* VerilogParser::bit_select() {
  Bit_selectContext *_localctx = _tracker.createInstance<Bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 666, VerilogParser::RuleBit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4464); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4460);
              match(VerilogParser::LB);
              setState(4461);
              expression(0);
              setState(4462);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4466); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 457, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_lvalueContext ------------------------------------------------------------------

VerilogParser::Net_lvalueContext::Net_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Net_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Const_selectContext* VerilogParser::Net_lvalueContext::const_select() {
  return getRuleContext<VerilogParser::Const_selectContext>(0);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Net_lvalueContext *> VerilogParser::Net_lvalueContext::net_lvalue() {
  return getRuleContexts<VerilogParser::Net_lvalueContext>();
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_lvalueContext::net_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Net_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Net_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Net_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleNet_lvalue;
}


std::any VerilogParser::Net_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_lvalueContext* VerilogParser::net_lvalue() {
  Net_lvalueContext *_localctx = _tracker.createInstance<Net_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 668, VerilogParser::RuleNet_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4483);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4468);
        hierarchical_identifier();
        setState(4470);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4469);
          const_select();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4472);
        match(VerilogParser::LC);
        setState(4473);
        net_lvalue();
        setState(4478);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4474);
          match(VerilogParser::CO);
          setState(4475);
          net_lvalue();
          setState(4480);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4481);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_selectContext ------------------------------------------------------------------

VerilogParser::Const_selectContext::Const_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Const_selectContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Const_selectContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Const_selectContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Const_selectContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Const_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_select;
}


std::any VerilogParser::Const_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_selectContext* VerilogParser::const_select() {
  Const_selectContext *_localctx = _tracker.createInstance<Const_selectContext>(_ctx, getState());
  enterRule(_localctx, 670, VerilogParser::RuleConst_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4486);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      setState(4485);
      const_bit_select();
      break;
    }

    default:
      break;
    }
    setState(4488);
    match(VerilogParser::LB);
    setState(4489);
    constant_range_expression();
    setState(4490);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_bit_selectContext ------------------------------------------------------------------

VerilogParser::Const_bit_selectContext::Const_bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Const_bit_selectContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Const_bit_selectContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Const_bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_bit_select;
}


std::any VerilogParser::Const_bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_bit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_bit_selectContext* VerilogParser::const_bit_select() {
  Const_bit_selectContext *_localctx = _tracker.createInstance<Const_bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 672, VerilogParser::RuleConst_bit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4496); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4492);
              match(VerilogParser::LB);
              setState(4493);
              constant_expression(0);
              setState(4494);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4498); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_lvalueContext ------------------------------------------------------------------

VerilogParser::Variable_lvalueContext::Variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Variable_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::Variable_lvalueContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Variable_lvalueContext *> VerilogParser::Variable_lvalueContext::variable_lvalue() {
  return getRuleContexts<VerilogParser::Variable_lvalueContext>();
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_lvalueContext::variable_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Variable_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Variable_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_lvalue;
}


std::any VerilogParser::Variable_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_lvalueContext* VerilogParser::variable_lvalue() {
  Variable_lvalueContext *_localctx = _tracker.createInstance<Variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 674, VerilogParser::RuleVariable_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4515);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4500);
        hierarchical_identifier();
        setState(4502);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4501);
          select_();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4504);
        match(VerilogParser::LC);
        setState(4505);
        variable_lvalue();
        setState(4510);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4506);
          match(VerilogParser::CO);
          setState(4507);
          variable_lvalue();
          setState(4512);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4513);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_operator;
}


std::any VerilogParser::Unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_operatorContext* VerilogParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 676, VerilogParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4517);
    _la = _input->LA(1);
    if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 276220618465) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_module_path_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_module_path_operatorContext::Unary_module_path_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_module_path_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_module_path_operator;
}


std::any VerilogParser::Unary_module_path_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_module_path_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::unary_module_path_operator() {
  Unary_module_path_operatorContext *_localctx = _tracker.createInstance<Unary_module_path_operatorContext>(_ctx, getState());
  enterRule(_localctx, 678, VerilogParser::RuleUnary_module_path_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4519);
    _la = _input->LA(1);
    if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 274878441185) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

VerilogParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Decimal_numberContext* VerilogParser::NumberContext::decimal_number() {
  return getRuleContext<VerilogParser::Decimal_numberContext>(0);
}

VerilogParser::Octal_numberContext* VerilogParser::NumberContext::octal_number() {
  return getRuleContext<VerilogParser::Octal_numberContext>(0);
}

VerilogParser::Binary_numberContext* VerilogParser::NumberContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Hex_numberContext* VerilogParser::NumberContext::hex_number() {
  return getRuleContext<VerilogParser::Hex_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::NumberContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}


size_t VerilogParser::NumberContext::getRuleIndex() const {
  return VerilogParser::RuleNumber;
}


std::any VerilogParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NumberContext* VerilogParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 680, VerilogParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4521);
      decimal_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4522);
      octal_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4523);
      binary_number();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4524);
      hex_number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4525);
      real_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_numberContext ------------------------------------------------------------------

VerilogParser::Real_numberContext::Real_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Fixed_point_numberContext* VerilogParser::Real_numberContext::fixed_point_number() {
  return getRuleContext<VerilogParser::Fixed_point_numberContext>(0);
}

VerilogParser::Exponential_numberContext* VerilogParser::Real_numberContext::exponential_number() {
  return getRuleContext<VerilogParser::Exponential_numberContext>(0);
}

VerilogParser::Unit_numberContext* VerilogParser::Real_numberContext::unit_number() {
  return getRuleContext<VerilogParser::Unit_numberContext>(0);
}


size_t VerilogParser::Real_numberContext::getRuleIndex() const {
  return VerilogParser::RuleReal_number;
}


std::any VerilogParser::Real_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_numberContext* VerilogParser::real_number() {
  Real_numberContext *_localctx = _tracker.createInstance<Real_numberContext>(_ctx, getState());
  enterRule(_localctx, 682, VerilogParser::RuleReal_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4531);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FIXED_POINT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(4528);
        fixed_point_number();
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(4529);
        exponential_number();
        break;
      }

      case VerilogParser::UNIT_NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(4530);
        unit_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_numberContext ------------------------------------------------------------------

VerilogParser::Decimal_numberContext::Decimal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Decimal_numberContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Decimal_baseContext* VerilogParser::Decimal_numberContext::decimal_base() {
  return getRuleContext<VerilogParser::Decimal_baseContext>(0);
}

VerilogParser::Decimal_valueContext* VerilogParser::Decimal_numberContext::decimal_value() {
  return getRuleContext<VerilogParser::Decimal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Decimal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Decimal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_number;
}


std::any VerilogParser::Decimal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_numberContext* VerilogParser::decimal_number() {
  Decimal_numberContext *_localctx = _tracker.createInstance<Decimal_numberContext>(_ctx, getState());
  enterRule(_localctx, 684, VerilogParser::RuleDecimal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4540);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4533);
      unsigned_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4535);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::UNSIGNED_NUMBER) {
        setState(4534);
        size();
      }
      setState(4537);
      decimal_base();
      setState(4538);
      decimal_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_numberContext ------------------------------------------------------------------

VerilogParser::Binary_numberContext::Binary_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_baseContext* VerilogParser::Binary_numberContext::binary_base() {
  return getRuleContext<VerilogParser::Binary_baseContext>(0);
}

VerilogParser::Binary_valueContext* VerilogParser::Binary_numberContext::binary_value() {
  return getRuleContext<VerilogParser::Binary_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Binary_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Binary_numberContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_number;
}


std::any VerilogParser::Binary_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_numberContext* VerilogParser::binary_number() {
  Binary_numberContext *_localctx = _tracker.createInstance<Binary_numberContext>(_ctx, getState());
  enterRule(_localctx, 686, VerilogParser::RuleBinary_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4542);
      size();
    }
    setState(4545);
    binary_base();
    setState(4546);
    binary_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_numberContext ------------------------------------------------------------------

VerilogParser::Octal_numberContext::Octal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Octal_baseContext* VerilogParser::Octal_numberContext::octal_base() {
  return getRuleContext<VerilogParser::Octal_baseContext>(0);
}

VerilogParser::Octal_valueContext* VerilogParser::Octal_numberContext::octal_value() {
  return getRuleContext<VerilogParser::Octal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Octal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Octal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_number;
}


std::any VerilogParser::Octal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_numberContext* VerilogParser::octal_number() {
  Octal_numberContext *_localctx = _tracker.createInstance<Octal_numberContext>(_ctx, getState());
  enterRule(_localctx, 688, VerilogParser::RuleOctal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4549);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4548);
      size();
    }
    setState(4551);
    octal_base();
    setState(4552);
    octal_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_numberContext ------------------------------------------------------------------

VerilogParser::Hex_numberContext::Hex_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hex_baseContext* VerilogParser::Hex_numberContext::hex_base() {
  return getRuleContext<VerilogParser::Hex_baseContext>(0);
}

VerilogParser::Hex_valueContext* VerilogParser::Hex_numberContext::hex_value() {
  return getRuleContext<VerilogParser::Hex_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Hex_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Hex_numberContext::getRuleIndex() const {
  return VerilogParser::RuleHex_number;
}


std::any VerilogParser::Hex_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_numberContext* VerilogParser::hex_number() {
  Hex_numberContext *_localctx = _tracker.createInstance<Hex_numberContext>(_ctx, getState());
  enterRule(_localctx, 690, VerilogParser::RuleHex_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4555);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4554);
      size();
    }
    setState(4557);
    hex_base();
    setState(4558);
    hex_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeContext ------------------------------------------------------------------

VerilogParser::SizeContext::SizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::SizeContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::SizeContext::getRuleIndex() const {
  return VerilogParser::RuleSize;
}


std::any VerilogParser::SizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSize(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::SizeContext* VerilogParser::size() {
  SizeContext *_localctx = _tracker.createInstance<SizeContext>(_ctx, getState());
  enterRule(_localctx, 692, VerilogParser::RuleSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4560);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fixed_point_numberContext ------------------------------------------------------------------

VerilogParser::Fixed_point_numberContext::Fixed_point_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fixed_point_numberContext::FIXED_POINT_NUMBER() {
  return getToken(VerilogParser::FIXED_POINT_NUMBER, 0);
}


size_t VerilogParser::Fixed_point_numberContext::getRuleIndex() const {
  return VerilogParser::RuleFixed_point_number;
}


std::any VerilogParser::Fixed_point_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFixed_point_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fixed_point_numberContext* VerilogParser::fixed_point_number() {
  Fixed_point_numberContext *_localctx = _tracker.createInstance<Fixed_point_numberContext>(_ctx, getState());
  enterRule(_localctx, 694, VerilogParser::RuleFixed_point_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4562);
    match(VerilogParser::FIXED_POINT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unit_numberContext ------------------------------------------------------------------

VerilogParser::Unit_numberContext::Unit_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unit_numberContext::UNIT_NUMBER() {
  return getToken(VerilogParser::UNIT_NUMBER, 0);
}


size_t VerilogParser::Unit_numberContext::getRuleIndex() const {
  return VerilogParser::RuleUnit_number;
}


std::any VerilogParser::Unit_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnit_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unit_numberContext* VerilogParser::unit_number() {
  Unit_numberContext *_localctx = _tracker.createInstance<Unit_numberContext>(_ctx, getState());
  enterRule(_localctx, 696, VerilogParser::RuleUnit_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4564);
    match(VerilogParser::UNIT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exponential_numberContext ------------------------------------------------------------------

VerilogParser::Exponential_numberContext::Exponential_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Exponential_numberContext::EXPONENTIAL_NUMBER() {
  return getToken(VerilogParser::EXPONENTIAL_NUMBER, 0);
}


size_t VerilogParser::Exponential_numberContext::getRuleIndex() const {
  return VerilogParser::RuleExponential_number;
}


std::any VerilogParser::Exponential_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExponential_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Exponential_numberContext* VerilogParser::exponential_number() {
  Exponential_numberContext *_localctx = _tracker.createInstance<Exponential_numberContext>(_ctx, getState());
  enterRule(_localctx, 698, VerilogParser::RuleExponential_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4566);
    match(VerilogParser::EXPONENTIAL_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unsigned_numberContext ------------------------------------------------------------------

VerilogParser::Unsigned_numberContext::Unsigned_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unsigned_numberContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::Unsigned_numberContext::getRuleIndex() const {
  return VerilogParser::RuleUnsigned_number;
}


std::any VerilogParser::Unsigned_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnsigned_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unsigned_numberContext* VerilogParser::unsigned_number() {
  Unsigned_numberContext *_localctx = _tracker.createInstance<Unsigned_numberContext>(_ctx, getState());
  enterRule(_localctx, 700, VerilogParser::RuleUnsigned_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4568);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_valueContext ------------------------------------------------------------------

VerilogParser::Decimal_valueContext::Decimal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::X_OR_Z_UNDERSCORE() {
  return getToken(VerilogParser::X_OR_Z_UNDERSCORE, 0);
}


size_t VerilogParser::Decimal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_value;
}


std::any VerilogParser::Decimal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_valueContext* VerilogParser::decimal_value() {
  Decimal_valueContext *_localctx = _tracker.createInstance<Decimal_valueContext>(_ctx, getState());
  enterRule(_localctx, 702, VerilogParser::RuleDecimal_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4570);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::UNSIGNED_NUMBER

    || _la == VerilogParser::X_OR_Z_UNDERSCORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_valueContext ------------------------------------------------------------------

VerilogParser::Binary_valueContext::Binary_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_valueContext::BINARY_VALUE() {
  return getToken(VerilogParser::BINARY_VALUE, 0);
}


size_t VerilogParser::Binary_valueContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_value;
}


std::any VerilogParser::Binary_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_valueContext* VerilogParser::binary_value() {
  Binary_valueContext *_localctx = _tracker.createInstance<Binary_valueContext>(_ctx, getState());
  enterRule(_localctx, 704, VerilogParser::RuleBinary_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4572);
    match(VerilogParser::BINARY_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_valueContext ------------------------------------------------------------------

VerilogParser::Octal_valueContext::Octal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_valueContext::OCTAL_VALUE() {
  return getToken(VerilogParser::OCTAL_VALUE, 0);
}


size_t VerilogParser::Octal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_value;
}


std::any VerilogParser::Octal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_valueContext* VerilogParser::octal_value() {
  Octal_valueContext *_localctx = _tracker.createInstance<Octal_valueContext>(_ctx, getState());
  enterRule(_localctx, 706, VerilogParser::RuleOctal_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4574);
    match(VerilogParser::OCTAL_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_valueContext ------------------------------------------------------------------

VerilogParser::Hex_valueContext::Hex_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_valueContext::HEX_VALUE() {
  return getToken(VerilogParser::HEX_VALUE, 0);
}


size_t VerilogParser::Hex_valueContext::getRuleIndex() const {
  return VerilogParser::RuleHex_value;
}


std::any VerilogParser::Hex_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_valueContext* VerilogParser::hex_value() {
  Hex_valueContext *_localctx = _tracker.createInstance<Hex_valueContext>(_ctx, getState());
  enterRule(_localctx, 708, VerilogParser::RuleHex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4576);
    match(VerilogParser::HEX_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_baseContext ------------------------------------------------------------------

VerilogParser::Decimal_baseContext::Decimal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_baseContext::DECIMAL_BASE() {
  return getToken(VerilogParser::DECIMAL_BASE, 0);
}


size_t VerilogParser::Decimal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_base;
}


std::any VerilogParser::Decimal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_baseContext* VerilogParser::decimal_base() {
  Decimal_baseContext *_localctx = _tracker.createInstance<Decimal_baseContext>(_ctx, getState());
  enterRule(_localctx, 710, VerilogParser::RuleDecimal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4578);
    match(VerilogParser::DECIMAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_baseContext ------------------------------------------------------------------

VerilogParser::Binary_baseContext::Binary_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_baseContext::BINARY_BASE() {
  return getToken(VerilogParser::BINARY_BASE, 0);
}


size_t VerilogParser::Binary_baseContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_base;
}


std::any VerilogParser::Binary_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_baseContext* VerilogParser::binary_base() {
  Binary_baseContext *_localctx = _tracker.createInstance<Binary_baseContext>(_ctx, getState());
  enterRule(_localctx, 712, VerilogParser::RuleBinary_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4580);
    match(VerilogParser::BINARY_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_baseContext ------------------------------------------------------------------

VerilogParser::Octal_baseContext::Octal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_baseContext::OCTAL_BASE() {
  return getToken(VerilogParser::OCTAL_BASE, 0);
}


size_t VerilogParser::Octal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_base;
}


std::any VerilogParser::Octal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_baseContext* VerilogParser::octal_base() {
  Octal_baseContext *_localctx = _tracker.createInstance<Octal_baseContext>(_ctx, getState());
  enterRule(_localctx, 714, VerilogParser::RuleOctal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4582);
    match(VerilogParser::OCTAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_baseContext ------------------------------------------------------------------

VerilogParser::Hex_baseContext::Hex_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_baseContext::HEX_BASE() {
  return getToken(VerilogParser::HEX_BASE, 0);
}


size_t VerilogParser::Hex_baseContext::getRuleIndex() const {
  return VerilogParser::RuleHex_base;
}


std::any VerilogParser::Hex_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_baseContext* VerilogParser::hex_base() {
  Hex_baseContext *_localctx = _tracker.createInstance<Hex_baseContext>(_ctx, getState());
  enterRule(_localctx, 716, VerilogParser::RuleHex_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4584);
    match(VerilogParser::HEX_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_Context ------------------------------------------------------------------

VerilogParser::String_Context::String_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::String_Context::STRING() {
  return getToken(VerilogParser::STRING, 0);
}


size_t VerilogParser::String_Context::getRuleIndex() const {
  return VerilogParser::RuleString_;
}


std::any VerilogParser::String_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitString_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::String_Context* VerilogParser::string_() {
  String_Context *_localctx = _tracker.createInstance<String_Context>(_ctx, getState());
  enterRule(_localctx, 718, VerilogParser::RuleString_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4586);
    match(VerilogParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_instanceContext ------------------------------------------------------------------

VerilogParser::Attribute_instanceContext::Attribute_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::AS() {
  return getTokens(VerilogParser::AS);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::AS(size_t i) {
  return getToken(VerilogParser::AS, i);
}

std::vector<VerilogParser::Attr_specContext *> VerilogParser::Attribute_instanceContext::attr_spec() {
  return getRuleContexts<VerilogParser::Attr_specContext>();
}

VerilogParser::Attr_specContext* VerilogParser::Attribute_instanceContext::attr_spec(size_t i) {
  return getRuleContext<VerilogParser::Attr_specContext>(i);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Attribute_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleAttribute_instance;
}


std::any VerilogParser::Attribute_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttribute_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attribute_instanceContext* VerilogParser::attribute_instance() {
  Attribute_instanceContext *_localctx = _tracker.createInstance<Attribute_instanceContext>(_ctx, getState());
  enterRule(_localctx, 720, VerilogParser::RuleAttribute_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4588);
    match(VerilogParser::LP);
    setState(4589);
    match(VerilogParser::AS);
    setState(4590);
    attr_spec();
    setState(4595);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(4591);
      match(VerilogParser::CO);
      setState(4592);
      attr_spec();
      setState(4597);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4598);
    match(VerilogParser::AS);
    setState(4599);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_specContext ------------------------------------------------------------------

VerilogParser::Attr_specContext::Attr_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Attr_nameContext* VerilogParser::Attr_specContext::attr_name() {
  return getRuleContext<VerilogParser::Attr_nameContext>(0);
}

tree::TerminalNode* VerilogParser::Attr_specContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Attr_specContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Attr_specContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_spec;
}


std::any VerilogParser::Attr_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_specContext* VerilogParser::attr_spec() {
  Attr_specContext *_localctx = _tracker.createInstance<Attr_specContext>(_ctx, getState());
  enterRule(_localctx, 722, VerilogParser::RuleAttr_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4601);
    attr_name();
    setState(4604);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(4602);
      match(VerilogParser::EQ);
      setState(4603);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

VerilogParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Attr_nameContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Attr_nameContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_name;
}


std::any VerilogParser::Attr_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_nameContext* VerilogParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 724, VerilogParser::RuleAttr_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4606);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_identifierContext ------------------------------------------------------------------

VerilogParser::Block_identifierContext::Block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_identifier;
}


std::any VerilogParser::Block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_identifierContext* VerilogParser::block_identifier() {
  Block_identifierContext *_localctx = _tracker.createInstance<Block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 726, VerilogParser::RuleBlock_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4608);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_identifierContext ------------------------------------------------------------------

VerilogParser::Cell_identifierContext::Cell_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Cell_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Cell_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleCell_identifier;
}


std::any VerilogParser::Cell_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_identifierContext* VerilogParser::cell_identifier() {
  Cell_identifierContext *_localctx = _tracker.createInstance<Cell_identifierContext>(_ctx, getState());
  enterRule(_localctx, 728, VerilogParser::RuleCell_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4610);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_identifierContext ------------------------------------------------------------------

VerilogParser::Config_identifierContext::Config_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Config_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Config_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_identifier;
}


std::any VerilogParser::Config_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_identifierContext* VerilogParser::config_identifier() {
  Config_identifierContext *_localctx = _tracker.createInstance<Config_identifierContext>(_ctx, getState());
  enterRule(_localctx, 730, VerilogParser::RuleConfig_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4612);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Escaped_identifierContext ------------------------------------------------------------------

VerilogParser::Escaped_identifierContext::Escaped_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Escaped_identifierContext::ESCAPED_IDENTIFIER() {
  return getToken(VerilogParser::ESCAPED_IDENTIFIER, 0);
}


size_t VerilogParser::Escaped_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEscaped_identifier;
}


std::any VerilogParser::Escaped_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEscaped_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Escaped_identifierContext* VerilogParser::escaped_identifier() {
  Escaped_identifierContext *_localctx = _tracker.createInstance<Escaped_identifierContext>(_ctx, getState());
  enterRule(_localctx, 732, VerilogParser::RuleEscaped_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4614);
    match(VerilogParser::ESCAPED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_identifierContext ------------------------------------------------------------------

VerilogParser::Event_identifierContext::Event_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Event_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Event_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_identifier;
}


std::any VerilogParser::Event_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_identifierContext* VerilogParser::event_identifier() {
  Event_identifierContext *_localctx = _tracker.createInstance<Event_identifierContext>(_ctx, getState());
  enterRule(_localctx, 734, VerilogParser::RuleEvent_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4616);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_identifierContext ------------------------------------------------------------------

VerilogParser::Function_identifierContext::Function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Function_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_identifier;
}


std::any VerilogParser::Function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_identifierContext* VerilogParser::function_identifier() {
  Function_identifierContext *_localctx = _tracker.createInstance<Function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 736, VerilogParser::RuleFunction_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4618);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Gate_instance_identifierContext::Gate_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Gate_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Gate_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instance_identifier;
}


std::any VerilogParser::Gate_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::gate_instance_identifier() {
  Gate_instance_identifierContext *_localctx = _tracker.createInstance<Gate_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 738, VerilogParser::RuleGate_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4620);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_identifierContext ------------------------------------------------------------------

VerilogParser::Generate_block_identifierContext::Generate_block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Generate_block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Generate_block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_identifier;
}


std::any VerilogParser::Generate_block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::generate_block_identifier() {
  Generate_block_identifierContext *_localctx = _tracker.createInstance<Generate_block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 740, VerilogParser::RuleGenerate_block_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4622);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_identifierContext ------------------------------------------------------------------

VerilogParser::Genvar_identifierContext::Genvar_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Genvar_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Genvar_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_identifier;
}


std::any VerilogParser::Genvar_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_identifierContext* VerilogParser::genvar_identifier() {
  Genvar_identifierContext *_localctx = _tracker.createInstance<Genvar_identifierContext>(_ctx, getState());
  enterRule(_localctx, 742, VerilogParser::RuleGenvar_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4624);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hierarchical_identifierContext ------------------------------------------------------------------

VerilogParser::Hierarchical_identifierContext::Hierarchical_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hierarchical_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

std::vector<VerilogParser::Hier_refContext *> VerilogParser::Hierarchical_identifierContext::hier_ref() {
  return getRuleContexts<VerilogParser::Hier_refContext>();
}

VerilogParser::Hier_refContext* VerilogParser::Hierarchical_identifierContext::hier_ref(size_t i) {
  return getRuleContext<VerilogParser::Hier_refContext>(i);
}


size_t VerilogParser::Hierarchical_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleHierarchical_identifier;
}


std::any VerilogParser::Hierarchical_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHierarchical_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::hierarchical_identifier() {
  Hierarchical_identifierContext *_localctx = _tracker.createInstance<Hierarchical_identifierContext>(_ctx, getState());
  enterRule(_localctx, 744, VerilogParser::RuleHierarchical_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4629);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4626);
        hier_ref(); 
      }
      setState(4631);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    }
    setState(4632);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hier_refContext ------------------------------------------------------------------

VerilogParser::Hier_refContext::Hier_refContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hier_refContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Hier_refContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Hier_refContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Hier_refContext::getRuleIndex() const {
  return VerilogParser::RuleHier_ref;
}


std::any VerilogParser::Hier_refContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHier_ref(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hier_refContext* VerilogParser::hier_ref() {
  Hier_refContext *_localctx = _tracker.createInstance<Hier_refContext>(_ctx, getState());
  enterRule(_localctx, 746, VerilogParser::RuleHier_ref);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4634);
    identifier();
    setState(4636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(4635);
      const_bit_select();
    }
    setState(4638);
    match(VerilogParser::DT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

VerilogParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Escaped_identifierContext* VerilogParser::IdentifierContext::escaped_identifier() {
  return getRuleContext<VerilogParser::Escaped_identifierContext>(0);
}

VerilogParser::Simple_identifierContext* VerilogParser::IdentifierContext::simple_identifier() {
  return getRuleContext<VerilogParser::Simple_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::IdentifierContext::IDENTIFIER() {
  return getToken(VerilogParser::IDENTIFIER, 0);
}


size_t VerilogParser::IdentifierContext::getRuleIndex() const {
  return VerilogParser::RuleIdentifier;
}


std::any VerilogParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::IdentifierContext* VerilogParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 748, VerilogParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4643);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4640);
        escaped_identifier();
        break;
      }

      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(4641);
        simple_identifier();
        break;
      }

      case VerilogParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 3);
        setState(4642);
        match(VerilogParser::IDENTIFIER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_port_identifierContext ------------------------------------------------------------------

VerilogParser::Input_port_identifierContext::Input_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Input_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Input_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_port_identifier;
}


std::any VerilogParser::Input_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_port_identifierContext* VerilogParser::input_port_identifier() {
  Input_port_identifierContext *_localctx = _tracker.createInstance<Input_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 750, VerilogParser::RuleInput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4645);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Instance_identifierContext ------------------------------------------------------------------

VerilogParser::Instance_identifierContext::Instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInstance_identifier;
}


std::any VerilogParser::Instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInstance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Instance_identifierContext* VerilogParser::instance_identifier() {
  Instance_identifierContext *_localctx = _tracker.createInstance<Instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 752, VerilogParser::RuleInstance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4647);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_identifierContext ------------------------------------------------------------------

VerilogParser::Library_identifierContext::Library_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Library_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Library_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_identifier;
}


std::any VerilogParser::Library_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_identifierContext* VerilogParser::library_identifier() {
  Library_identifierContext *_localctx = _tracker.createInstance<Library_identifierContext>(_ctx, getState());
  enterRule(_localctx, 754, VerilogParser::RuleLibrary_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4649);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_identifierContext ------------------------------------------------------------------

VerilogParser::Module_identifierContext::Module_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_identifier;
}


std::any VerilogParser::Module_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_identifierContext* VerilogParser::module_identifier() {
  Module_identifierContext *_localctx = _tracker.createInstance<Module_identifierContext>(_ctx, getState());
  enterRule(_localctx, 756, VerilogParser::RuleModule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4651);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Module_instance_identifierContext::Module_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance_identifier;
}


std::any VerilogParser::Module_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instance_identifierContext* VerilogParser::module_instance_identifier() {
  Module_instance_identifierContext *_localctx = _tracker.createInstance<Module_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 758, VerilogParser::RuleModule_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4653);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_identifierContext ------------------------------------------------------------------

VerilogParser::Net_identifierContext::Net_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Net_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Net_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleNet_identifier;
}


std::any VerilogParser::Net_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_identifierContext* VerilogParser::net_identifier() {
  Net_identifierContext *_localctx = _tracker.createInstance<Net_identifierContext>(_ctx, getState());
  enterRule(_localctx, 760, VerilogParser::RuleNet_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4655);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_port_identifierContext ------------------------------------------------------------------

VerilogParser::Output_port_identifierContext::Output_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Output_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Output_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_port_identifier;
}


std::any VerilogParser::Output_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_port_identifierContext* VerilogParser::output_port_identifier() {
  Output_port_identifierContext *_localctx = _tracker.createInstance<Output_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 762, VerilogParser::RuleOutput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4657);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_identifierContext ------------------------------------------------------------------

VerilogParser::Parameter_identifierContext::Parameter_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Parameter_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Parameter_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_identifier;
}


std::any VerilogParser::Parameter_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_identifierContext* VerilogParser::parameter_identifier() {
  Parameter_identifierContext *_localctx = _tracker.createInstance<Parameter_identifierContext>(_ctx, getState());
  enterRule(_localctx, 764, VerilogParser::RuleParameter_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4659);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_identifierContext ------------------------------------------------------------------

VerilogParser::Port_identifierContext::Port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Port_identifierContext::getRuleIndex() const {
  return VerilogParser::RulePort_identifier;
}


std::any VerilogParser::Port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_identifierContext* VerilogParser::port_identifier() {
  Port_identifierContext *_localctx = _tracker.createInstance<Port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 766, VerilogParser::RulePort_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4661);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_identifierContext ------------------------------------------------------------------

VerilogParser::Real_identifierContext::Real_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Real_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Real_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleReal_identifier;
}


std::any VerilogParser::Real_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_identifierContext* VerilogParser::real_identifier() {
  Real_identifierContext *_localctx = _tracker.createInstance<Real_identifierContext>(_ctx, getState());
  enterRule(_localctx, 768, VerilogParser::RuleReal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4663);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_identifierContext ------------------------------------------------------------------

VerilogParser::Simple_identifierContext::Simple_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Simple_identifierContext::SIMPLE_IDENTIFIER() {
  return getToken(VerilogParser::SIMPLE_IDENTIFIER, 0);
}


size_t VerilogParser::Simple_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_identifier;
}


std::any VerilogParser::Simple_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_identifierContext* VerilogParser::simple_identifier() {
  Simple_identifierContext *_localctx = _tracker.createInstance<Simple_identifierContext>(_ctx, getState());
  enterRule(_localctx, 770, VerilogParser::RuleSimple_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4665);
    match(VerilogParser::SIMPLE_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_identifierContext ------------------------------------------------------------------

VerilogParser::Specparam_identifierContext::Specparam_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Specparam_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Specparam_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_identifier;
}


std::any VerilogParser::Specparam_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_identifierContext* VerilogParser::specparam_identifier() {
  Specparam_identifierContext *_localctx = _tracker.createInstance<Specparam_identifierContext>(_ctx, getState());
  enterRule(_localctx, 772, VerilogParser::RuleSpecparam_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4667);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_identifierContext ------------------------------------------------------------------

VerilogParser::System_function_identifierContext::System_function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_function_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_identifier;
}


std::any VerilogParser::System_function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_identifierContext* VerilogParser::system_function_identifier() {
  System_function_identifierContext *_localctx = _tracker.createInstance<System_function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 774, VerilogParser::RuleSystem_function_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4669);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_identifierContext ------------------------------------------------------------------

VerilogParser::System_task_identifierContext::System_task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_task_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_identifier;
}


std::any VerilogParser::System_task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_identifierContext* VerilogParser::system_task_identifier() {
  System_task_identifierContext *_localctx = _tracker.createInstance<System_task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 776, VerilogParser::RuleSystem_task_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4671);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_identifierContext ------------------------------------------------------------------

VerilogParser::Task_identifierContext::Task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Task_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTask_identifier;
}


std::any VerilogParser::Task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_identifierContext* VerilogParser::task_identifier() {
  Task_identifierContext *_localctx = _tracker.createInstance<Task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 778, VerilogParser::RuleTask_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4673);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Terminal_identifierContext ------------------------------------------------------------------

VerilogParser::Terminal_identifierContext::Terminal_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Terminal_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Terminal_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTerminal_identifier;
}


std::any VerilogParser::Terminal_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTerminal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Terminal_identifierContext* VerilogParser::terminal_identifier() {
  Terminal_identifierContext *_localctx = _tracker.createInstance<Terminal_identifierContext>(_ctx, getState());
  enterRule(_localctx, 780, VerilogParser::RuleTerminal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4675);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topmodule_identifierContext ------------------------------------------------------------------

VerilogParser::Topmodule_identifierContext::Topmodule_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Topmodule_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Topmodule_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTopmodule_identifier;
}


std::any VerilogParser::Topmodule_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTopmodule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Topmodule_identifierContext* VerilogParser::topmodule_identifier() {
  Topmodule_identifierContext *_localctx = _tracker.createInstance<Topmodule_identifierContext>(_ctx, getState());
  enterRule(_localctx, 782, VerilogParser::RuleTopmodule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4677);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_identifierContext::Udp_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_identifier;
}


std::any VerilogParser::Udp_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_identifierContext* VerilogParser::udp_identifier() {
  Udp_identifierContext *_localctx = _tracker.createInstance<Udp_identifierContext>(_ctx, getState());
  enterRule(_localctx, 784, VerilogParser::RuleUdp_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4679);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_instance_identifierContext::Udp_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance_identifier;
}


std::any VerilogParser::Udp_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::udp_instance_identifier() {
  Udp_instance_identifierContext *_localctx = _tracker.createInstance<Udp_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 786, VerilogParser::RuleUdp_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4681);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_identifierContext ------------------------------------------------------------------

VerilogParser::Variable_identifierContext::Variable_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Variable_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Variable_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_identifier;
}


std::any VerilogParser::Variable_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_identifierContext* VerilogParser::variable_identifier() {
  Variable_identifierContext *_localctx = _tracker.createInstance<Variable_identifierContext>(_ctx, getState());
  enterRule(_localctx, 788, VerilogParser::RuleVariable_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4683);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool VerilogParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 205: return event_expressionSempred(antlrcpp::downCast<Event_expressionContext *>(context), predicateIndex);
    case 317: return constant_expressionSempred(antlrcpp::downCast<Constant_expressionContext *>(context), predicateIndex);
    case 321: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 324: return module_path_expressionSempred(antlrcpp::downCast<Module_path_expressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool VerilogParser::event_expressionSempred(Event_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::constant_expressionSempred(Constant_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 12);
    case 3: return precpred(_ctx, 11);
    case 4: return precpred(_ctx, 10);
    case 5: return precpred(_ctx, 9);
    case 6: return precpred(_ctx, 8);
    case 7: return precpred(_ctx, 7);
    case 8: return precpred(_ctx, 6);
    case 9: return precpred(_ctx, 5);
    case 10: return precpred(_ctx, 4);
    case 11: return precpred(_ctx, 3);
    case 12: return precpred(_ctx, 2);
    case 13: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 12);
    case 15: return precpred(_ctx, 11);
    case 16: return precpred(_ctx, 10);
    case 17: return precpred(_ctx, 9);
    case 18: return precpred(_ctx, 8);
    case 19: return precpred(_ctx, 7);
    case 20: return precpred(_ctx, 6);
    case 21: return precpred(_ctx, 5);
    case 22: return precpred(_ctx, 4);
    case 23: return precpred(_ctx, 3);
    case 24: return precpred(_ctx, 2);
    case 25: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::module_path_expressionSempred(Module_path_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 26: return precpred(_ctx, 7);
    case 27: return precpred(_ctx, 6);
    case 28: return precpred(_ctx, 5);
    case 29: return precpred(_ctx, 4);
    case 30: return precpred(_ctx, 3);
    case 31: return precpred(_ctx, 2);
    case 32: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void VerilogParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  verilogparserParserInitialize();
#else
  ::antlr4::internal::call_once(verilogparserParserOnceFlag, verilogparserParserInitialize);
#endif
}
